<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" type="text/css" href="/assets/css/materialize.css"> <link rel="stylesheet" href="https://cdn.rawgit.com/konpa/devicon/df6431e323547add1b4cf45992913f15286456d3/devicon.min.css"> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> <title>James Hamann</title> <script type="text/javascript">screen.width<=699&&(document.location="mobile.html");</script> </head> <body> <h2 style="text-align:center"> Latest Blog Posts </h2> <p style="text-align:center;"><a class="waves-effect waves-light btn green darken-2" target="_blank" href="https://medium.com/@jameshamann/"><i class="material-icons right">library_books</i>Read more at Medium</a></p> <div class="fixed-action-btn horizontal"> <a class="btn-floating btn-large waves-effect waves-default pulse" href="/"> <i class="material-icons">arrow_back</i> </a> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify — Part Two</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*e-avRWEkg9mFn5BuWm4X4w.jpeg"></figure></p> <p>Following on from my previous post, <a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a">Serverless React Web App with AWS Amplify — Part One</a>, today we’ll layout the Front End and implement our basic CRUD Functions.</p> <p><strong>All source code for the project can be found </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p> <h4>Front End</h4> <p>To bootstrap the front end, we’ll use <a href="https://react.semantic-ui.com/introduction">React Semantic UI</a>, a simple UI Framework that provides a great set of React Components.</p> <pre><strong>#bash</strong></pre> <pre>$ yarn add semantic-ui-react<br>[...]<br>$ yarn add semantic-ui-css</pre> <p>To get the CSS styling, you’ll need to import it in your <strong>index.js </strong>file, like so.</p> <pre><strong># index.js</strong></pre> <pre>import React from 'react';<br>import ReactDOM from 'react-dom';<br>import './index.css';<br>import App from './App';<br><strong>import 'semantic-ui-css/semantic.css'<br></strong>import registerServiceWorker from './registerServiceWorker';</pre> <pre>ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));<br>registerServiceWorker();</pre> <p>Now let’s setup the folder structure. I like to keep screens in one folder and re-useable components in another. With that it mind, let’s make two new directories within the <strong>src </strong>directory.</p> <pre>#<strong>bash</strong></pre> <pre>$ mkdir src/components<br>$ mkdir src/screens</pre> <pre># <strong>Project Layout</strong></pre> <pre>├── README.md<br>├── awsmobilejs<br>│   ├── #current-backend-info<br>│   │   ├── aws-exports.js<br>│   │   ├── backend-details.json<br>│   │   ├── cloud-api<br>│   │   │   └── sampleLambda<br>│   │   │       ├── app.js<br>│   │   │       ├── lambda.js<br>│   │   │       ├── package-lock.json<br>│   │   │       └── package.json<br>│   │   └── mobile-hub-project.yml<br>│   └── backend<br>│       ├── cloud-api<br>│       │   └── sampleLambda<br>│       │       ├── app.js<br>│       │       ├── lambda.js<br>│       │       ├── package-lock.json<br>│       │       └── package.json<br>│       └── mobile-hub-project.yml<br>├── package.json<br>├── public<br>│   ├── favicon.ico<br>│   ├── index.html<br>│   └── manifest.json<br>├── src<br>│   ├── App.css<br>│   ├── App.js<br>│   ├── App.test.js<br>│   ├── aws-exports.js<br>│   ├── components<br>│   ├── index.css<br>│   ├── index.js<br>│   ├── logo.svg<br>│   ├── registerServiceWorker.js<br>│   └── screens<br>└── yarn.lock</pre> <p>We’ll obviously need a few different views here, one to display all our items, one to create our items, one to edit/delete our items and one which shows a little more information about the item. We’ll use our <strong>App.js </strong>as the dashboard/index view for our app and add a navbar to navigate around the app.</p> <pre><strong># App.js</strong></pre> <pre>[...]</pre> <pre>render() {<br>    return (<br>      &lt;Segment&gt;<br>        &lt;Menu&gt;<br>           &lt;Menu.Item name='home'&gt; &lt;Icon name="shop"/&gt;&lt;/Menu.Item&gt;<br>           &lt;Menu.Item name='Items'/&gt;<br>           &lt;Menu.Item name='aboutUs' /&gt;<br>         &lt;/Menu&gt;<br>      &lt;/Segment&gt;<br>    );<br>  }<br>}</pre> <p>Now, let’s create an <strong>ItemDashboard</strong> page that shows all of our Item’s.</p> <pre><strong>#bash</strong></pre> <pre>touch src/screens/itemDashboard.js</pre> <pre>--------------------------------------------------------------------</pre> <pre>#<strong>itemDashboard.js</strong></pre> <pre>import React, { Component } from 'react';<br>import {Container, Card} from 'semantic-ui-react'</pre> <pre>class ItemDashboard extends Component {</pre> <pre>render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;Container style={{padding: 10}}&gt;<br>          &lt;Card.Group&gt;<br>              &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    Item Name<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Item Price<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                  Description of the Item<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</pre> <pre>export default ItemDashboard;</pre> <p>Now we’ll import this into our <strong>App.js </strong>and render it within our <strong>&lt;Segment&gt;</strong> section.</p> <pre># <strong>App.js</strong></pre> <pre>[...]<br>  <br>render() {<br>    return (<br>      &lt;Segment&gt;<br>        &lt;Menu&gt;<br>           &lt;Menu.Item name='home'&gt; &lt;Icon name="shop"/&gt;&lt;/Menu.Item&gt;<br>           &lt;Menu.Item name='Items'/&gt;<br>           &lt;Menu.Item name='aboutUs' /&gt;<br>         &lt;/Menu&gt;<br><strong>         &lt;ItemDashboard /&gt;<br></strong>      &lt;/Segment&gt;<br>    );<br>  }<br>}</pre> <p>At the moment our app should look nice and basic, something like this.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BxDPNJ33L4G073eyYITptg.png"><figcaption>Basic Item Dashboard</figcaption></figure><p>Next, let’s implement a modal, which will serve as our create page.</p> <p>We’ll use Semantic UI’s Modal and Form components to create the basic outline of our page. Let’s create a new file <strong>createItem.js </strong>which will live in our <strong>screens </strong>directory.</p> <pre>#bash</pre> <pre>$ touch src/screens/createItem.js</pre> <pre>--------------------------------------------------------------------</pre> <pre>#<strong>createItem.js</strong></pre> <pre>import React, { Component } from 'react';<br>import { Form, Modal, Button, Container } from 'semantic-ui-react'</pre> <pre>class CreateItemModal extends Component {</pre> <pre>constructor(props) {<br>    super(props)<br>    this.state = {}<br>    this.handleChange = this.handleChange.bind(this);<br>  }</pre> <pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre> <pre>handleSubmit(event) {</pre> <pre>}</pre> <pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre> <pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre> <pre>render () {<br>    return (<br>        &lt;Modal trigger={&lt;Button onClick={this.handleOpen}&gt;+ Add Item&lt;/Button&gt;} closeIcon={true} open={this.state.modalOpen} onClose={this.handleClose}&gt;<br>          &lt;Modal.Header&gt;Add an Item&lt;/Modal.Header&gt;<br>          &lt;Modal.Content&gt;<br>            &lt;Form&gt;<br>              &lt;Form.Group unstackable widths={2}&gt;<br>                &lt;Form.Input name='itemName' label='Item Name' placeholder='Enter Item Name...' onChange={this.handleChange} /&gt;<br>                &lt;Form.Input name='itemPrice' label='Item Price' placeholder='Enter Item Price...' onChange={this.handleChange} type='number' /&gt;<br>              &lt;/Form.Group&gt;<br>              &lt;Form.TextArea name='item_description' label='Item Description' placeholder='Add a Description of the Item...' onChange={this.handleChange} /&gt;</pre> <pre>&lt;Form.Button type='submit'&gt;Submit&lt;/Form.Button&gt;<br>            &lt;/Form&gt;<br>          &lt;/Modal.Content&gt;<br>        &lt;/Modal&gt;<br>      );<br>    }<br>  }</pre> <pre>export default CreateItemModal;</pre> <p>Most of the above code is recycled from examples on Semantic’s website. Studying the code, you’ll notice I’ve also added two functions that <strong>handleChange </strong>and <strong>handleSubmit </strong>within our form. This ensures all data is captured and submitted correctly, we’ll revisit both of these later when we connect everything together.</p> <p>One thing I should mention, that I encountered during my own development, is a funky bug with the modal where half of it would be cut, off screen. The issue is tracked <a href="https://github.com/Semantic-Org/Semantic-UI-React/issues/2558">here</a> and the solution below worked perfectly, for me. Please do let me know if you run into any funky issues around the modal that aren’t resolved with the below.</p> <p><strong>Proposed Workaround for Modal Issue:</strong></p> <pre>#<strong>App.css</strong></pre> <pre>.ui.page.modals.transition.visible {<br>    display: flex !important;<br>}</pre> <pre># suggested by loopmode on GitHub Issues thread.</pre> <p>Make sure to import and add the component in our <strong>ItemDashboard</strong>.</p> <pre>#<strong>src/screens/itemDashboard.js</strong></pre> <pre>[...]</pre> <pre>render() {<br>    return (<br>      &lt;div&gt;<br>       &lt;CreateItemModal/&gt;        <br>        &lt;Container style={{padding: 10}}&gt;<br>          &lt;Card.Group&gt;<br>              &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    Item Name<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Item Price<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                  Description of the Item<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );</pre> <pre>[...]</pre> <p>The finished <strong>createItemModal</strong> should look something like the below.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3bkmnkqVbDb7PsbZ3gkqSg.png"></figure><p>Looking good! Now let’s hook everything up so that we can actually create items that display on our Dashboard.</p> <h4>Create</h4> <p>Now that we have a form we’ll need to populate the function <strong>handleSubmit </strong>we wrote in earlier.</p> <p>Similar to our get request previously, we’ll have to set the <strong>apiName</strong>, <strong>path,</strong> and this time, the body of what we’re sending. We’ll then use Amplify’s <strong>API </strong>component to post and log the contents to the console.</p> <pre><strong>#createItem.js</strong></pre> <pre><strong>import Amplify, { API } from 'aws-amplify';</strong></pre> <pre>class CreateItemModal extends Component {</pre> <pre>constructor(props) {<br>    super(props)<br>    this.state = {}<br>    this.handleChange = this.handleChange.bind(this);<br><strong>    this.handleSubmit = this.handleSubmit.bind(this);</strong></pre> <pre>}</pre> <pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre> <pre><strong>handleSubmit(event) {<br>    let apiName = 'sampleCloudApi';<br>    let path = '/items';<br>    let newItem = {<br>      body: {<br>          name: this.state.itemName, price: this.state.itemPrice, description: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>    this.handleClose()<br>  }</strong></pre> <pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre> <pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre> <pre>render () {<br>    return (<br>        &lt;Modal trigger={&lt;Button onClick={this.handleOpen}&gt;+ Add Item&lt;/Button&gt;} closeIcon={true} open={this.state.modalOpen} onClose={this.handleClose}&gt;<br>          &lt;Modal.Header&gt;Add an Item&lt;/Modal.Header&gt;<br>          &lt;Modal.Content&gt;<br>            &lt;Form <strong>onSubmit={this.handleSubmit}</strong>&gt;<br>              &lt;Form.Group unstackable widths={2}&gt;<br>                &lt;Form.Input name='itemName' label='Item Name' placeholder='Enter Item Name...' onChange={this.handleChange}  <strong>value={this.state.itemName} </strong>/&gt;<br>                &lt;Form.Input name='itemPrice' label='Item Price' placeholder='£0.00' onChange={this.handleChange}  <strong>value={this.state.itemPrice} </strong>/&gt;<br>              &lt;/Form.Group&gt;<br>             &lt;Form.TextArea name='itemDescription' label='Item    Description' placeholder='Add a Description of the Item...' onChange={this.handleChange}  <strong>value={this.state.itemDescription}</strong> /&gt;</pre> <pre>&lt;Form.Button type='submit'&gt;Submit&lt;/Form.Button&gt;<br>            &lt;/Form&gt;<br>          &lt;/Modal.Content&gt;<br>        &lt;/Modal&gt;<br>      );<br>    }<br>  }</pre> <pre>export default CreateItemModal;</pre> <p>The <strong>handleSubmit </strong>function declares the variables necessary for posting to our backend. The body is formed of the values we set in each form element: <strong>itemName, itemPrice </strong>and <strong>itemDescription. </strong>The last thing we need to do is bind our function to our component so that it doesn’t show up undefined when we call our function.</p> <p>Now let’s give the form a quick test to see if everything’s working.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/844/1*NEmUzgh6sEsxzqJoIeu_1A.png"></figure><p>After submitting the form, with some content obviously, you should see the contents in the console, like above.</p> <p>Great! However, this isn’t saving anywhere, we still need to configure our Database.</p> <h4>DynamoDB Setup</h4> <p>Earlier on we setup a Database with the default example setup, we’re going to remove this and configure the database from scratch. DynamoDB requires us to specify a Primary Key, which determines how items within our Table are uniquely organised. There’s a lot of different schools of thought on what’s best to do here, which are way out of scope of this post. To keep things simple I’ll create a <strong>UUID, </strong>which will be generated when a user submits a new Item using the form.</p> <pre><strong>#bash</strong></pre> <pre>$ awsmobile database configure</pre> <pre>? Select from one of the choices below. Remove table from the project<br>? Select table to be deleted AWSMobileTable<br>? Are you sure you want to delete the table Yes</pre> <pre>$ awsmobile database configure</pre> <pre>Welcome to NoSQL database wizard<br>You will be asked a series of questions to help determine how to best construct your NoSQL database table.</pre> <pre>? Should the data of this table be open or restricted by user? Open<br>? Table name ServerlessReactExample</pre> <pre>You can now add columns to the table.</pre> <pre>? What would you like to name this column ID<br>? Choose the data type string<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemName<br>? Choose the data type string<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemPrice<br>? Choose the data type number<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemDescription<br>? Choose the data type string<br>? Would you like to add another column No</pre> <pre>Before you create the database, you must specify how items in your table are uniquely organized. This is done by specifying a Primary key. The primary key uniquely identifies each item in the table, so that no two items can have the same key.<br>This could be and individual column or a combination that has "primary key" and a "sort key".<br>To learn more about primary key:<br><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey</a></pre> <pre>? Select primary key ID<br>? Select sort key (No Sort Key)</pre> <pre>You can optionally add global secondary indexes for this table. These are useful when running queries defined by a different column than the primary key.<br>To learn more about indexes:<br><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes</a></pre> <pre>? Add index No</pre> <pre>$ awsmobile push<br>[...]<br>contents in #current-backend-info/ is synchronized with the latest in the aws cloud</pre> <p>Again, to keep things simple I’ve not added a sort key or an index, just the Primary key which is require for setting up the db.</p> <p>Let’s quickly tweak our <strong>handleSubmit </strong>function to generate a uuid whenever we submit. In order to achieve this we’ll use <a href="https://github.com/kelektiv/node-uuid"><strong>node-uuid</strong></a><strong>. </strong>There’s a few different versions you can generate, but we’ll use the <strong>uuidv1, </strong>which creates a timestamp uuid. This can be converted and tested on a site like <a href="https://www.famkruithof.net/uuid/uuidgen">this</a>.</p> <pre>#bash </pre> <pre>$ yarn add node-uuid</pre> <pre>------------------------------------------------------------------</pre> <pre><strong>#createItem.js</strong></pre> <pre><strong>const uuidv1 = require('uuid/v1');</strong></pre> <pre>[...]<br>handleSubmit(event) {<br>    console.log(this);<br>    let apiName = 'sampleCloudApi';<br>    let path = '/items';<br>    let newItem = {<br>      body: {<br>          <strong>ID: uuidv1()</strong>, name: this.state.itemName, price: this.state.itemPrice, description: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>    this.handleClose()<br>  }<br>[...]</pre> <p>Lastly, we need to configure our <strong>cloud-api </strong>to use our newly created database.</p> <pre>#bash</pre> <pre>awsmobile cloud-api configure</pre> <pre>This feature will create an API using Amazon API Gateway and AWS Lambda. You can optionally have the lambda function perform CRUD operations against your Amazon DynamoDB table.</pre> <pre>? Select from one of the choices below. Create CRUD API for an existing Amazon DynamoDB table<br>? Select Amazon DynamoDB table to connect to a CRUD API ServerlessReactExample<br>Adding lambda function code on:<br>/Users/jameshamann/Documents/Development/serverless-web-app-example/awsmobilejs/backend/cloud-api/rverlessReactExample/<br>...<br>Path to be used on API for get and remove an object should be like:<br>/ServerlessReactExample/object/:ID</pre> <pre>Path to be used on API for list objects on get method should be like:<br>/ServerlessReactExample/:ID</pre> <pre>JSON to be used as data on put request should be like:<br>{<br>  "ID": "INSERT VALUE HERE",<br>  "ItemDescription": "INSERT VALUE HERE",<br>  "ItemName": "INSERT VALUE HERE",<br>  "ItemPrice": "INSERT VALUE HERE"<br>}<br>To test the api from the command line (after awsmobile push) use this commands<br>awsmobile cloud-api invoke ServerlessReactExampleCRUD &lt;method&gt; &lt;path&gt; [init]</pre> <pre>$ awsmobile push</pre> <p>This does change the name of your <strong>API, </strong>you’ll notice mine is now called <strong>ServerlessReactExampleCRUD,</strong> with a <strong>path </strong>of <strong>/ServerlessReactExample. </strong>So in order to get things to work,<strong> </strong>you’ll need to update the <strong>apiName and path </strong>in your code to reflect this.</p> <p>Now let’s create a new item in our form and hit Submit. We still don’t see anything, but if we head over to the <a href="https://aws.amazon.com/dynamodb">AWS DynamoDB Console</a>, we’ll see our item has been successfully saved in our database!</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xZ2kgys68NggdswMMe_yQA.png"></figure><h4>Read</h4> <p>Now that we can successfully Create items, let’s work on Reading them in our dashboard. Instead of reading one Item at a time, I’m going to fetch all Items in our database and display them on our itemDashboard. To do this, we’ll need to slightly alter our Lambda code to include a function that returns all items from our DynamoDB Table.</p> <p>DynamoDB provides us with a <strong>.scan </strong>method, which returns all items, similar to a <em>SELECT * from tablename</em> in SQL. Let’s start off by editing our <strong>app.js </strong>within our <strong>backend </strong>folder and include a route that retrieves all data.</p> <pre>#<strong>awsmobilejs/backend/yourLambdaFunctionName/app.js</strong></pre> <pre>[...]</pre> <pre>app.get('/ServerlessReactExample', function(req, res) {</pre> <pre>var params = {<br>    TableName: tableName,<br>    Select: 'ALL_ATTRIBUTES',<br>};</pre> <pre>dynamodb.scan(params, (err, data) =&gt; {<br>       if (err) {<br>         res.json({error: 'Could not load items: ' + err.message});<br>       }</pre> <pre>res.json({<br>           data: data.Items.map(item =&gt; {<br>             return item;<br>           })<br>       });<br>   });<br>});</pre> <pre>[...]</pre> <pre>-------------------------------------------------------------------</pre> <pre>#bash</pre> <pre>$ awsmobile push<br>[...]</pre> <p>Be sure to add the function just above the other routes and to push your changes to the aws cloud.</p> <p>Once everything has been pushed and updated, reload your app and, if everything’s setup correctly, you should see all items from the database.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/848/1*mOAAlE3_bDNddPPw-4C01g.png"><figcaption>After refreshing</figcaption></figure><p>Let’s update our itemDashboard so that it correctly displays the data fetched from the database. We’ll iterate through our JSON response and for each item, we’ll display the <strong>name, price </strong>and <strong>description </strong>on a <strong>Card. </strong>We’ll require another library, <strong>lodash</strong>, which basically makes working with objects a lot easier.</p> <pre>#bash </pre> <pre>$ yarn add loadash</pre> <pre>-------------------------------------------------------------------</pre> <pre>#<strong>src/screens/itemDashboard.js</strong></pre> <pre>import React, { Component } from 'react';<br>import {Container, Card} from 'semantic-ui-react'<br><strong>import Amplify, { API } from 'aws-amplify';<br>import _ from 'lodash';</strong></pre> <pre>let apiName = 'ServerlessReactExampleCRUD';<br>let path = '/ServerlessReactExample';</pre> <pre>class ItemDashboard extends Component {</pre> <pre><strong>constructor(props){<br>    super(props)<br>    this.state = {itemData: {}}<br>  }</strong></pre> <pre><strong>getItems(){<br>    API.get(apiName, path).then(response =&gt; {<br>      console.log(response)<br>      this.setState({<br>       itemData: response.data<br>      });<br>    });<br>  }</strong></pre> <pre>componentDidMount(){<br>    <strong>this.getItems()<br></strong>  }</pre> <pre>render() {<br><strong>    const itemData = this.state.itemData;<br></strong>    <strong>return (<br>      &lt;div&gt;</strong></pre> <pre>&lt;CreateItemModal/&gt;<strong>        <br>&lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  £ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</strong></pre> <pre>export default ItemDashboard;</pre> <p>We move our GET request into it’s own function, <strong>getItems() </strong>and call it during the <strong>componentDidMount </strong>function. Then, in our <strong>render </strong>function, we set <strong>itemData </strong>equal to <strong>this.state.itemData, </strong>which is set during our <strong>getItems() function. </strong>In the UI, we _<strong>.map </strong>over our <strong>itemData </strong>and for each Item we return a Card with the <strong>ItemName</strong>, <strong>ItemPrice </strong>and <strong>ItemDescription</strong>. After reloading your app, the result should look something like the below.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dSNJl7GoDS8FYqbMxKn5WQ.png"></figure><p>Before moving on, you’ll notice in order to see your results after a form submission you’ll need to refresh. Let’s fix that with a callback and set the state of <strong>this.state.itemData </strong>to get updated when we submit our form.</p> <pre>#<strong>src/screens/itemDashboard.js</strong></pre> <pre>[...]</pre> <pre>render() {<br>    const itemData = this.state.itemData;<br>    return (<br>      &lt;div&gt;</pre> <pre><strong>&lt;CreateItemModal getItems={this.getItems}/&gt;<br></strong>&lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  £ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</pre> <pre>[...]</pre> <pre>-------------------------------------------------------------------<br>#<strong>src/screens/createItem.js</strong></pre> <pre>[...]</pre> <pre>handleSubmit(event) {<br>    console.log(this);<br>    let apiName = 'ServerlessReactExampleCRUD';<br>    let path = '/ServerlessReactExample';<br>    let newItem = {<br>      body: {<br>          "ID": uuidv1(),<br>          "ItemName": this.state.itemName,<br>          "ItemPrice": this.state.itemPrice,<br>          "ItemDescription": this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>   <strong> this.props.getItems()</strong><br>    this.handleClose()<br>  }</pre> <pre>[...]</pre> <p>We pass the function down from <strong>ItemDashboard </strong>to <strong>createItem</strong>.</p> <h4>Update</h4> <p>Next, we’ll look at Updating our Items, if we want to change the price, for example.</p> <p>Let’s create another modal, exactly the same as our <strong>createItem.js, </strong>but let’s call it <strong>editItem.js. </strong>Alot of the contents will be similar as it’s essentially the same form, just for editing an item.</p> <pre><strong>#src/screens/editItem.js</strong></pre> <pre>import React, { Component } from 'react';<br>import { Form, Modal, Button, Container, Icon } from 'semantic-ui-react'<br>import Amplify, { API } from 'aws-amplify';<br>const uuidv1 = require('uuid/v1');</pre> <pre>class EditItemModal extends Component {</pre> <pre>constructor(props) {<br>    super(props)<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br><strong>    this.state = { item: this.props.item };<br></strong>  }</pre> <pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre> <pre>handleSubmit(event) {<br>    let apiName = 'ServerlessReactExampleCRUD';<br>    let path = '/ServerlessReactExample';<br><strong>    let editItem = {<br></strong>      body: {<br><strong>          "ID": this.props.item[0].ID,<br></strong>          "ItemName": this.state.itemName,<br>          "ItemPrice": this.state.itemPrice,<br>          "ItemDescription": this.state.itemDescription<br>        }<br>      }<br>    API.put(apiName, path, editItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });</pre> <pre>    this.props.getItems()<br>    this.handleClose()<br>    event.preventDefault();<br>  }</pre> <pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre> <pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre> <pre>render () {<br>      <strong>return (<br>        &lt;Container style={{padding: 10}}&gt;<br>            &lt;Modal trigger={&lt;Button icon onClick={this.handleOpen}&gt;&lt;Icon name='edit' /&gt;&lt;/Button&gt;}open={this.state.modalOpen}  closeIcon </strong> <strong>onClose={this.handleClose}&gt;<br>              &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;<br>              &lt;Modal.Content&gt;<br>                &lt;Form onSubmit={this.handleSubmit}&gt;<br>                &lt;Form.Group unstackable widths={2}&gt;<br>                  &lt;Form.Input name='itemName' label='Item Name' placeholder='Edit Item Name...' onChange={this.handleChange}  value={this.state.itemName} /&gt;<br>                  &lt;Form.Input name='itemPrice' label='Item Price' placeholder='£0.00' onChange={this.handleChange}  value={this.state.itemPrice} /&gt;<br>                &lt;/Form.Group&gt;<br>                &lt;Form.TextArea name='itemDescription' label='Item Description' placeholder='Edit Description of the Item...' onChange={this.handleChange}  value={this.state.itemDescription} /&gt;<br>                  &lt;Form.Button type='submit'&gt;Submit&lt;/Form.Button&gt;<br>                &lt;/Form&gt;<br>            &lt;/Modal.Content&gt;<br>          &lt;/Modal&gt;<br>       &lt;/Container&gt;</strong><br>      );<br>    }<br>  }</pre> <pre>export default EditItemModal;</pre> <p>Essentially this is the same code as what’s in <strong>createItem.js, </strong>the only difference is we’re receiving props we’ve sent from our parent component <strong>itemDashboard.js, </strong>in order to retrieve the item’s ID. This is important, as we require the ID in order to make sure we’re updating the correct item in our database.</p> <p>To send the Item to our <strong>EditItemModal </strong>, we need to create a function that fetches the item. We’ll do this in our <strong>ItemDashboard</strong> and send the response to our <strong>EditItemModal </strong>through props.</p> <pre><strong>#src/screens/ItemDashboard.js<br>[...]</strong></pre> <pre><strong>import EditItemModal from './editItem.js'</strong></pre> <pre>[...]</pre> <pre><strong>getItem(id){<br>  let single_path = '/ServerlessReactExample/' + id<br>  console.log(single_path)<br>  API.get(apiName, single_path).then(response =&gt; {<br>    console.log(response)<br>    this.setState({<br>      item: response<br>    })<br>  });<br>}</strong></pre> <pre>[...]</pre> <pre>return (<br>      &lt;div&gt;<br>        &lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            <strong>&lt;Card onClick={() =&gt; this.getItem(ID)}&gt;</strong><br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  £ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br><strong>              &lt;EditItemModal item={Object.values(this.state.item) getItems={(this.getItems)} /&gt;<br></strong>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );</pre> <p>Don’t forget to import the <strong>EditItemModal, </strong>as we’ll be rendering this within our dashboard on each card. Our function, <strong>getItem, </strong>takes an ID as it’s argument, the ID is then appended to the path used within our GET request, which returns all information on the requested Item. We then set the state of <strong>item </strong>equal to the response of our call and send that data through to our <strong>EditItemModal.</strong></p> <p>Once Complete, you should have a dashboard similar to this, with the ability to edit the item you’ve clicked on.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DRRHjfv4wJGjOo7bnTDN1w.png"></figure><p>Awesome! Lastly, let’s quickly implement our last CRUD function, delete.</p> <h4>Delete</h4> <p>Implementing a delete function is fairly quick, as most of the work is already done. We’ll add the delete function to our <strong>EditItemModal</strong>, as it’s probably the best place for it.</p> <pre>#<strong>src/screens/editItem.js</strong></pre> <pre>[...]</pre> <pre>constructor(props) {<br>    super(props)<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br><strong>    this.deleteItem = this.deleteItem.bind(this);</strong></pre> <pre>this.state = { item: this.props.item };<br>  }</pre> <pre><strong>deleteItem(){<br>    let apiName = 'ServerlessReactExampleCRUD';<br>    let path = "/ServerlessReactExample/object/" + this.props.item[0].ID<br>    API.del(apiName, path).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    this.props.getItems()</strong></pre> <pre><strong>    this.handleClose()<br>  }</strong></pre> <pre><strong>[...]</strong></pre> <p>Very simply, our function makes a delete request, using <strong>API </strong>component, with the ID appended to the path. The ID is required so the function know’s which Item to delete from our database. Don’t forget to bind our function to <strong>this</strong>, otherwise we’ll get undefined errors when trying to retrieve our <strong>ID.</strong></p> <p>Lastly, let’s render a Delete button on our Modal and link it all together.</p> <pre>#<strong>src/screens/editItem.js</strong></pre> <pre>return (<br>        &lt;Container style={{padding: 10}}&gt;<br>            &lt;Modal trigger={&lt;Button icon onClick={this.handleOpen}&gt;&lt;Icon name='edit' /&gt;&lt;/Button&gt;} open={this.state.modalOpen} closeIcon onClose={this.handleClose}&gt;<br>              &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;<br>              &lt;Modal.Content&gt;<br>                &lt;Form onSubmit={this.handleSubmit}&gt;<br>                &lt;Form.Group unstackable widths={2}&gt;<br>                  &lt;Form.Input name='itemName' label='Item Name' placeholder='Edit Item Name...' onChange={this.handleChange}  value={this.state.itemName} /&gt;<br>                  &lt;Form.Input name='itemPrice' label='Item Price' placeholder='£0.00' onChange={this.handleChange}  value={this.state.itemPrice} /&gt;<br>                &lt;/Form.Group&gt;<br>                &lt;Form.TextArea name='itemDescription' label='Item Description' placeholder='Edit Description of the Item...' onChange={this.handleChange}  value={this.state.itemDescription} /&gt;<br>                  &lt;Form.Button type='submit'&gt;Submit&lt;/Form.Button&gt;<br>                &lt;/Form&gt;<br>            &lt;/Modal.Content&gt;<br>           <strong> &lt;Modal.Actions&gt;<br>              &lt;Button icon labelPosition='left' onClick={this.deleteItem}&gt;<br>              &lt;Icon name='delete' /&gt;<br>                Delete Item<br>              &lt;/Button&gt;<br>            &lt;/Modal.Actions&gt;</strong><br>          &lt;/Modal&gt;<br>       &lt;/Container&gt;</pre> <p>Once completed, your <strong>EditItemModal</strong> should look like this. When clicking delete, and after a refresh, you’ll notice the item has been removed.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-G3bneervjaVbEsLngqtRA.png"></figure><p>This has been quite a long post, so well done if you’ve made it this far! You now have a, real basic, Serverless React Web App! There are still a lot of things that need to be cleaned up and refactored, like perhaps adding the Item Title to the <strong>EditItemModal</strong>, so we know what we’re editing and adding maybe adding some validation to our forms? There’s a lot of scope for improvement and enhancement here, but this gives you a solid foundation to move forward.</p> <p>The next, and final, part on this mini series will be focused around Adding Authentication, with Amplify, as well as the Deployment and Distribution of your app through AWS.</p> <p><strong>All source code for the project can be found </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p> <p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"></figure><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d740ee8e7456" width="1" height="1"> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify — Part One</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_0jTP7l27uwj2CPLpqnVdw.jpeg"></figure></p> <p>Having previously posted about <a href="https://medium.com/@jameshamann/accelerating-mobile-app-development-with-aws-amplify-fb2034e60160">Accelerating Mobile Development with AWS Amplify</a>, I thought I’d do the same for the Web, using <a href="https://github.com/aws/aws-amplify">AWS Amplify</a>, Amazon’s new JavaScript Library for app development.</p> <p><strong>All source code for the project can be found </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p> <p>Before diving in, it’s probably worth understanding, at least at a high level, the architecture behind serverless apps and how they work.</p> <h4>What is a Serverless Application?</h4> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eIECK-X8x_9wfu9uShspHw.png"><figcaption>High Level Serverless Application Model</figcaption></figure><p>This diagram represents, at a high level, the architecture of a serverless application. Our static content (React Web App) is stored in an S3 bucket served up to the client, either from CloudFront or directly. This communicates with API Gateway. From here this triggers a Lambda function (which handles all our back end logic) and communicates with DynamoDB to get, save, delete or whatever depending on what request was sent from the client.</p> <h4>What are the benefits?</h4> <p>Cost. You only pay for the compute time you use. This works great if you have large fluctuations in traffic/requests. It also takes the hassle of maintaining a server away and some what simplifies things so you can focus on building your product. Obviously, every app has it’s own requirements and serverless architecture may not fit in all cases, but for the most part it provides a good framework to deploy applications at low cost, with minimal configuration.</p> <h4>What we’ll be building</h4> <p>To keep things nice and simple, and to avoid the stale recycled todo example, we’ll build an online inventory with basic CRUD functions. I’m sure it goes without saying but you’d need an AWS Account, which you can get get <a href="https://aws.amazon.com/">here</a>. I’d also advise you to keep an eye on your billing statement so you don’t incur any unexpected charges.</p> <h4>Getting Started</h4> <p>Firstly, we’ll need to install the <strong>awsmobile-cli </strong>and configure it with our AWS Keys.</p> <pre><strong>#bash</strong></pre> <pre>$ npm install -g awsmobile-cli<br>[...]<br><br>$ awsmobile configure<br>$ configure aws<br>? accessKeyId:  [ENTER YOUR ACCESS KEY ID] #hit enter<br>? secretAccessKey: [ENTER YOUR SECRET ACCESS KEY] #hit enter<br>? region:  eu-west-2 #select your region using arrows and hit enter</pre> <p>Next, we’ll use <a href="https://github.com/facebook/create-react-app">create-react-app</a> to scaffold up a React App for us.</p> <pre><strong>#bash </strong></pre> <pre>$ create-react-app serverless-web-app-example<br>[...]<br>✨  Done in 17.74s.</pre> <pre>Success! Created serverless-web-app-example at /Users/jameshamann/Documents/Development/serverless-web-app-example<br>Inside that directory, you can run several commands:</pre> <pre>yarn start<br>    Starts the development server.</pre> <pre>yarn build<br>    Bundles the app into static files for production.</pre> <pre>yarn test<br>    Starts the test runner.</pre> <pre>yarn eject<br>    Removes this tool and copies build dependencies, configuration files<br>    and scripts into the app directory. If you do this, you can’t go back!</pre> <pre>We suggest that you begin by typing:</pre> <pre>cd serverless-web-app-example<br>  yarn start</pre> <pre>Happy hacking!<br>$ cd serverless-web-app-example</pre> <p>Let’s fire up our app to make sure it’s all setup correctly.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kBjOFtIFilxIiY6WQMR0sA.png"><figcaption>React Starter Page</figcaption></figure><p>Great, looks good! Now lets install <strong>aws-amplify </strong>and <strong>aws-amplify-react</strong> (which just contains helpers and higher order components for react) within our project.</p> <pre><strong>#bash</strong> </pre> <pre>$ npm install aws-amplify --save <br>[...]<br>$ npm install aws-amplify-react --save<br>[...]</pre> <p>Once this is all installed, we’ll need to setup our backend. To initialise a project, we use the <strong>awsmobile init </strong>command within the root of our project. You’ll be prompted a few questions, usually the default answers provided are correct so you should be able to hit enter for each of them.</p> <pre><strong>#bash </strong></pre> <pre>$ awsmobile init<br>[...]</pre> <pre>✨  Done in 5.30s.<br>yarn add aws-amplify-react returned 0</pre> <pre>Success! your project is now initialized with awsmobilejs</pre> <pre>awsmobilejs/.awsmobile<br>     is the workspace of awsmobile-cli, please do not modify its contents</pre> <pre>awsmobilejs/#current-backend-info<br>     contains information of the backend awsmobile project from the last<br>     synchronization with the cloud</pre> <pre>awsmobilejs/backend<br>     is where you develop the codebase of the backend awsmobile project</pre> <pre>awsmobile console<br>     opens the web console of the backend awsmobile project</pre> <pre>awsmobile run<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and runs the frontend application locally</pre> <pre>awsmobile publish<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and publishes the frontend application to aws S3 for hosting</pre> <pre>Happy coding with awsmobile!</pre> <p>This command creates all the necessary resources in AWS for your backend, as well as creating a <strong>awsmobilejs </strong>folder within the root of your project, which contains basic information about your project.</p> <p>Lastly, we’ll need to hook up our client (React app) to our newly created backend. In your app’s entry point (usually App.js) include the bolded code in the snippet. This just imports the Amplify Library and configures it using a file called <strong>aws_exports </strong>which is generated when you initialise your backend, in the previous step.</p> <pre><strong># App.js </strong></pre> <pre>import React, { Component } from 'react';<br>import logo from './logo.svg';<br>import './App.css';<br><strong>import Amplify from 'aws-amplify';<br>import aws_exports from './aws-exports';</strong></pre> <pre><strong>Amplify.configure(aws_exports);</strong></pre> <pre>class App extends Component {<br>  render() {<br>    return (<br>      &lt;div className="App"&gt;<br>        &lt;header className="App-header"&gt;<br>          &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br>          &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;<br>        &lt;/header&gt;<br>        &lt;p className="App-intro"&gt;<br>          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br>        &lt;/p&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre> <pre>export default App;</pre> <h4>Lambda and API Setup</h4> <p>Now we’ve got the basic infrastructure setup, let’s setup Lambda, API Gateway and DynamoDB for our basic CRUD functions. To do this, run the <strong>awsmobile features </strong>command. From here, you can see what features you’re able to activate and what features are available as default. For now we only require <strong>cloud-api </strong>and <strong>database </strong>to be selected and activated.</p> <pre><strong>#bash </strong></pre> <pre>awsmobile features</pre> <pre>? select features:<br> ◯ user-signin<br> ◯ user-files<br> ◉ cloud-api<br>❯◉ database<br> ◉ analytics<br> ◉ hosting</pre> <pre># hit space to select the features you'd like and enter to confirm</pre> <p>Whenever you change something locally, as we’ve just done, we’ll need to push it to AWS so the changes can take effect.</p> <pre><strong>#bash</strong></pre> <pre>$ awsmobile push</pre> <p>Once everything’s been initialised and pushed, have a poke around the <strong>backend</strong> directory, within <strong>awsmobilejs.</strong> There should be a <strong>cloud-api </strong>directory that contains your Lambda Project and a bunch of boilerplate code to get you started. By default, Lambda is setup to use AWS’s Serverless Express Framework for Node.js, so if you’re experienced with Node.js and Express, everything should look pretty familiar.</p> <p>At this point, I like to do a quick check to make sure the Client and Backend are setup and talking to each other. To do this, I write a get request within the <strong>componentDidMount </strong>function, so as soon as our Component mounts, it fetches data from our backend and logs it to the console. AWS Amplify provides a component, API, to handle all requests to our backend.</p> <pre><strong># App.js</strong></pre> <pre>import React, { Component } from 'react';<br>import logo from './logo.svg';<br>import './App.css';<br><strong>import Amplify, { API } from 'aws-amplify';<br></strong>import aws_exports from './aws-exports';</pre> <pre>Amplify.configure(aws_exports);</pre> <pre><strong>let apiName = 'sampleCloudApi';<br>let path = '/items';</strong></pre> <pre>class App extends Component {</pre> <pre><strong>componentDidMount(){<br>    API.get(apiName, path).then(response =&gt; {<br>      console.log(response)<br>    });<br>  }</strong></pre> <pre>render() {<br>    return (<br>      &lt;div className="App"&gt;<br>        &lt;header className="App-header"&gt;<br>          &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br>          &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;<br>        &lt;/header&gt;<br>        &lt;p className="App-intro"&gt;<br>          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br>        &lt;/p&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre> <pre>export default App;</pre> <p>If you’ve poked around the Lambda app.js file, you’ll notice we should be expecting a response of <strong>({success: ‘get call succeed!’, url: req.url}).</strong></p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*T-GpqFtmKzSIPWZeuqQ0Zw.png"></figure><p>Ok, you might need to squint, but if you check the console you’ll see our request object <strong>{success: “get call succeeded!”, url: /items”}. </strong>Great! Everything’s hooked up and ready to go.</p> <p>In the next part we’ll look at setting our Front End Pages up and creating the basic CRUD Functions.</p> <p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p> <h4><a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-two-d740ee8e7456">Serverless React Web App with AWS Amplify — Part Two Available Here</a></h4> <figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"></figure><p><strong>This story is published in </strong><a href="http://blog.usejournal.com"><strong>Noteworthy</strong></a><strong>, where thousands come every day to learn about the people &amp; ideas shaping the products we love.</strong></p> <p><a href="http://blog.usejournal.com"><strong>Follow our publication</strong></a><strong> to see more product &amp; design stories featured by the </strong><a href="https://usejournal.com/?/utm_source=usejournal.com&amp;utm_medium=blog&amp;utm_campaign=guest_post&amp;utm_content=james_hamann"><strong>Journal</strong></a><strong> team.</strong></p> <img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=414e9402d92a" width="1" height="1"><hr> <p><a href="https://blog.usejournal.com/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a">Serverless React Web App with AWS Amplify — Part One</a> was originally published in <a href="https://blog.usejournal.com">Noteworthy — The Journal Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Accelerating Mobile App Development with AWS Amplify</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*6afwPNkz6LnroeA0lfyC2g.png"></figure></p> <p>Over the last couple of months AWS have released a new Library, <a href="https://github.com/aws/aws-amplify">AWS Amplify</a>, both for Web Development and React Native Mobile Development. The purpose is to provide <em>a declarative and easy-to-use interface across different categories of cloud operations. </em>If you’re already using AWS Services, it plugs directly in, but it also designed in such a way to plug in with any other backed/cloud service that you use.</p> <p>Having used it on a few projects myself, it made key areas of app development a breeze and accelerates the development of an app greatly. Services include Authentication through <a href="https://aws.amazon.com/cognito/">AWS Cognito,</a> No-SQL Database’s through <a href="https://aws.amazon.com/dynamodb/">DynamoDB</a> and hosting through <a href="https://aws.amazon.com/s3/">S3</a> and <a href="https://aws.amazon.com/cloudfront/">CloudFont</a>. It connects everything so easily and quickly that it gives you the time to focus on actually developing the app.</p> <p>I’ll briefly walkthrough the process of scaffolding a simple <strong>awsmobile</strong> project, to demonstrate how easy and quick it is to get going. I’ll assume you have the basics, like <a href="https://nodejs.org/en/">node</a>, <a href="https://facebook.github.io/react-native/docs/getting-started.html">react-native-cli</a> or <a href="https://facebook.github.io/react-native/docs/getting-started.html">create-react-native-cli</a> installed already.</p> <p>Obviously, first things first, make sure you’ve got <a href="https://aws.amazon.com/cli/">aws</a> and <a href="https://github.com/aws/awsmobile-cli">awsmobile</a> CLI (npm install awsmobile-cli — global) installed and ready to go, you’ll also want to make sure you’ve got your AWS_ACCESS_KEY and AWS_SECRET_KEY to hand.</p> <p>Let’s setup our CLI to ensure it can connect to AWS.</p> <pre><strong>#bash </strong></pre> <pre>$ awsmobile configure<br>$ configure aws<br>? accessKeyId:  [ENTER YOUR ACCESS KEY ID] #hit enter<br>? secretAccessKey: [ENTER YOUR SECRET ACCESS KEY] #hit enter<br>? region:  eu-west-2 #select your region using arrows and hit enter</pre> <p>Now you’re all setup and connected to AWS let’s setup your app.</p> <h4>Setup</h4> <p>I’ll leave it up to you to decide whether you choose to use create-react-native-app or react-native-init, both have there advantages and disadvantages that are beyond the spec of this post. I’ll be using react-native init.</p> <pre>#<strong>bash </strong></pre> <pre>react-native init awsMobileApp<br>This will walk you through creating a new React Native project in /Users/jameshamann/Documents/Development/awsMobileApp<br>Using yarn v1.3.2<br>Installing react-native...<br>[...]<br>✨  Done in 6.10s.<br>To run your app on iOS:<br>   cd /Users/jameshamann/Documents/Development/awsMobileApp<br>   react-native run-ios<br>   - or -<br>   Open ios/awsMobileApp.xcodeproj in Xcode<br>   Hit the Run button<br>To run your app on Android:<br>   cd /Users/jameshamann/Documents/Development/awsMobileApp<br>   Have an Android emulator running (quickest way to get started), or a device connected<br>   react-native run-android</pre> <p>Next you’ll probably want to set up your Github repo and push everything up. Then install both AWS Amplify and AWS Amplify React Native.</p> <pre>#<strong>bash </strong></pre> <pre>$ npm install aws-amplify --save<br>$ npm install aws-amplify-react-native --save</pre> <p>Now we’ll initialise a awsmobile project, which will setup a backend for our app and connect it to AWSMobile hub.</p> <pre><strong>#bash</strong></pre> <pre>awsmobile init</pre> <pre>Please tell us about your project:<br>? Where is your project's source directory:  /<br>? Where is your project's distribution directory that stores build artifacts:  /<br>? What is your project's build command:  npm run-script build<br>? What is your project's start command for local test run:  npm run-script start</pre> <pre>? What awsmobile project name would you like to use:  awsMobileAppExample</pre> <pre>Successfully created AWS Mobile Hub project: awsMobileAppExample</pre> <pre>retrieving the latest backend awsmobile project information<br>awsmobile project's details logged at: awsmobilejs/#current-backend-info/backend-details.json<br>awsmobile project's access information logged at: awsmobilejs/#current-backend-info/aws-exports.js<br>awsmobile project's access information copied to: aws-exports.js<br>awsmobile project's specifications logged at: awsmobilejs/#current-backend-info/mobile-hub-project.yml<br>contents in #current-backend-info/ is synchronized with the latest in the aws cloud</pre> <pre>Executing yarn add aws-amplify ...<br>[...]<br>Success! your project is now initialized with awsmobilejs</pre> <pre>awsmobilejs/.awsmobile<br>     is the workspace of awsmobile-cli, please do not modify its contents</pre> <pre>awsmobilejs/#current-backend-info<br>     contains information of the backend awsmobile project from the last<br>     synchronization with the cloud</pre> <pre>awsmobilejs/backend<br>     is where you develop the codebase of the backend awsmobile project</pre> <pre>awsmobile console<br>     opens the web console of the backend awsmobile project</pre> <pre>awsmobile run<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and runs the frontend application locally</pre> <pre>awsmobile publish<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and publishes the frontend application to aws S3 for hosting</pre> <pre>Happy coding with awsmobile!</pre> <p>That simple command pretty much sets everything up for you within a <strong>awsmobilejs</strong> directory within your app. If you head over to the AWS console, you should see your project, like this.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*Ae5TkV1NbfbXhKpomKPgSQ.png"><figcaption>AWS Mobile Hub</figcaption></figure><p>AWS Mobile includes the main features you’d need for your mobile app, and there’s obviously plenty of other AWS Services you can tie into your mobile app. The ones that come bundled in can be found by using the awsmobile command.</p> <pre><strong>#bash</strong></pre> <pre>$ awsmobile features</pre> <pre>? select features:  (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)<br>❯◯ user-signin<br> ◯ user-files<br> ◯ cloud-api<br> ◯ database<br> ◉ analytics<br> ◉ hosting</pre> <pre>[...]<br>enabled: user-signin<br>backend awsmobile project enabled features:<br>analytics, hosting, user-signin</pre> <p>From here you can select whatever feature you’d like to add, for arguments sake let’s add authentication.</p> <p>Next, we’ll use AWS Amplify’s component <strong>withAuthenticator.</strong></p> <p>Let’s edit our <strong>App.js </strong>to include the component and then wrap our entire app around it. The main thing we’ll need to edit is changing the class from <strong>export default class App extends Component </strong>to <strong>Class App extends Component </strong>and then export the App at the bottom of the file as an argument in our <strong>withAuthenticator </strong>component. We’ll also need to</p> <pre><strong>#javascript - App.js</strong></pre> <pre>[...]</pre> <pre>import Amplify from 'aws-amplify';<br>import { withAuthenticator } from 'aws-amplify-react-native';<br>import aws_exports from './aws-exports';<br>Amplify.configure(aws_exports);<br>[...]</pre> <pre>class App extends Component&lt;Props&gt; { </pre> <pre>[...]</pre> <pre>}</pre> <pre>export default withAuthenticator(App);</pre> <p>Now let’s boot our app up in an emulator. It should look similar to the below, with all the basics setup, including routing.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JLYQ4CNKr4DkriQS8WXL1Q.png"><figcaption>Authentication Front End Setup</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dvNp1DqBL5xAwAP0ilppyA.png"></figure><p>When trying to sign up, however, you’ll notice there’s an error <strong>No userPool.</strong> That’s because we haven’t synced our backend with the cloud yet.</p> <pre><strong>#bash </strong></pre> <pre>$awsmobile push</pre> <pre>[...]</pre> <p>Once this is complete, reboot your app on the emulator and try signing up. Boom, you’ve got a full authentication system ready to go, built in with SMS confirmations. (please check AWS Billing/Charges to make sure you don’t incur any unwanted charges). Once a user Signs up, they’ll be visible in your AWS Cognito Pool.</p> <p>It’s super simple to get setup and going with AWS, plus with the addition of AWS Amplify, it’s even easier to connect essential AWS Services to your app.</p> <p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"></figure><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fb2034e60160" width="1" height="1"> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>A brief guide to Semantic Versioning</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sr-foEv_uj2kJ4Ew6mhDvw.jpeg"></figure></p> <p>Whenever releasing a product or app, you’ll want to version it. This helps users understand what stage the app is at and also helps when integrating the app into package managers. In Software Development, we version apps by following <strong>Semantic Versioning, </strong>which is a general template that everyone uses and understands.</p> <blockquote>Why bother?</blockquote> <p>Versioning our apps helps us keep track of what’s been added/removed at what point. It can get real hectic, real fast, especially in the early stages when you’re releasing new features and fixing bugs. You’re gonna want to reference things that have been added or things that have been fixed.</p> <blockquote>Where would I keep a track of this?</blockquote> <p>You can <strong>tag </strong>your releases on <strong>Github </strong>using <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging"><strong>git tag.</strong></a><strong> </strong>Essentially, you just tag a version number to a specific commit, like a merge, push it and this appears on the repository under “releases”, with any notes you’d like to add. It’s best to keep track of all these changes in a <strong>CHANGELOG, </strong>there’s a nice format to follow outlined <a href="https://keepachangelog.com/en/1.0.0/">here.</a> This way you can keep track of what’s been fixed and any upcoming features that are being released into the next version. It’s also important to remember, software is built for people. So people need to actually understand what’s going on and at what stage your apps currently at, having a well documented<strong> CHANGELOG</strong> helps provide a clear timeline and explanation of your app.</p> <blockquote>Ok, so how do I go about versioning my app/package?</blockquote> <h4>0 — Pre-MVP/Alpha</h4> <p>At this stage, you’re developing your app and still building towards an MVP. There’s no real point differentating between versions here because it’s not a useable product yet. During this period, the version will remain at <strong>0.</strong></p> <h4><strong>Major.Minor.Patch — Alpha/Beta</strong></h4> <p>Once you reach your <strong>MVP, </strong>you might iterate over this and create <strong>Alpha/Beta </strong>releases for users to test and supply feedback on. When creating your first release, you’ll want to start versioning. This helps you keep track of your app and creates a timeline of what features were added when and what bugs have and have not been fixed yet. You might be wondering, what exactly constitutes a major, minor or patch release.</p> <p><strong>Major Release — </strong>Increment the first digit by 1 if the new features break backwards compatibility/current features</p> <p><strong>Minor Release — </strong>Increment the middle digit by 1 if the new features don’t break any existing features and are compatible with the app in it’s current state.</p> <p><strong>Patch Release — </strong>Increment the last digit by 1 if you’re publishing bug/patch fixes to your app.</p> <p>Before publishing your first, useable version, you might find yourself incrementing the middle and the last digit to keep track of Alpha/Beta releases. Only once you’re ready for a proper, first release, should you start versioning from 1.0.0.</p> <p>I can’t stress enough the benefits of keeping a clean, well documented CHANGELOG. Regardless of whether your project is open source or not, it’s vital to keep track of what’s been worked on. It helps guide you when deciding what features need work and gives you good insight into your release cycle.</p> <p>If you’re interested in reading more, you can get the full breakdown of <a href="https://semver.org/">Semantic Versioning on their site.</a></p> <p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"></figure><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c6055d87c90e" width="1" height="1"> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi Ezequiel Frescó Werchowsky, thanks for reading and getting in touch!</b></h4> <p style="text-align:justify"></p> <p>Hi <a href="https://medium.com/u/92d053321ec7">Ezequiel Frescó Werchowsky</a>, thanks for reading and getting in touch! Apologies, it seems like I might’ve done, thank you for letting me know, I’ll update the post with the changes.</p> <p>Regarding your error, it looks like it’s an issue with AWS and not being able to read your credentials. Have you downloaded the AWS CLI (<a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html">https://docs.aws.amazon.com/cli/latest/userguide/installing.html</a>), if so run the command: aws configure. This will prompt you to enter you AWS_ACCESS_KEY and your AWS_SECRET_ACCESS_KEY, which can be retrieved from the AWS console, under “My Secruity Credentials”, on the top right dropdown by your username.</p> <p>Try the above and let me know if you run into any other issues, I’m happy to help!</p> <p>Thanks, James</p> <img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3be6aa3813e8" width="1" height="1"> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Ryan Pereira Thanks for reading and getting in touch!</b></h4> <p style="text-align:justify"></p> <p><a href="https://medium.com/u/bf1bb52caac4">Ryan Pereira</a> Thanks for reading and getting in touch!</p> <p>Here, I’m explaining that you should setup a brand new jekyll site and add your Gem, that you’ve just built, to the Gemfile and running bundle install. When adding your gem, you need to specify it’s path, like this:<strong> gem “YOURTHEME” =&gt; :path =&gt; “path/to/your/gem”.</strong></p> <p>Looking at the error from your previous comment, I suggest running gem install bundler and gem install jekyll again, looks like maybe an issue with the Ruby Version. In which case it might be best to upgrade to 2.4 +. To upgrade your ruby version, you can install <a href="https://rvm.io/">RVM</a> (ruby version manager).</p> <p>This is only applicable if you’re looking to build your own Gem Theme and publish it. If you wish to use an existing theme, you can use the one I created (jekyll-material-theme) and customise it or grab one from <a href="http://jekyllthemes.org/">http://jekyllthemes.org/</a>.</p> <p>Hope this helps a little! Let me know if you need anything else.</p> <p>Thanks, James</p> <img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3e1c288759dc" width="1" height="1"> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Configuring your Elastic Beanstalk App for SSL</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/859/1*a96dh5kNx9M4xzB2EiRjuQ.png"></figure></p> <p>It’s always a good idea to add a SSL certificate. It gives people piece of mind when visiting your site that information isn’t being accessed by third-parties and also<a href="https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html"> boosts your SEO ranking in Google.</a> Setting your Elastic Beanstalk app up for SSL isn’t too difficult and requires just a few simple steps.</p> <h4>Getting Started</h4> <p>I’m going to assume you have a domain already registered, either living in <a href="https://aws.amazon.com/route53/">Route 53</a> or another domain provider. To start with, if you haven’t done so already, you’ll need to point your domain to your EB app. This can be done by creating an Alias <strong>A Record </strong>and setting it’s value equal to your EB App’s <strong>URL. </strong>This can be found on the Elastic Beanstalk Dashboard.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AxGaW7tST3TXrMEGB5f59A.png"><figcaption>Elastic Beanstalk Management Console</figcaption></figure><p>In this example, it’s <a href="http://ssl-example.eu-west-2.elasticbeanstalk.com">http://ssl-example.eu-west-2.elasticbeanstalk.com</a>. When adding this to your domain, ensure the A record is set to <strong>Yes </strong>for <strong>Alias.</strong> The value will then be your app’s Elastic Beanstalk URL.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/824/1*lPbprwruQj6NT15ArSHKsw.png"><figcaption>Route 53 Configuration for an A Record</figcaption></figure><p>Now, if you visit your domain, in my case <a href="http://sslexample.jameshamann.com">sslexample.jameshamann.com</a>, you’ll see your app! You can try to type <a href="https://yourdomain.com">https://yourdomain.com</a> but as there’s no certificate, the request will timeout. So let’s add a certificate!</p> <h4>Configure your App</h4> <p>In order to use a SSL certificate for your Elastic Beanstalk App, you’ll need to change the configuration of your app to use <strong>Load Balancers </strong>as opposed to a single instance. This can cost more, so please check your billing dashboard to ensure you’re not going over budget or anything.</p> <blockquote>What are Application Load Balancers?</blockquote> <p>In essence, instead of running a single instance, a load balancer distributes traffic across multiple targets, instances, across multiple availability zones, which boosts availability of your app.</p> <p>In our example the SSL certificate is applied to the load balancer, so connections between the Client and Load Balancer are secure and encrypted.</p> <p>In order to configure your app, head to the <strong>Configuration </strong>tab of your Elastic Beanstalk dashboard and click the <strong>modify </strong>link on the <strong>Capacity </strong>card.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*p_0OSYzUKzxnVcDyIx1UTg.png"><figcaption>Configuration Tab of Elastic Beanstalk App — Capacity card located at the top right</figcaption></figure><p>Once here, the only thing I advise you to change is the maximum number of instances, from <strong>4 to 1</strong>, however that’s up to you.</p> <p>Don’t change anything else, just hit <strong>Save.</strong></p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gLJNgOZBKkiCGlXF7fT-WA.png"><figcaption>Adding a Load Balancer</figcaption></figure><p>This will then take you back to the configuration page, where you’ll need to hit <strong>Apply </strong>for your changes to take place. As your app will be unavailable for a short period whilst the changes take place, you’ll need to confirm again after hitting Apply.</p> <h4>Creating an SSL Certificate with ACM</h4> <p>Now we need to actually create our certificate. As we’re using Elastic Beanstalk, it makes sense to create a certificate in ACM (Amazon Certificate Manager).</p> <p>In my case, I opted for a wildcard certificate for the domain <strong>jameshamann.com. </strong>This means all alias domains, i.e sslexample.jameshamann.com will be covered by the same SSL certificate. To do this, head over to <strong>ACM </strong>and request a certificate. Type in your domain, if you wish to setup a wild card add a * to the beginning of your domain.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9m-OrW6A1FSoG69zCP7J7A.png"><figcaption>AWS Certificate Manager Requesting a Certificate</figcaption></figure><p>You’ll have two options to validate that you’re the owner of the domain. DNS or Email. I chose DNS, but whatever you choose, just make sure you have access to the correct email domains if choosing email.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2ljBzx4kwrwjG4WOyqIfQA.png"><figcaption>DNS Config for domain</figcaption></figure><p>To verify via DNS, you’ll need to add a CNAME record with whatever values are generated in your <strong>DNS_Configuration.csv </strong>file.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/872/1*xF8yRtr4dISmP3LOZTjsnw.png"><figcaption>Enter the Name value from the .csv file and the Value from the .csv file and hit create.</figcaption></figure><p>This will take a little time to verify, but once done, your certificate should move from <strong>Pending </strong>to <strong>Issued.</strong></p> <h4>Bringing it all together</h4> <p>Lastly, we need to apply our newly created SSL Certificate to our App’s Load Balancer. To do this, navigate to the Configuration Tab of your Elastic Beanstalk App. There should be a new card labelled <strong>Load Balancer.</strong></p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RDqYx_EicYyrVFw-x-wVyA.png"><figcaption>Click <strong>modify </strong>on the <strong>Load Balancer </strong>card</figcaption></figure><p>In order to add the certificate, we’ll need to open up port <strong>443 </strong>(SSL Port) and assign our certificate.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IVTxvbsh7tQ9RlaQ-1bOBA.png"></figure><p>If your certificate doesn’t appear in the dropdown, try refreshing and waiting a bit. Once it does, choose it and hit save. Again, you’ll be directed back to the Configuration page where you’ll have to <strong>Apply </strong>your changes.</p> <p>Once completeled, navigate to <a href="https://yourdomain.com"><strong>https://yourdomain.com</strong></a><strong> </strong>and you should see your site served through HTTPS.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hs4xzNHX06qnQXAW2jWRhQ.png"><figcaption>Site Secured!</figcaption></figure><p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"></figure><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9065ca091f49" width="1" height="1"> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Node.js RESTful API with DynamoDB Local</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ejTEhVznAjlYSXsWz5zZ7A.png"></figure></p> <p>Node is usually used along side MongoDB in the <strong>MEAN</strong> stack. However, using Amazon’s DynamoDB has it’s own benefits, not least from speed, scalability, affordability and freeing your time up from configuring database clusters/updates. Through this post I’ll discuss how to setup DynamoDB with your Node project locally.</p> <h4>Versions</h4> <ul> <li>Node 9.2.1</li> <li>Express 4.15.5</li> <li>DynamoDB Local — <a href="https://s3.eu-central-1.amazonaws.com/dynamodb-local-frankfurt/dynamodb_local_latest.tar.gz">Latest</a> </li> <li> <a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html">JRE</a> (Java Runtime Environment) 6.x or newer</li> </ul> <h4>Setting up your Node Project</h4> <p>To get things moving quickly, we’ll use the express generator to scaffold a project for us.</p> <pre><strong>#bash</strong></pre> <pre>$ express node-dynamo-db<br>   <br>   create : node-dynamo-db<br>   create : node-dynamo-db/package.json<br>   create : node-dynamo-db/app.js<br>   create : node-dynamo-db/public<br>   create : node-dynamo-db/routes<br>   create : node-dynamo-db/routes/index.js<br>   create : node-dynamo-db/routes/users.js<br>   create : node-dynamo-db/views<br>   create : node-dynamo-db/views/index.jade<br>   create : node-dynamo-db/views/layout.jade<br>   create : node-dynamo-db/views/error.jade<br>   create : node-dynamo-db/bin<br>   create : node-dynamo-db/bin/www<br>   create : node-dynamo-db/public/javascripts<br>   create : node-dynamo-db/public/images<br>   create : node-dynamo-db/public/stylesheets<br>   create : node-dynamo-db/public/stylesheets/style.css</pre> <pre>install dependencies:<br>     $ cd node-dynamo-db &amp;&amp; npm install</pre> <pre>run the app:<br>     $ DEBUG=node-dynamo-db:* npm start</pre> <pre>$ cd node-dynamo-db<br>$ npm install</pre> <p>Fire up your server to ensure it’s all working as intended.</p> <pre>$ npm start</pre> <p>Navigate to <a href="http://localhost:3000">http://localhost:3000</a> and you’ll see the welcome page from express, like below.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*t5zAKeNYDFMigF_oyNIUdA.png"><figcaption>Generic Express Welcome Page</figcaption></figure><p>Next, as there’s no live-reloading, we’ll install Nodemon to watch our files and whenever a change is made, it’ll restart the server for us. Without Nodemon, you’re gonna get frustrated real fast. Once installed, we’ll update our <strong>start </strong>command within the <strong>package.json</strong> to run the <strong>nodemon </strong>command as opposed to node.</p> <pre><strong>#bash </strong></pre> <pre>$ npm install -g nodemon</pre> <pre>--------------------------------------------------------------------</pre> <pre><strong>#package.json </strong></pre> <pre>{<br>  "name": "node-dynamo-db",<br>  "version": "0.0.0",<br>  "private": true,<br>  "scripts": {<br><strong>    "start": "nodemon  ./bin/www"<br></strong>  },<br>  "dependencies": {<br>    "body-parser": "~1.18.2",<br>    "cookie-parser": "~1.4.3",<br>    "debug": "~2.6.9",<br>    "express": "~4.15.5",<br>    "jade": "~1.11.0",<br>    "morgan": "~1.9.0",<br>    "serve-favicon": "~2.4.5"<br>  }<br>}</pre> <h4>Setting up DynamoDB</h4> <p>First download the file from the link above, unpack it and navigate into the directory. You’ll notice DynamoDB is provided as an executable .jar file. In order to start the database up, we need to run the following command within the directory the .jar file is located.</p> <pre><strong>#bash </strong></pre> <pre>$ java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb</pre> <pre>Initializing DynamoDB Local with the following configuration:<br>Port: 8000<br>InMemory: false<br>DbPath: null<br>SharedDb: true<br>shouldDelayTransientStatuses: false<br>CorsParams: *</pre> <p>Boom, you’ve got a local instance of DynamoDB running! Problem is, unless you’re gifted with photographic memory, you’re probably not going to rememeber the above command and even if you do, it’s ballache to write out each time. Lets speed things up and create an <a href="https://medium.com/@jameshamann/automation-with-cron-d10f7cbbb638">alias</a> command within our <strong>.bashrc </strong>or <strong>.zshrc, </strong>depending on what you use. Mine looks like this.</p> <pre><strong>#bash .zshrc or .bashrc</strong></pre> <pre>alias ddb="cd path/to/dynamodb_local_latest &amp;&amp; java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb"</pre> <p>I’ve named my alias <strong>ddb, </strong>it navigates to the directory and then executes the .jar, simple as that. Now when reloading my terminal window and running ddb, DynamoDB should spin up.</p> <pre><strong>#bash</strong></pre> <pre>$ ddb</pre> <pre>Initializing DynamoDB Local with the following configuration:<br>Port: 8000<br>InMemory: false<br>DbPath: null<br>SharedDb: true<br>shouldDelayTransientStatuses: false<br>CorsParams: *</pre> <p>Now we’re all set to start creating our table and to begin seeding some data into our table. For the purpose of this demo, I’ll be making a database revolving around cars.</p> <p>Before moving forward, let’s just update our <strong>package.json </strong>to automate some of the commands we’ll be running fairly frequently.</p> <pre>{<br>  "name": "crafty-api",<br>  "version": "0.0.0",<br>  "private": true,<br>  "scripts": {<br>   <strong> "start": "nodemon app.js",<br></strong>    <strong>"create-db": "cd dynamodb &amp;&amp; node createCarsTable.js &amp;&amp; cd ..",<br>    "delete-db": "cd dynamodb &amp;&amp; node deleteCarsTable.js &amp;&amp; cd ..",<br>    "load-data": "cd dynamodb &amp;&amp; node loadCarData.js &amp;&amp; cd ..", <br>    "read-data": "cd dynamodb &amp;&amp; node readDataTest.js &amp;&amp; cd .."<br></strong>  },<br>  "dependencies": {<br>    "aws-sdk": "^2.176.0",<br>    "body-parser": "~1.18.2",<br>    "cookie-parser": "~1.4.3",<br>    "cors": "^2.8.4",<br>    "debug": "~2.6.9",<br>    "ejs": "^2.5.7",<br>    "express": "~4.15.5",<br>    "jade": "~1.11.0",<br>    "morgan": "~1.9.0",<br>    "newman": "^3.9.1",<br>    "node-uuid": "^1.4.8",<br>    "serve-favicon": "~2.4.5",<br>    "uuid": "^3.2.1"<br>  }<br>}</pre> <p>This is what my current one looks like and it just speeds things up so much, so consider adding your own to speed up your workflow.</p> <p>First things first, we’re gonna need to create a table and choose a <strong>partition key. </strong>Amazon provided pretty good advice <a href="https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key/">here</a> on what constitutes as a good key. Reason we need a key is because Dynamo DB partitions our data across multiple storage units and uses that key to both store and read the data. Therefore, <strong>the partition key must be a unique value</strong>. Good examples are user_ids and devices_ids.</p> <p>For my table I’ve chosen <strong>car_id.</strong></p> <pre><strong>#JavaScript - createCarsTable.js</strong></pre> <pre>var AWS = require("aws-sdk");</pre> <pre>AWS.config.update({<br>  region: "eu-west-2",<br>  endpoint: "<a href="http://localhost:8000">http://localhost:8000</a>"<br>});</pre> <pre>var dynamodb = new AWS.DynamoDB();</pre> <pre>var params = {<br>    TableName : "Cars",<br>    KeySchema: [<br>        { AttributeName: "id", KeyType: "HASH"}, <strong> //Partition key</strong></pre> <pre>],<br>    AttributeDefinitions: [<br>        { AttributeName: "id", AttributeType: "N" },</pre> <pre>],<br>    ProvisionedThroughput: {<br>        ReadCapacityUnits: 5,<br>        WriteCapacityUnits: 5<br>    }<br>};</pre> <pre>dynamodb.createTable(params, function(err, data) {<br>    if (err) {<br>        console.error("Unable to create table. Error JSON:", JSON.stringify(err, null, 2));<br>    } else {<br>        console.log("Created table. Table description JSON:", JSON.stringify(data, null, 2));<br>    }<br>});</pre> <p>Now run you’re <strong>create-db </strong>command, making sure Dynamo DB is running in the background on another terminal window, on port 8000.</p> <pre><strong>#bash</strong></pre> <pre>yarn create-db<br>yarn run v1.3.2<br>$ cd dynamodb &amp;&amp; node createCarsTable.js &amp;&amp; cd ..<br>Created table. Table description JSON: {<br>  "TableDescription": {<br>    "AttributeDefinitions": [<br>      {<br>        "AttributeName": "id",<br>        "AttributeType": "N"<br>      }<br>    ],<br>    "TableName": "Cars",<br>    "KeySchema": [<br>      {<br>        "AttributeName": "id",<br>        "KeyType": "HASH"<br>      }<br>    ],<br>    "TableStatus": "ACTIVE",<br>    "CreationDateTime": "2018-02-01T16:08:25.308Z",<br>    "ProvisionedThroughput": {<br>      "LastIncreaseDateTime": "1970-01-01T00:00:00.000Z",<br>      "LastDecreaseDateTime": "1970-01-01T00:00:00.000Z",<br>      "NumberOfDecreasesToday": 0,<br>      "ReadCapacityUnits": 5,<br>      "WriteCapacityUnits": 5<br>    },<br>    "TableSizeBytes": 0,<br>    "ItemCount": 0,<br>    "TableArn": "arn:aws:dynamodb:ddblocal:000000000000:table/Cars"<br>  }<br>}<br>✨  Done in 0.47s.</pre> <p>Now you’re table is setup and ready to seed data into.</p> <p>In this example, we’re using Dynamo DB’s <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#putItem-property"><strong>PutItem</strong></a><strong> </strong>method to seed some data into our Database.</p> <pre>#<strong>JSON - carData.json </strong></pre> <pre>[<br>  { "id": 1,<br>    "type" : "Automatic",<br>    "name" : "Toyota Yaris",<br>    "manufacturer" : "Toyota",<br>    "fuel_type" : "Petrol",<br>    "description" : "A smooth ride"<br>  },<br>  { "id": 2,<br>    "type" : "Manual",<br>    "name" : "Volkswagen Golf",<br>    "manufacturer" : "Volkswagen",<br>    "fuel_type" : "Petrol",<br>    "description" : "Good Value"<br>  }<br>]</pre> <pre>------------------------------------------------------------------</pre> <pre>#<strong>JavaScript - loadCarData.js</strong></pre> <pre>var AWS = require("aws-sdk");<br>var fs = require('fs');</pre> <pre>AWS.config.update({<br>    region: "eu-west-2",<br>    endpoint: "<a href="http://localhost:8000">http://localhost:8000</a>"<br>});</pre> <pre>var docClient = new AWS.DynamoDB.DocumentClient();</pre> <pre>console.log("Importing Cars into DynamoDB. Please wait.");</pre> <pre>var cars = JSON.parse(fs.readFileSync('carData.json', 'utf8'));</pre> <pre>cars.forEach(function(car) {<br>  console.log(car)</pre> <pre>var params = {<br>        TableName: "Cars",<br>        Item: {<br>            "id": car.id,<br>            "type": car.type,<br>            "name": car.name,<br>            "manufacturer": car.manufacturer,<br>            "fuel_type": car.fuel_type,<br>            "description": car.description<br>        }<br>    };</pre> <pre>docClient.put(params, function(err, data) {<br>       if (err) {<br>           console.error("Unable to add Car", car.name, ". Error JSON:", JSON.stringify(err, null, 2));<br>       } else {<br>           console.log("PutItem succeeded:", car.name);<br>       }<br>    });<br>});</pre> <p>If you run your <strong>load-data </strong>command, it should seed in the two items in our <strong>carData.json </strong>file and log the names back in the console, like below.</p> <pre>#<strong>bash </strong></pre> <pre>yarn load-data<br>yarn run v1.3.2<br>$ cd dynamodb &amp;&amp; node loadCarData.js &amp;&amp; cd ..<br>Importing Cars into DynamoDB. Please wait.<br>{ id: 1,<br>  type: 'Automatic',<br>  name: 'Toyota Yaris',<br>  manufacturer: 'Toyota',<br>  fuel_type: 'Petrol',<br>  description: 'A smooth ride' }<br>{ id: 2,<br>  type: 'Manual',<br>  name: 'Volkswagen Golf',<br>  manufacturer: 'Volkswagen',<br>  fuel_type: 'Petrol',<br>  description: 'Good Value' }<br>PutItem succeeded: Toyota Yaris<br>PutItem succeeded: Volkswagen Golf<br>✨  Done in 0.46s.</pre> <p>Now our datas in there, but how do we know? Let’s run a quick test using Dynamo DBs<a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html"> DocumentClient </a><strong>.get </strong>method. <strong>DocumentClient </strong>is just a class that simplifies working with DynamoDB Items.</p> <pre>#<strong>JavaScript - readDataTest.js </strong></pre> <pre>var AWS = require("aws-sdk");</pre> <pre>AWS.config.update({<br>  region: "eu-west-2",<br>  endpoint: "<a href="http://localhost:8000">http://localhost:8000</a>"<br>});</pre> <pre>var docClient = new AWS.DynamoDB.DocumentClient()</pre> <pre>var table = "Cars";</pre> <pre>var id = 1;</pre> <pre>var params = {<br>    TableName: table,<br>    Key:{<br>        "id": id<br>    }<br>};</pre> <pre>docClient.get(params, function(err, data) {<br>    if (err) {<br>        console.error("Unable to read item. Error JSON:", JSON.stringify(err, null, 2));<br>    } else {<br>        console.log("GetItem succeeded:", JSON.stringify(data, null, 2));<br>    }<br>});</pre> <p>Remembering our JSON file, we should expect the <strong>Toyota Yaris</strong> to be returned to the console…</p> <pre>#<strong>bash</strong><br>$ yarn read-data<br>yarn run v1.3.2<br>$ cd dynamodb &amp;&amp; node readDataTest.js &amp;&amp; cd ..<br>GetItem succeeded: {<br>  "Item": {<br>    "name": "Toyota Yaris",<br>    "description": "A smooth ride",<br>    "id": 1,<br>    "type": "Automatic",<br>    "fuel_type": "Petrol",<br>    "manufacturer": "Toyota"<br>  }<br>}<br>✨  Done in 0.56s.</pre> <p>BAM! DynamoDB is setup and seeded with data, now we just need to bring all the elements together.</p> <h4><strong>Bringing it all together</strong></h4> <p>At the moment, our Node backend isn’t actually talking to Dynamo DB at all, lets change that by incorporating some of the methods we’ve used above and create a route that returns <strong>all cars.</strong></p> <p>To do this we’re going to using <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html">DynamoDBs DocClient</a> <strong>scan </strong>method.</p> <pre>#<strong>Javascript app.js</strong></pre> <pre>var express = require('express');<br>var path = require('path');<br>var favicon = require('serve-favicon');<br>var logger = require('morgan');<br>var cookieParser = require('cookie-parser');<br>var bodyParser = require('body-parser');<br>var AWS = require("aws-sdk");</pre> <pre>var app = express();</pre> <pre>app.listen(3000, () =&gt; console.log('Cars API listening on port 3000!'))</pre> <pre>AWS.config.update({<br>  region: "eu-west-2",<br>  endpoint: "<a href="http://localhost:8000">http://localhost:8000</a>"<br>});</pre> <pre>var docClient = new AWS.DynamoDB.DocumentClient();</pre> <pre>app.use(logger('dev'));<br>app.use(bodyParser.json());<br>app.use(bodyParser.urlencoded({ extended: false }));<br>app.use(cookieParser());<br>app.set('view engine', 'jade');</pre> <pre>app.get('/', function (req, res) {<br>  res.send({ title: "Cars API Entry Point" })<br>})</pre> <pre>app.get('/cars', function (req, res) {</pre> <pre>var params = {<br>    TableName: "Cars",<br>    ProjectionExpression: "#id, #name, #type, #manufacturer, #fuel_type, #description",<br>    ExpressionAttributeNames: {<br>        "#id": "id",<br>        "#name": "name",<br>        "#type": "type",<br>        "#manufacturer": "manufacturer",<br>        "#fuel_type": "fuel_type",<br>        "#description": "description"<br>    }<br>};</pre> <pre>console.log("Scanning Cars table.");<br>docClient.scan(params, onScan);</pre> <pre>function onScan(err, data) {<br>    if (err) {<br>        console.error("Unable to scan the table. Error JSON:", JSON.stringify(err, null, 2));<br>    } else {<br>        res.send(data)<br>        // print all the Cars<br>        console.log("Scan succeeded.");<br>        data.Items.forEach(function(car) {<br>           console.log(car.id, car.type, car.name)<br>        });</pre> <pre>if (typeof data.LastEvaluatedKey != "undefined") {<br>            console.log("Scanning for more...");<br>            params.ExclusiveStartKey = data.LastEvaluatedKey;<br>            docClient.scan(params, onScan);<br>        }<br>    }<br>  }<br>})</pre> <p>This is what you want your <strong>app.js </strong>file to look like. I know we can refactor this and move some code to the routes folder, however for the purposes of keeping this article as to the point as possible, I’ll leave that to you.</p> <p>As the file shows, we create a new route called <strong>/cars </strong>and create a params variable, which contains the name of the table and what we want to be returned from our scan. We then create a function called <strong>onScan </strong>which sends our data to the client and logs our results to console. This also contains some error catching, should there be any issues with your request.</p> <p>Now, if you navigate to <a href="http://localhost:3000/cars"><strong>http://localhost:3000/cars</strong></a><strong> </strong>you should see something resembling the below.</p> <pre>#<strong>JSON - response from </strong><a href="http://localhost:3000/cars"><strong>http://localhost:3000/cars</strong></a></pre> <pre>{"Items":[{"name":"Volkswagen Golf","description":"Good Value","id":2,"fuel_type":"Petrol","type":"Manual","manufacturer":"Volkswagen"},{"name":"Toyota Yaris","description":"A smooth ride","id":1,"fuel_type":"Petrol","type":"Automatic","manufacturer":"Toyota"}],"Count":2,"ScannedCount":2}</pre> <p>Great job! Now you’ve got building blocks of a Node.js RESTful API using AWS DynamoDB.</p> <p>Let’s do one more route where we ask DynamoDB to return a car, by <strong>id.</strong></p> <p>Let’s call our route <strong>/cars/:id. </strong>We’ll pass the ID in via our request url. We’ll then use the ID to query the table and return us the correct car. We get the<strong> id </strong>value by slicing the string to return us only the number.</p> <p>Remember, however, when we created our table we specified that the <strong>id was a number type.</strong> Therefore if we try to pass the value, as it is, to DynamoDB, it’ll spit back an error. <strong>We first need to convert our id value from string to integer using parseInt().</strong></p> <pre><strong>#JavaScript - app.js</strong></pre> <pre>[...]</pre> <pre>app.get('/cars/:id', function (req, res) {</pre> <pre>var carID = parseInt(req.url.slice(6));<br>  console.log(req.url)<br>  console.log(carID)</pre> <pre>var params = {<br>      TableName : "Cars",<br>      KeyConditionExpression: "#id = :id",<br>      ExpressionAttributeNames:{<br>          "#id": "id"<br>      },<br>      ExpressionAttributeValues: {<br>          ":id": carID<br>      }<br>  };</pre> <pre>docClient.query(params, function(err, data) {<br>    if (err) {<br>        console.error("Unable to query. Error:", JSON.stringify(err, null, 2));<br>    } else {<br>        console.log("Query succeeded.");<br>        res.send(data.Items)<br>        data.Items.forEach(function(car) {<br>            console.log(car.id, car.name, car.type);<br>        });<br>    }<br>});</pre> <pre>});</pre> <p>We save our converted <strong>carID </strong>value in a variable and use this in our params object. We then use the <strong>query </strong>method to gather and return the data to the client. If all is setup correctly, you should be able to navigate to <a href="http://localhost:3000/cars/1"><strong>http://localhost:3000/cars/1</strong></a><strong> </strong>and see that the Yaris is returned as JSON. If you check your terminal you’ll see the <strong>id, name and type </strong>of the car queried.</p> <pre>#<strong>JSON - </strong><a href="http://localhost:3000/cars/1"><strong>http://localhost:3000/cars/1</strong></a></pre> <pre>[{"name":"Toyota Yaris","description":"A smooth ride","id":1,"type":"Automatic","fuel_type":"Petrol","manufacturer":"Toyota"}]</pre> <pre>#<strong>bash</strong></pre> <pre>$ yarn start<br>[nodemon] starting `node app.js`<br>Cars API listening on port 3000!<br>/cars/1<br>1<br>Query succeeded.<br>1 'Toyota Yaris' 'Automatic'<br>GET /cars/1 200 47.279 ms - 126</pre> <p>From here you can add additional routes to search by car name, car type and look to implement POSTing to the DB. Hint: this will be similar to our <strong>loadCarData.js </strong>file, using DynamoDB’s <strong>PutItem </strong>function.</p> <p>Next time I’ll look to deploy our sample app to AWS Elastic Beanstalk along with AWS DynamoDB and implement a build pipeline with CircleCI and testing using Postman.</p> <p>If you wish, you can check all the code out here, at the example <a href="https://github.com/jameshamann/node-dynamo-db-example">Github Repo</a>.</p> <p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"></figure><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7e342a934a24" width="1" height="1"><hr> <p><a href="https://medium.com/quick-code/node-js-restful-api-with-dynamodb-local-7e342a934a24">Node.js RESTful API with DynamoDB Local</a> was originally published in <a href="https://medium.com/quick-code">Quick Code</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Automation With Cron</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iFN_PWPWs6TQ9JzDp2v9Wg.jpeg"></figure></p> <p>There’s been quite a few projects recently where I’ve found myself doing tedious things that can easily be automated. Enter <strong>Cron</strong>, the time-based job scheduler.</p> <p>Once or twice a week I find myself updating/rebuilding my Jekyll Site because it displays my Medium RSS feed as a Blog page. As the site is static, I need to re-build it every time I publish something new. It’s not an issue as it’s only a few commands, but sometimes I forget and weeks can go by without updating my site. Writing a Cron job is so stupidly easy, you’ll find yourself automating pretty much every mundane task you do.</p> <h4>Writing a Cron Job</h4> <pre><strong>#bash</strong></pre> <pre>$ env EDITOR=nano crontab -e #opens nano in your terminal, with your crontab open. </pre> <p>You should see something like this now, after running the above command.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BmkWB_Ewb4C4CUB4kyu4zQ.png"></figure><p>Ok so not exactly like this, as this contains my cron job, but it should be a nice empty text file. For my purpose, I decided to create an executable file with the commands and then get cron to run that, however you can run the commands inside here, it’s just tidier to write a script for it.</p> <h4><strong>Cron Time Intervals</strong></h4> <p>Cron works by executing your commands at a determined time, whether that be weekly on a Monday at 2pm or on the 15th of each month. The <strong>* * * * * </strong>at the start each determine a different time scale.</p> <ul> <li>1st character, * — Minute of the Day</li> <li>2nd character, * * — Hour of the Day</li> <li>3rd character, * * * — Day of the Month</li> <li>4th character, * * * * — Month of the Year</li> <li>5th character, * * * * * — Day of the Week (0–7, Sunday is both represented by a 0 and 7)</li> </ul> <p>You’ll notice in my example, I decided to execute every week on a Sunday.</p> <p>Here’s another example if you want to run a job at 6:30 every Tuesday.</p> <pre>#<strong>nano</strong></pre> <pre>30 18 * * 2 yourcommand #execute every Tuesday at 18:30</pre> <pre>45 07 10 * * yourcommand # execute every 10th day of the month at 07:45</pre> <pre>20 15 * * 3 yourcommand # execute at 15:20 every Wednesday</pre> <p>Let’s make this a little easier and add some shortcut commands to our <strong>.bashrc </strong>or <strong>.zshrc </strong>(depending on what you’re using).</p> <p>Using the <strong>alias </strong>command we can shortcut a long command to something a little easier to remember and type.</p> <pre>#<strong>.bashrc or .zshrc</strong></pre> <pre>alias newcron="env EDITOR=nano crontab -e" #open a new crontab<br>alias cronjobs="crontab -l" # list our cronjobs</pre> <p>Now you’re set to automate whatever you want!</p> <p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"></figure><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d10f7cbbb638" width="1" height="1"> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Circle CI and DynamoDB</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HB_1Qb46JUVaECkT4kv7FA.png"></figure></p> <p>After searching around whilst building a Node.js API project, I realised there wasn’t too much documented on how to setup CircleCI with AWS DynamoDB for testing purposes within your build pipeline. I thought I’d do a quick post to summarise the process and hopefully make it clearer for others who are trying to achieve the same.</p> <h4>Getting Started</h4> <p>As I mentioned above, I was building a Node.js API, however this process should translate regardless of the language or tools you’re using. Before going any further, please make sure you’ve entered your <strong>AWS_ACCESS_KEY</strong> and <strong>AWS_SECRET_KEY </strong>into your CircleCI Project. This can be done from the setting page of your Project, under the <strong>Permissions </strong>heading.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/706/1*ZML55IXm5lZjI-gjD-_cLA.png"><figcaption>Hit the <strong>AWS Permissions </strong>link and enter your variables</figcaption></figure><p>Now we’re going to need to edit our circleci <strong>config.yml </strong>file. The below is my finished version. I know it’s pretty long and messy and can definitely be refactored, but it does the job for now.</p> <pre><strong>#YAML</strong></pre> <pre>version: 2</pre> <pre>branches:<br>    only:<br>     - master # list of branches to build</pre> <pre>jobs:<br>  build:<br>    docker:<br>      - image: circleci/node</pre> <pre>working_directory: ~/repo</pre> <pre>steps:<br>      - checkout<br>      - run:<br>          name: Install Java<br>          command: 'sudo apt-get update &amp;&amp; sudo apt-get install default-jre default-jdk'<br>      - run:<br>          name: Install Python<br>          command: 'sudo apt-get update &amp;&amp; sudo apt-get install -y python-dev'<br>      - run:<br>          name: Install Python<br>          command: 'sudo curl -O <a href="https://bootstrap.pypa.io/get-pip.py'">https://bootstrap.pypa.io/get-pip.py'</a><br>      - run:<br>          name: Install Python<br>          command: 'sudo python get-pip.py'</pre> <pre>- run:<br>          name: Install AWS CLI<br>          command: 'sudo pip install awsebcli --upgrade'<br>      - run:<br>          name: Setup Container<br>          command: |<br>              curl -k -L -o dynamodb-local.tgz <a href="http://dynamodb-local.s3-website-us-west-2.amazonaws.com/dynamodb_local_latest.tar.gz">http://dynamodb-local.s3-website-us-west-2.amazonaws.com/dynamodb_local_latest.tar.gz</a><br>              tar -xzf dynamodb-local.tgz<br>              java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb<br>          background: true<br>      - run:<br>          name: Update yarn<br>          command: 'yarn global add npm@latest'<br>      - restore_cache:<br>          key: dependency-cache-{{ checksum "package.json" }}<br>      - run:<br>          name: Install Dependencies<br>          command: yarn install<br>      - save_cache:<br>          key: dependency-cache-{{ checksum "package.json" }}<br>          paths:<br>            - node_modules<br>      - run:<br>          name: Start Server<br>          command: 'yarn ci-start'<br>          background: true<br>      - run:<br>          name: Create Table<br>          command: 'yarn create-db'<br>      - run:<br>          name: Load Data<br>          command: 'yarn load-data'<br>      - run:<br>          name: Run Tests<br>          command: 'yarn test'<br>      - run:<br>          name: Deploy to AWS Elastic Beanstalk<br>          command: 'eb init MyApp -r eu-west-2 -p arn:aws:elasticbeanstalk:eu-west-2::platform/Node.js running on<br>                    64bit Amazon Linux/4.4.3'<br>      - run:<br>          name: Deploy to AWS Elastic Beanstalk<br>          command: 'eb deploy your-env'</pre> <p>First up we install Java as DynamoDB requires Java to run. The next part is optional, but as my app deploys to Elastic Beanstalk, I download Python as AWS EB CLI requires Python to run. Lastly we install DynamoDB directly from Amazon, I’ve chosen <strong>eu-west-2, </strong>but choose whichever location is nearest to you. This downloads as a zip, so we unzip it and then run the <strong>.jar </strong>file. The important thing here is to note the use of the option <strong>background: true. </strong>This ensures it runs in the background and doesn’t stall your build from going onto the next stage. From here, you can launch your server as a background task, load your data in and run your tests.</p> <p>Hope you this helped anyone having trouble incorporating DynamoDB into their build pipelines. If you’re stuck, or have any questions, please ask!</p> <p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"></figure><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6db3c82f2f6a" width="1" height="1"> </div> </div> <p style="text-align: center"><a class="waves-effect waves-light btn green darken-2" target="_blank" href="https://medium.com/@jameshamann/"><i class="material-icons right">library_books</i>Read more at Medium</a></p> <script type="text/javascript" src="/assets/js/jquery-3.2.1.min.js"></script> <script type="text/javascript" src="/assets/js/materialize.min.js"></script> <script src="/assets/js/init.js"></script> </body> <footer class="page-footer"> <div class="footer-copyright" style="padding-left: 30px"> <i class="material-icons" style="padding-right:5px">copyright</i><p>2017 Copyright James Hamann | All rights reserved</p> </div> </footer> </html>