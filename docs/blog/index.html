<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" type="text/css" href="/assets/css/materialize.css"> <link rel="stylesheet" href="https://cdn.rawgit.com/konpa/devicon/df6431e323547add1b4cf45992913f15286456d3/devicon.min.css"> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> <title>James Hamann</title> <script type="text/javascript">screen.width<=699&&(document.location="mobile.html");</script> </head> <body> <h2 style="text-align:center"> Latest Blog Posts </h2> <p style="text-align:center;"><a class="waves-effect waves-light btn green darken-2" target="_blank" href="https://medium.com/@jameshamann/"><i class="material-icons right">library_books</i>Read more at Medium</a></p> <div class="fixed-action-btn horizontal"> <a class="btn-floating btn-large waves-effect waves-default pulse" href="/"> <i class="material-icons">arrow_back</i> </a> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Architecting your IoT App using Raspberry Pi and AWS</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dzxCfHB9TOC2o8DGXVf3qA.png"/></figure><p>Having done a lot of work with IoT sensors and Raspberry Pi recently, and considering itâ€™s growing popularity, I thought Iâ€™d share how I went about architecting the infrastructure of the application, which can be applied to pretty much any IoT app you may be working on. Whilst the principals will apply to all major cloud hosting providers, Iâ€™ll be discussing AWS specific services.</p><h4>Project Outline</h4><p>A Smart Watering System for Farms/Plants, driven by data obtained from IoT Sensors and Forecasting APIs.</p><h4>Hardware Used</h4><ul><li>Raspberry Pi 3 Model B and SD Card loaded withÂ Raspbian</li><li>Female to Female DupontÂ Wires</li><li>DHT11 Temp/Humidity Sensor</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*SEIzFKM352ssKoN1NkG5_w.jpeg"/></figure><p>The above is obviously still in the prototyping phase, which hopefully explains the mess. The end product will be cased in a watertight enclosure. In addition to the Temperature Sensor, the above picture also contains a Photo Resistor which captures information about light levels, but is currently not beingÂ used.</p><h4>Architecture Diagram</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/720/1*wFQ0HOSHDiyTTdkjhhu0Xw.png"/></figure><p>This diagram illustrates all of the components used and how they interact with each other. Letâ€™s break it down a little further and understand whatâ€™s happening.</p><p>First the Pi IoT sensors publish raw data about the temperature, humidity, soil moisture and hours of sunlight. This is sent to an IoT topic via an MQTT message. This is a super light weight pub/sub messaging protocol designed specifically for devices in locations with limited network bandwidth, which is great for IoT. Next, an AWS IoT rule and action is created, which subscribes to the topic that the sensors are publishing to and sends these messages to a Kinesis data stream and DynamoDBÂ Table.</p><p>Using Kinesis is entirely optional and dependant on what youâ€™re building. The benefit of Kinesis is that it allows you the option of creating multiple delivery streams for your data. You could have one stream that delivers to a Lambda Function for record transformation, which writes to DynamoDB, or another stream for a Kinesisâ€™ Analytics Application, even a delivery stream for an ElasticSearch app. It gives you the flexibility of being able to stream the data to multiple destinations for multiple uses. On the other hand, it can over complicate the app and be a bit of overkill in some cases, but itâ€™s worth considering and making a final decision based on your appâ€™s requirements. In this example the Kinesis Delivery Stream writes to an S3 Bucket, as anÂ archive.</p><p>Once in DynamoDB, the application looks similar to a typical serverless application. The back-end logic is handled by Lambda and API Gateway and then sent to the client/Raspberry Pi. The React Front End is stored in an S3 bucket and distributed via CloudFront to the client. The client will display the sensor data as well as having the ability to control the water flow manually.</p><p>To automate the watering, the data from the sensors will be evaluated alongside data from Forecasting APIs and, based on certain criteria, the app will decide whether the area needs water and, if so, it would calculate the amount required based on all the data available. In the event watering is required a message will be published from Lambda to the Raspberry Pi on another topic, containing the â€œOpen Valveâ€ message as well as the amount of time to keep the valveÂ open.</p><p>To add a level of interactivity, a chatbot could be included which would prompt the user the current status and give the user the option to interact back, querying past events. In addition to this, data visualisation tools could be used to create dashboards, historical data could even be loaded into a Machine Learning Model to predict the likelihood of watering and the optimum amount of water. There are lots of applications and ways in which you can expand a small project into something more, to gain experience using new tools and technologies.</p><p>Whilst this model explains the infrastructure in the context of this project, it is easily applied to any other IoT app you may have in mind. Connecting a Raspberry Pi to the cloud allows it to do so much more and gives you the opportunity to build new, different apps and explore different technologies.</p><p>In another post weâ€™ll look at the specifics of setting this up within the AWS Environment and getting a Raspberry Pi Connected on the IoTÂ Console.</p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b8b89e3ac39a" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi Gerald Carter, sorry for the delay in getting back to you.</b></h4> <p style="text-align:justify"><p>Hi <a href="https://medium.com/u/36a1ef21a16f">Gerald Carter</a>, sorry for the delay in getting back to you. Looking at the error you mentioned above, it might be down to the command you used in your pipelines script or the name of your app/environment onÂ AWS.</p><p>Using my example above, my elastic beanstalk app was called <strong>MyApplication </strong>and the environment I used was <strong>MyApplication-staging.</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/25d8f89a2b52e2311772f9f1df132cb5/href">https://medium.com/media/25d8f89a2b52e2311772f9f1df132cb5/href</a></iframe><p>On line 17 I mention the name of the Application, <strong>MyApplication</strong>.</p><p>On line 18, I mention the environment I wish to deploy my app to, <strong>MyApplicaton-staging.</strong></p><p>Both of these need to be setup before pushing. Double check what you called your app/environment in AWS and make sure this matches the buildÂ script.</p><p>Hope thisÂ helps!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=17eb9e04aef4" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify â€” Part Two</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*e-avRWEkg9mFn5BuWm4X4w.jpeg"/></figure><p>Following on from my previous post, <a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a">Serverless React Web App with AWS Amplifyâ€Šâ€”â€ŠPart One</a>, today weâ€™ll layout the Front End and implement our basic CRUD Functions.</p><p><strong>All source code for the project can be foundÂ </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><h4>Front End</h4><p>To bootstrap the front end, weâ€™ll use <a href="https://react.semantic-ui.com/introduction">React Semantic UI</a>, a simple UI Framework that provides a great set of React Components.</p><pre><strong>#bash</strong></pre><pre>$ yarn add semantic-ui-react<br>[...]<br>$ yarn add semantic-ui-css</pre><p>To get the CSS styling, youâ€™ll need to import it in your <strong>index.js </strong>file, likeÂ so.</p><pre><strong># index.js</strong></pre><pre>import React from &#39;react&#39;;<br>import ReactDOM from &#39;react-dom&#39;;<br>import &#39;./index.css&#39;;<br>import App from &#39;./App&#39;;<br><strong>import &#39;semantic-ui-css/semantic.css&#39;<br></strong>import registerServiceWorker from &#39;./registerServiceWorker&#39;;</pre><pre>ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));<br>registerServiceWorker();</pre><p>Now letâ€™s setup the folder structure. I like to keep screens in one folder and re-useable components in another. With that it mind, letâ€™s make two new directories within the <strong>src </strong>directory.</p><pre>#<strong>bash</strong></pre><pre>$ mkdir src/components<br>$ mkdir src/screens</pre><pre># <strong>Project Layout</strong></pre><pre>â”œâ”€â”€ README.md<br>â”œâ”€â”€ awsmobilejs<br>â”‚   â”œâ”€â”€ #current-backend-info<br>â”‚   â”‚   â”œâ”€â”€ aws-exports.js<br>â”‚   â”‚   â”œâ”€â”€ backend-details.json<br>â”‚   â”‚   â”œâ”€â”€ cloud-api<br>â”‚   â”‚   â”‚   â””â”€â”€ sampleLambda<br>â”‚   â”‚   â”‚       â”œâ”€â”€ app.js<br>â”‚   â”‚   â”‚       â”œâ”€â”€ lambda.js<br>â”‚   â”‚   â”‚       â”œâ”€â”€ package-lock.json<br>â”‚   â”‚   â”‚       â””â”€â”€ package.json<br>â”‚   â”‚   â””â”€â”€ mobile-hub-project.yml<br>â”‚   â””â”€â”€ backend<br>â”‚       â”œâ”€â”€ cloud-api<br>â”‚       â”‚   â””â”€â”€ sampleLambda<br>â”‚       â”‚       â”œâ”€â”€ app.js<br>â”‚       â”‚       â”œâ”€â”€ lambda.js<br>â”‚       â”‚       â”œâ”€â”€ package-lock.json<br>â”‚       â”‚       â””â”€â”€ package.json<br>â”‚       â””â”€â”€ mobile-hub-project.yml<br>â”œâ”€â”€ package.json<br>â”œâ”€â”€ public<br>â”‚   â”œâ”€â”€ favicon.ico<br>â”‚   â”œâ”€â”€ index.html<br>â”‚   â””â”€â”€ manifest.json<br>â”œâ”€â”€ src<br>â”‚   â”œâ”€â”€ App.css<br>â”‚   â”œâ”€â”€ App.js<br>â”‚   â”œâ”€â”€ App.test.js<br>â”‚   â”œâ”€â”€ aws-exports.js<br>â”‚   â”œâ”€â”€ components<br>â”‚   â”œâ”€â”€ index.css<br>â”‚   â”œâ”€â”€ index.js<br>â”‚   â”œâ”€â”€ logo.svg<br>â”‚   â”œâ”€â”€ registerServiceWorker.js<br>â”‚   â””â”€â”€ screens<br>â””â”€â”€ yarn.lock</pre><p>Weâ€™ll obviously need a few different views here, one to display all our items, one to create our items, one to edit/delete our items and one which shows a little more information about the item. Weâ€™ll use our <strong>App.js </strong>as the dashboard/index view for our app and add a navbar to navigate around theÂ app.</p><pre><strong># App.js</strong></pre><pre>[...]</pre><pre>render() {<br>    return (<br>      &lt;Segment&gt;<br>        &lt;Menu&gt;<br>           &lt;Menu.Item name=&#39;home&#39;&gt; &lt;Icon name=&quot;shop&quot;/&gt;&lt;/Menu.Item&gt;<br>           &lt;Menu.Item name=&#39;Items&#39;/&gt;<br>           &lt;Menu.Item name=&#39;aboutUs&#39; /&gt;<br>         &lt;/Menu&gt;<br>      &lt;/Segment&gt;<br>    );<br>  }<br>}</pre><p>Now, letâ€™s create an <strong>ItemDashboard</strong> page that shows all of ourÂ Itemâ€™s.</p><pre><strong>#bash</strong></pre><pre>touch src/screens/itemDashboard.js</pre><pre>--------------------------------------------------------------------</pre><pre>#<strong>itemDashboard.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import {Container, Card} from &#39;semantic-ui-react&#39;</pre><pre>class ItemDashboard extends Component {</pre><pre>render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;Container style={{padding: 10}}&gt;<br>          &lt;Card.Group&gt;<br>              &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    Item Name<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Item Price<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                  Description of the Item<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default ItemDashboard;</pre><p>Now weâ€™ll import this into our <strong>App.js </strong>and render it within our <strong>&lt;Segment&gt;</strong> section.</p><pre># <strong>App.js</strong></pre><pre>[...]<br>  <br>render() {<br>    return (<br>      &lt;Segment&gt;<br>        &lt;Menu&gt;<br>           &lt;Menu.Item name=&#39;home&#39;&gt; &lt;Icon name=&quot;shop&quot;/&gt;&lt;/Menu.Item&gt;<br>           &lt;Menu.Item name=&#39;Items&#39;/&gt;<br>           &lt;Menu.Item name=&#39;aboutUs&#39; /&gt;<br>         &lt;/Menu&gt;<br><strong>         &lt;ItemDashboard /&gt;<br></strong>      &lt;/Segment&gt;<br>    );<br>  }<br>}</pre><p>At the moment our app should look nice and basic, something likeÂ this.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BxDPNJ33L4G073eyYITptg.png"/><figcaption>Basic Item Dashboard</figcaption></figure><p>Next, letâ€™s implement a modal, which will serve as our createÂ page.</p><p>Weâ€™ll use Semantic UIâ€™s Modal and Form components to create the basic outline of our page. Letâ€™s create a new file <strong>createItem.js </strong>which will live in our <strong>screens </strong>directory.</p><pre>#bash</pre><pre>$ touch src/screens/createItem.js</pre><pre>--------------------------------------------------------------------</pre><pre>#<strong>createItem.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import { Form, Modal, Button, Container } from &#39;semantic-ui-react&#39;</pre><pre>class CreateItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.state = {}<br>    this.handleChange = this.handleChange.bind(this);<br>  }</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre>handleSubmit(event) {</pre><pre>}</pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>    return (<br>        &lt;Modal trigger={&lt;Button onClick={this.handleOpen}&gt;+ Add Item&lt;/Button&gt;} closeIcon={true} open={this.state.modalOpen} onClose={this.handleClose}&gt;<br>          &lt;Modal.Header&gt;Add an Item&lt;/Modal.Header&gt;<br>          &lt;Modal.Content&gt;<br>            &lt;Form&gt;<br>              &lt;Form.Group unstackable widths={2}&gt;<br>                &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Enter Item Name...&#39; onChange={this.handleChange} /&gt;<br>                &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Enter Item Price...&#39; onChange={this.handleChange} type=&#39;number&#39; /&gt;<br>              &lt;/Form.Group&gt;<br>              &lt;Form.TextArea name=&#39;item_description&#39; label=&#39;Item Description&#39; placeholder=&#39;Add a Description of the Item...&#39; onChange={this.handleChange} /&gt;</pre><pre>&lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>            &lt;/Form&gt;<br>          &lt;/Modal.Content&gt;<br>        &lt;/Modal&gt;<br>      );<br>    }<br>  }</pre><pre>export default CreateItemModal;</pre><p>Most of the above code is recycled from examples on Semanticâ€™s website. Studying the code, youâ€™ll notice Iâ€™ve also added two functions that <strong>handleChange </strong>and <strong>handleSubmit </strong>within our form. This ensures all data is captured and submitted correctly, weâ€™ll revisit both of these later when we connect everything together.</p><p>One thing I should mention, that I encountered during my own development, is a funky bug with the modal where half of it would be cut, off screen. The issue is tracked <a href="https://github.com/Semantic-Org/Semantic-UI-React/issues/2558">here</a> and the solution below worked perfectly, for me. Please do let me know if you run into any funky issues around the modal that arenâ€™t resolved with theÂ below.</p><p><strong>Proposed Workaround for ModalÂ Issue:</strong></p><pre>#<strong>App.css</strong></pre><pre>.ui.page.modals.transition.visible {<br>    display: flex !important;<br>}</pre><pre># suggested by loopmode on GitHub Issues thread.</pre><p>Make sure to import and add the component in our <strong>ItemDashboard</strong>.</p><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>[...]</pre><pre>render() {<br>    return (<br>      &lt;div&gt;<br>       &lt;CreateItemModal/&gt;        <br>        &lt;Container style={{padding: 10}}&gt;<br>          &lt;Card.Group&gt;<br>              &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    Item Name<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Item Price<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                  Description of the Item<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );</pre><pre>[...]</pre><p>The finished <strong>createItemModal</strong> should look something like theÂ below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3bkmnkqVbDb7PsbZ3gkqSg.png"/></figure><p>Looking good! Now letâ€™s hook everything up so that we can actually create items that display on our Dashboard.</p><h4>Create</h4><p>Now that we have a form weâ€™ll need to populate the function <strong>handleSubmit </strong>we wrote inÂ earlier.</p><p>Similar to our get request previously, weâ€™ll have to set the <strong>apiName</strong>, <strong>path,</strong> and this time, the body of what weâ€™re sending. Weâ€™ll then use Amplifyâ€™s <strong>API </strong>component to post and log the contents to theÂ console.</p><pre><strong>#createItem.js</strong></pre><pre><strong>import Amplify, { API } from &#39;aws-amplify&#39;;</strong></pre><pre>class CreateItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.state = {}<br>    this.handleChange = this.handleChange.bind(this);<br><strong>    this.handleSubmit = this.handleSubmit.bind(this);</strong></pre><pre>}</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre><strong>handleSubmit(event) {<br>    let apiName = &#39;sampleCloudApi&#39;;<br>    let path = &#39;/items&#39;;<br>    let newItem = {<br>      body: {<br>          name: this.state.itemName, price: this.state.itemPrice, description: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>    this.handleClose()<br>  }</strong></pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>    return (<br>        &lt;Modal trigger={&lt;Button onClick={this.handleOpen}&gt;+ Add Item&lt;/Button&gt;} closeIcon={true} open={this.state.modalOpen} onClose={this.handleClose}&gt;<br>          &lt;Modal.Header&gt;Add an Item&lt;/Modal.Header&gt;<br>          &lt;Modal.Content&gt;<br>            &lt;Form <strong>onSubmit={this.handleSubmit}</strong>&gt;<br>              &lt;Form.Group unstackable widths={2}&gt;<br>                &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Enter Item Name...&#39; onChange={this.handleChange}  <strong>value={this.state.itemName} </strong>/&gt;<br>                &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Â£0.00&#39; onChange={this.handleChange}  <strong>value={this.state.itemPrice} </strong>/&gt;<br>              &lt;/Form.Group&gt;<br>             &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item    Description&#39; placeholder=&#39;Add a Description of the Item...&#39; onChange={this.handleChange}  <strong>value={this.state.itemDescription}</strong> /&gt;</pre><pre>&lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>            &lt;/Form&gt;<br>          &lt;/Modal.Content&gt;<br>        &lt;/Modal&gt;<br>      );<br>    }<br>  }</pre><pre>export default CreateItemModal;</pre><p>The <strong>handleSubmit </strong>function declares the variables necessary for posting to our backend. The body is formed of the values we set in each form element: <strong>itemName, itemPrice </strong>and <strong>itemDescription. </strong>The last thing we need to do is bind our function to our component so that it doesnâ€™t show up undefined when we call our function.</p><p>Now letâ€™s give the form a quick test to see if everythingâ€™s working.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/844/1*NEmUzgh6sEsxzqJoIeu_1A.png"/></figure><p>After submitting the form, with some content obviously, you should see the contents in the console, likeÂ above.</p><p>Great! However, this isnâ€™t saving anywhere, we still need to configure our Database.</p><h4>DynamoDB Setup</h4><p>Earlier on we setup a Database with the default example setup, weâ€™re going to remove this and configure the database from scratch. DynamoDB requires us to specify a Primary Key, which determines how items within our Table are uniquely organised. Thereâ€™s a lot of different schools of thought on whatâ€™s best to do here, which are way out of scope of this post. To keep things simple Iâ€™ll create a <strong>UUID, </strong>which will be generated when a user submits a new Item using theÂ form.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile database configure</pre><pre>? Select from one of the choices below. Remove table from the project<br>? Select table to be deleted AWSMobileTable<br>? Are you sure you want to delete the table Yes</pre><pre>$ awsmobile database configure</pre><pre>Welcome to NoSQL database wizard<br>You will be asked a series of questions to help determine how to best construct your NoSQL database table.</pre><pre>? Should the data of this table be open or restricted by user? Open<br>? Table name ServerlessReactExample</pre><pre>You can now add columns to the table.</pre><pre>? What would you like to name this column ID<br>? Choose the data type string<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemName<br>? Choose the data type string<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemPrice<br>? Choose the data type number<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemDescription<br>? Choose the data type string<br>? Would you like to add another column No</pre><pre>Before you create the database, you must specify how items in your table are uniquely organized. This is done by specifying a Primary key. The primary key uniquely identifies each item in the table, so that no two items can have the same key.<br>This could be and individual column or a combination that has &quot;primary key&quot; and a &quot;sort key&quot;.<br>To learn more about primary key:<br><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey</a></pre><pre>? Select primary key ID<br>? Select sort key (No Sort Key)</pre><pre>You can optionally add global secondary indexes for this table. These are useful when running queries defined by a different column than the primary key.<br>To learn more about indexes:<br><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes</a></pre><pre>? Add index No</pre><pre>$ awsmobile push<br>[...]<br>contents in #current-backend-info/ is synchronized with the latest in the aws cloud</pre><p>Again, to keep things simple Iâ€™ve not added a sort key or an index, just the Primary key which is require for setting up theÂ db.</p><p>Letâ€™s quickly tweak our <strong>handleSubmit </strong>function to generate a uuid whenever we submit. In order to achieve this weâ€™ll use <a href="https://github.com/kelektiv/node-uuid"><strong>node-uuid</strong></a><strong>. </strong>Thereâ€™s a few different versions you can generate, but weâ€™ll use the <strong>uuidv1, </strong>which creates a timestamp uuid. This can be converted and tested on a site likeÂ <a href="https://www.famkruithof.net/uuid/uuidgen">this</a>.</p><pre>#bash </pre><pre>$ yarn add node-uuid</pre><pre>------------------------------------------------------------------</pre><pre><strong>#createItem.js</strong></pre><pre><strong>const uuidv1 = require(&#39;uuid/v1&#39;);</strong></pre><pre>[...]<br>handleSubmit(event) {<br>    console.log(this);<br>    let apiName = &#39;sampleCloudApi&#39;;<br>    let path = &#39;/items&#39;;<br>    let newItem = {<br>      body: {<br>          <strong>ID: uuidv1()</strong>, name: this.state.itemName, price: this.state.itemPrice, description: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>    this.handleClose()<br>  }<br>[...]</pre><p>Lastly, we need to configure our <strong>cloud-api </strong>to use our newly created database.</p><pre>#bash</pre><pre>awsmobile cloud-api configure</pre><pre>This feature will create an API using Amazon API Gateway and AWS Lambda. You can optionally have the lambda function perform CRUD operations against your Amazon DynamoDB table.</pre><pre>? Select from one of the choices below. Create CRUD API for an existing Amazon DynamoDB table<br>? Select Amazon DynamoDB table to connect to a CRUD API ServerlessReactExample<br>Adding lambda function code on:<br>/Users/jameshamann/Documents/Development/serverless-web-app-example/awsmobilejs/backend/cloud-api/rverlessReactExample/<br>...<br>Path to be used on API for get and remove an object should be like:<br>/ServerlessReactExample/object/:ID</pre><pre>Path to be used on API for list objects on get method should be like:<br>/ServerlessReactExample/:ID</pre><pre>JSON to be used as data on put request should be like:<br>{<br>  &quot;ID&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemDescription&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemName&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemPrice&quot;: &quot;INSERT VALUE HERE&quot;<br>}<br>To test the api from the command line (after awsmobile push) use this commands<br>awsmobile cloud-api invoke ServerlessReactExampleCRUD &lt;method&gt; &lt;path&gt; [init]</pre><pre>$ awsmobile push</pre><p>This does change the name of your <strong>API, </strong>youâ€™ll notice mine is now called <strong>ServerlessReactExampleCRUD,</strong> with a <strong>path </strong>of <strong>/ServerlessReactExample. </strong>So in order to get things to work,<strong> </strong>youâ€™ll need to update the <strong>apiName and path </strong>in your code to reflectÂ this.</p><p>Now letâ€™s create a new item in our form and hit Submit. We still donâ€™t see anything, but if we head over to the <a href="https://aws.amazon.com/dynamodb">AWS DynamoDB Console</a>, weâ€™ll see our item has been successfully saved in our database!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xZ2kgys68NggdswMMe_yQA.png"/></figure><h4>Read</h4><p>Now that we can successfully Create items, letâ€™s work on Reading them in our dashboard. Instead of reading one Item at a time, Iâ€™m going to fetch all Items in our database and display them on our itemDashboard. To do this, weâ€™ll need to slightly alter our Lambda code to include a function that returns all items from our DynamoDBÂ Table.</p><p>DynamoDB provides us with aÂ <strong>.scan </strong>method, which returns all items, similar to a <em>SELECT * from tablename</em> in SQL. Letâ€™s start off by editing our <strong>app.js </strong>within our <strong>backend </strong>folder and include a route that retrieves allÂ data.</p><pre>#<strong>awsmobilejs/backend/yourLambdaFunctionName/app.js</strong></pre><pre>[...]</pre><pre>app.get(&#39;/ServerlessReactExample&#39;, function(req, res) {</pre><pre>var params = {<br>    TableName: tableName,<br>    Select: &#39;ALL_ATTRIBUTES&#39;,<br>};</pre><pre>dynamodb.scan(params, (err, data) =&gt; {<br>       if (err) {<br>         res.json({error: &#39;Could not load items: &#39; + err.message});<br>       }</pre><pre>res.json({<br>           data: data.Items.map(item =&gt; {<br>             return item;<br>           })<br>       });<br>   });<br>});</pre><pre>[...]</pre><pre>-------------------------------------------------------------------</pre><pre>#bash</pre><pre>$ awsmobile push<br>[...]</pre><p>Be sure to add the function just above the other routes and to push your changes to the awsÂ cloud.</p><p>Once everything has been pushed and updated, reload your app and, if everythingâ€™s setup correctly, you should see all items from the database.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/848/1*mOAAlE3_bDNddPPw-4C01g.png"/><figcaption>After refreshing</figcaption></figure><p>Letâ€™s update our itemDashboard so that it correctly displays the data fetched from the database. Weâ€™ll iterate through our JSON response and for each item, weâ€™ll display the <strong>name, price </strong>and <strong>description </strong>on a <strong>Card. </strong>Weâ€™ll require another library, <strong>lodash</strong>, which basically makes working with objects a lotÂ easier.</p><pre>#bash </pre><pre>$ yarn add loadash</pre><pre>-------------------------------------------------------------------</pre><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import {Container, Card} from &#39;semantic-ui-react&#39;<br><strong>import Amplify, { API } from &#39;aws-amplify&#39;;<br>import _ from &#39;lodash&#39;;</strong></pre><pre>let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>let path = &#39;/ServerlessReactExample&#39;;</pre><pre>class ItemDashboard extends Component {</pre><pre><strong>constructor(props){<br>    super(props)<br>    this.state = {itemData: {}}<br>  }</strong></pre><pre><strong>getItems(){<br>    API.get(apiName, path).then(response =&gt; {<br>      console.log(response)<br>      this.setState({<br>       itemData: response.data<br>      });<br>    });<br>  }</strong></pre><pre>componentDidMount(){<br>    <strong>this.getItems()<br></strong>  }</pre><pre>render() {<br><strong>    const itemData = this.state.itemData;<br></strong>    <strong>return (<br>      &lt;div&gt;</strong></pre><pre>&lt;CreateItemModal/&gt;<strong>        <br>&lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Â£ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</strong></pre><pre>export default ItemDashboard;</pre><p>We move our GET request into itâ€™s own function, <strong>getItems() </strong>and call it during the <strong>componentDidMount </strong>function. Then, in our <strong>render </strong>function, we set <strong>itemData </strong>equal to <strong>this.state.itemData, </strong>which is set during our <strong>getItems() function. </strong>In the UI, we _<strong>.map </strong>over our <strong>itemData </strong>and for each Item we return a Card with the <strong>ItemName</strong>, <strong>ItemPrice </strong>and <strong>ItemDescription</strong>. After reloading your app, the result should look something like theÂ below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dSNJl7GoDS8FYqbMxKn5WQ.png"/></figure><p>Before moving on, youâ€™ll notice in order to see your results after a form submission youâ€™ll need to refresh. Letâ€™s fix that with a callback and set the state of <strong>this.state.itemData </strong>to get updated when we submit ourÂ form.</p><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>[...]</pre><pre>render() {<br>    const itemData = this.state.itemData;<br>    return (<br>      &lt;div&gt;</pre><pre><strong>&lt;CreateItemModal getItems={this.getItems}/&gt;<br></strong>&lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Â£ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>[...]</pre><pre>-------------------------------------------------------------------<br>#<strong>src/screens/createItem.js</strong></pre><pre>[...]</pre><pre>handleSubmit(event) {<br>    console.log(this);<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &#39;/ServerlessReactExample&#39;;<br>    let newItem = {<br>      body: {<br>          &quot;ID&quot;: uuidv1(),<br>          &quot;ItemName&quot;: this.state.itemName,<br>          &quot;ItemPrice&quot;: this.state.itemPrice,<br>          &quot;ItemDescription&quot;: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>   <strong> this.props.getItems()</strong><br>    this.handleClose()<br>  }</pre><pre>[...]</pre><p>We pass the function down from <strong>ItemDashboard </strong>to <strong>createItem</strong>.</p><h4>Update</h4><p>Next, weâ€™ll look at Updating our Items, if we want to change the price, forÂ example.</p><p>Letâ€™s create another modal, exactly the same as our <strong>createItem.js, </strong>but letâ€™s call it <strong>editItem.js. </strong>Alot of the contents will be similar as itâ€™s essentially the same form, just for editing anÂ item.</p><pre><strong>#src/screens/editItem.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import { Form, Modal, Button, Container, Icon } from &#39;semantic-ui-react&#39;<br>import Amplify, { API } from &#39;aws-amplify&#39;;<br>const uuidv1 = require(&#39;uuid/v1&#39;);</pre><pre>class EditItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br><strong>    this.state = { item: this.props.item };<br></strong>  }</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre>handleSubmit(event) {<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &#39;/ServerlessReactExample&#39;;<br><strong>    let editItem = {<br></strong>      body: {<br><strong>          &quot;ID&quot;: this.props.item[0].ID,<br></strong>          &quot;ItemName&quot;: this.state.itemName,<br>          &quot;ItemPrice&quot;: this.state.itemPrice,<br>          &quot;ItemDescription&quot;: this.state.itemDescription<br>        }<br>      }<br>    API.put(apiName, path, editItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });</pre><pre>    this.props.getItems()<br>    this.handleClose()<br>    event.preventDefault();<br>  }</pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>      <strong>return (<br>        &lt;Container style={{padding: 10}}&gt;<br>            &lt;Modal trigger={&lt;Button icon onClick={this.handleOpen}&gt;&lt;Icon name=&#39;edit&#39; /&gt;&lt;/Button&gt;}open={this.state.modalOpen}  closeIcon </strong> <strong>onClose={this.handleClose}&gt;<br>              &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;<br>              &lt;Modal.Content&gt;<br>                &lt;Form onSubmit={this.handleSubmit}&gt;<br>                &lt;Form.Group unstackable widths={2}&gt;<br>                  &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Edit Item Name...&#39; onChange={this.handleChange}  value={this.state.itemName} /&gt;<br>                  &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Â£0.00&#39; onChange={this.handleChange}  value={this.state.itemPrice} /&gt;<br>                &lt;/Form.Group&gt;<br>                &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item Description&#39; placeholder=&#39;Edit Description of the Item...&#39; onChange={this.handleChange}  value={this.state.itemDescription} /&gt;<br>                  &lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>                &lt;/Form&gt;<br>            &lt;/Modal.Content&gt;<br>          &lt;/Modal&gt;<br>       &lt;/Container&gt;</strong><br>      );<br>    }<br>  }</pre><pre>export default EditItemModal;</pre><p>Essentially this is the same code as whatâ€™s in <strong>createItem.js, </strong>the only difference is weâ€™re receiving props weâ€™ve sent from our parent component <strong>itemDashboard.js, </strong>in order to retrieve the itemâ€™s ID. This is important, as we require the ID in order to make sure weâ€™re updating the correct item in our database.</p><p>To send the Item to our <strong>EditItemModalÂ </strong>, we need to create a function that fetches the item. Weâ€™ll do this in our <strong>ItemDashboard</strong> and send the response to our <strong>EditItemModal </strong>throughÂ props.</p><pre><strong>#src/screens/ItemDashboard.js<br>[...]</strong></pre><pre><strong>import EditItemModal from &#39;./editItem.js&#39;</strong></pre><pre>[...]</pre><pre><strong>getItem(id){<br>  let single_path = &#39;/ServerlessReactExample/&#39; + id<br>  console.log(single_path)<br>  API.get(apiName, single_path).then(response =&gt; {<br>    console.log(response)<br>    this.setState({<br>      item: response<br>    })<br>  });<br>}</strong></pre><pre>[...]</pre><pre>return (<br>      &lt;div&gt;<br>        &lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            <strong>&lt;Card onClick={() =&gt; this.getItem(ID)}&gt;</strong><br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Â£ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br><strong>              &lt;EditItemModal item={Object.values(this.state.item) getItems={(this.getItems)} /&gt;<br></strong>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );</pre><p>Donâ€™t forget to import the <strong>EditItemModal, </strong>as weâ€™ll be rendering this within our dashboard on each card. Our function, <strong>getItem, </strong>takes an ID as itâ€™s argument, the ID is then appended to the path used within our GET request, which returns all information on the requested Item. We then set the state of <strong>item </strong>equal to the response of our call and send that data through to our <strong>EditItemModal.</strong></p><p>Once Complete, you should have a dashboard similar to this, with the ability to edit the item youâ€™ve clickedÂ on.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DRRHjfv4wJGjOo7bnTDN1w.png"/></figure><p>Awesome! Lastly, letâ€™s quickly implement our last CRUD function, delete.</p><h4>Delete</h4><p>Implementing a delete function is fairly quick, as most of the work is already done. Weâ€™ll add the delete function to our <strong>EditItemModal</strong>, as itâ€™s probably the best place forÂ it.</p><pre>#<strong>src/screens/editItem.js</strong></pre><pre>[...]</pre><pre>constructor(props) {<br>    super(props)<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br><strong>    this.deleteItem = this.deleteItem.bind(this);</strong></pre><pre>this.state = { item: this.props.item };<br>  }</pre><pre><strong>deleteItem(){<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &quot;/ServerlessReactExample/object/&quot; + this.props.item[0].ID<br>    API.del(apiName, path).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    this.props.getItems()</strong></pre><pre><strong>    this.handleClose()<br>  }</strong></pre><pre><strong>[...]</strong></pre><p>Very simply, our function makes a delete request, using <strong>API </strong>component, with the ID appended to the path. The ID is required so the function knowâ€™s which Item to delete from our database. Donâ€™t forget to bind our function to <strong>this</strong>, otherwise weâ€™ll get undefined errors when trying to retrieve ourÂ <strong>ID.</strong></p><p>Lastly, letâ€™s render a Delete button on our Modal and link it all together.</p><pre>#<strong>src/screens/editItem.js</strong></pre><pre>return (<br>        &lt;Container style={{padding: 10}}&gt;<br>            &lt;Modal trigger={&lt;Button icon onClick={this.handleOpen}&gt;&lt;Icon name=&#39;edit&#39; /&gt;&lt;/Button&gt;} open={this.state.modalOpen} closeIcon onClose={this.handleClose}&gt;<br>              &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;<br>              &lt;Modal.Content&gt;<br>                &lt;Form onSubmit={this.handleSubmit}&gt;<br>                &lt;Form.Group unstackable widths={2}&gt;<br>                  &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Edit Item Name...&#39; onChange={this.handleChange}  value={this.state.itemName} /&gt;<br>                  &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Â£0.00&#39; onChange={this.handleChange}  value={this.state.itemPrice} /&gt;<br>                &lt;/Form.Group&gt;<br>                &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item Description&#39; placeholder=&#39;Edit Description of the Item...&#39; onChange={this.handleChange}  value={this.state.itemDescription} /&gt;<br>                  &lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>                &lt;/Form&gt;<br>            &lt;/Modal.Content&gt;<br>           <strong> &lt;Modal.Actions&gt;<br>              &lt;Button icon labelPosition=&#39;left&#39; onClick={this.deleteItem}&gt;<br>              &lt;Icon name=&#39;delete&#39; /&gt;<br>                Delete Item<br>              &lt;/Button&gt;<br>            &lt;/Modal.Actions&gt;</strong><br>          &lt;/Modal&gt;<br>       &lt;/Container&gt;</pre><p>Once completed, your <strong>EditItemModal</strong> should look like this. When clicking delete, and after a refresh, youâ€™ll notice the item has beenÂ removed.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-G3bneervjaVbEsLngqtRA.png"/></figure><p>This has been quite a long post, so well done if youâ€™ve made it this far! You now have a, real basic, Serverless React Web App! There are still a lot of things that need to be cleaned up and refactored, like perhaps adding the Item Title to the <strong>EditItemModal</strong>, so we know what weâ€™re editing and adding maybe adding some validation to our forms? Thereâ€™s a lot of scope for improvement and enhancement here, but this gives you a solid foundation to moveÂ forward.</p><p>The next, and final, part on this mini series will be focused around Adding Authentication, with Amplify, as well as the Deployment and Distribution of your app throughÂ AWS.</p><p><strong>All source code for the project can be foundÂ </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d740ee8e7456" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify â€” Part One</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_0jTP7l27uwj2CPLpqnVdw.jpeg"/></figure><p>Having previously posted about <a href="https://medium.com/@jameshamann/accelerating-mobile-app-development-with-aws-amplify-fb2034e60160">Accelerating Mobile Development with AWS Amplify</a>, I thought Iâ€™d do the same for the Web, using <a href="https://github.com/aws/aws-amplify">AWS Amplify</a>, Amazonâ€™s new JavaScript Library for app development.</p><p><strong>All source code for the project can be foundÂ </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>Before diving in, itâ€™s probably worth understanding, at least at a high level, the architecture behind serverless apps and how theyÂ work.</p><h4>What is a Serverless Application?</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eIECK-X8x_9wfu9uShspHw.png"/><figcaption>High Level Serverless Application Model</figcaption></figure><p>This diagram represents, at a high level, the architecture of a serverless application. Our static content (React Web App) is stored in an S3 bucket served up to the client, either from CloudFront or directly. This communicates with API Gateway. From here this triggers a Lambda function (which handles all our back end logic) and communicates with DynamoDB to get, save, delete or whatever depending on what request was sent from theÂ client.</p><h4>What are the benefits?</h4><p>Cost. You only pay for the compute time you use. This works great if you have large fluctuations in traffic/requests. It also takes the hassle of maintaining a server away and some what simplifies things so you can focus on building your product. Obviously, every app has itâ€™s own requirements and serverless architecture may not fit in all cases, but for the most part it provides a good framework to deploy applications at low cost, with minimal configuration.</p><h4>What weâ€™ll beÂ building</h4><p>To keep things nice and simple, and to avoid the stale recycled todo example, weâ€™ll build an online inventory with basic CRUD functions. Iâ€™m sure it goes without saying but youâ€™d need an AWS Account, which you can get get <a href="https://aws.amazon.com/">here</a>. Iâ€™d also advise you to keep an eye on your billing statement so you donâ€™t incur any unexpected charges.</p><h4>Getting Started</h4><p>Firstly, weâ€™ll need to install the <strong>awsmobile-cli </strong>and configure it with our AWSÂ Keys.</p><pre><strong>#bash</strong></pre><pre>$ npm install -g awsmobile-cli<br>[...]<br><br>$ awsmobile configure<br>$ configure aws<br>? accessKeyId:  [ENTER YOUR ACCESS KEY ID] #hit enter<br>? secretAccessKey: [ENTER YOUR SECRET ACCESS KEY] #hit enter<br>? region:  eu-west-2 #select your region using arrows and hit enter</pre><p>Next, weâ€™ll use <a href="https://github.com/facebook/create-react-app">create-react-app</a> to scaffold up a React App forÂ us.</p><pre><strong>#bash </strong></pre><pre>$ create-react-app serverless-web-app-example<br>[...]<br>âœ¨  Done in 17.74s.</pre><pre>Success! Created serverless-web-app-example at /Users/jameshamann/Documents/Development/serverless-web-app-example<br>Inside that directory, you can run several commands:</pre><pre>yarn start<br>    Starts the development server.</pre><pre>yarn build<br>    Bundles the app into static files for production.</pre><pre>yarn test<br>    Starts the test runner.</pre><pre>yarn eject<br>    Removes this tool and copies build dependencies, configuration files<br>    and scripts into the app directory. If you do this, you canâ€™t go back!</pre><pre>We suggest that you begin by typing:</pre><pre>cd serverless-web-app-example<br>  yarn start</pre><pre>Happy hacking!<br>$ cd serverless-web-app-example</pre><p>Letâ€™s fire up our app to make sure itâ€™s all setup correctly.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kBjOFtIFilxIiY6WQMR0sA.png"/><figcaption>React StarterÂ Page</figcaption></figure><p>Great, looks good! Now lets install <strong>aws-amplify </strong>and <strong>aws-amplify-react</strong> (which just contains helpers and higher order components for react) within ourÂ project.</p><pre><strong>#bash</strong> </pre><pre>$ npm install aws-amplify --save <br>[...]<br>$ npm install aws-amplify-react --save<br>[...]</pre><p>Once this is all installed, weâ€™ll need to setup our backend. To initialise a project, we use the <strong>awsmobile init </strong>command within the root of our project. Youâ€™ll be prompted a few questions, usually the default answers provided are correct so you should be able to hit enter for each ofÂ them.</p><pre><strong>#bash </strong></pre><pre>$ awsmobile init<br>[...]</pre><pre>âœ¨  Done in 5.30s.<br>yarn add aws-amplify-react returned 0</pre><pre>Success! your project is now initialized with awsmobilejs</pre><pre>awsmobilejs/.awsmobile<br>     is the workspace of awsmobile-cli, please do not modify its contents</pre><pre>awsmobilejs/#current-backend-info<br>     contains information of the backend awsmobile project from the last<br>     synchronization with the cloud</pre><pre>awsmobilejs/backend<br>     is where you develop the codebase of the backend awsmobile project</pre><pre>awsmobile console<br>     opens the web console of the backend awsmobile project</pre><pre>awsmobile run<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and runs the frontend application locally</pre><pre>awsmobile publish<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and publishes the frontend application to aws S3 for hosting</pre><pre>Happy coding with awsmobile!</pre><p>This command creates all the necessary resources in AWS for your backend, as well as creating a <strong>awsmobilejs </strong>folder within the root of your project, which contains basic information about yourÂ project.</p><p>Lastly, weâ€™ll need to hook up our client (React app) to our newly created backend. In your appâ€™s entry point (usually App.js) include the bolded code in the snippet. This just imports the Amplify Library and configures it using a file called <strong>aws_exports </strong>which is generated when you initialise your backend, in the previousÂ step.</p><pre><strong># App.js </strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import logo from &#39;./logo.svg&#39;;<br>import &#39;./App.css&#39;;<br><strong>import Amplify from &#39;aws-amplify&#39;;<br>import aws_exports from &#39;./aws-exports&#39;;</strong></pre><pre><strong>Amplify.configure(aws_exports);</strong></pre><pre>class App extends Component {<br>  render() {<br>    return (<br>      &lt;div className=&quot;App&quot;&gt;<br>        &lt;header className=&quot;App-header&quot;&gt;<br>          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;<br>          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;<br>        &lt;/header&gt;<br>        &lt;p className=&quot;App-intro&quot;&gt;<br>          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br>        &lt;/p&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default App;</pre><h4>Lambda and APIÂ Setup</h4><p>Now weâ€™ve got the basic infrastructure setup, letâ€™s setup Lambda, API Gateway and DynamoDB for our basic CRUD functions. To do this, run the <strong>awsmobile features </strong>command. From here, you can see what features youâ€™re able to activate and what features are available as default. For now we only require <strong>cloud-api </strong>and <strong>database </strong>to be selected and activated.</p><pre><strong>#bash </strong></pre><pre>awsmobile features</pre><pre>? select features:<br> â—¯ user-signin<br> â—¯ user-files<br> â—‰ cloud-api<br>â¯â—‰ database<br> â—‰ analytics<br> â—‰ hosting</pre><pre># hit space to select the features you&#39;d like and enter to confirm</pre><p>Whenever you change something locally, as weâ€™ve just done, weâ€™ll need to push it to AWS so the changes can takeÂ effect.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile push</pre><p>Once everythingâ€™s been initialised and pushed, have a poke around the <strong>backend</strong> directory, within <strong>awsmobilejs.</strong> There should be a <strong>cloud-api </strong>directory that contains your Lambda Project and a bunch of boilerplate code to get you started. By default, Lambda is setup to use AWSâ€™s Serverless Express Framework for Node.js, so if youâ€™re experienced with Node.js and Express, everything should look pretty familiar.</p><p>At this point, I like to do a quick check to make sure the Client and Backend are setup and talking to each other. To do this, I write a get request within the <strong>componentDidMount </strong>function, so as soon as our Component mounts, it fetches data from our backend and logs it to the console. AWS Amplify provides a component, API, to handle all requests to ourÂ backend.</p><pre><strong># App.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import logo from &#39;./logo.svg&#39;;<br>import &#39;./App.css&#39;;<br><strong>import Amplify, { API } from &#39;aws-amplify&#39;;<br></strong>import aws_exports from &#39;./aws-exports&#39;;</pre><pre>Amplify.configure(aws_exports);</pre><pre><strong>let apiName = &#39;sampleCloudApi&#39;;<br>let path = &#39;/items&#39;;</strong></pre><pre>class App extends Component {</pre><pre><strong>componentDidMount(){<br>    API.get(apiName, path).then(response =&gt; {<br>      console.log(response)<br>    });<br>  }</strong></pre><pre>render() {<br>    return (<br>      &lt;div className=&quot;App&quot;&gt;<br>        &lt;header className=&quot;App-header&quot;&gt;<br>          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;<br>          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;<br>        &lt;/header&gt;<br>        &lt;p className=&quot;App-intro&quot;&gt;<br>          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br>        &lt;/p&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default App;</pre><p>If youâ€™ve poked around the Lambda app.js file, youâ€™ll notice we should be expecting a response of <strong>({success: â€˜get call succeed!â€™, url: req.url}).</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*T-GpqFtmKzSIPWZeuqQ0Zw.png"/></figure><p>Ok, you might need to squint, but if you check the console youâ€™ll see our request object <strong>{success: â€œget call succeeded!â€, url: /itemsâ€}. </strong>Great! Everythingâ€™s hooked up and ready toÂ go.</p><p>In the next part weâ€™ll look at setting our Front End Pages up and creating the basic CRUD Functions.</p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><h4><a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-two-d740ee8e7456">Serverless React Web App with AWS Amplifyâ€Šâ€”â€ŠPart Two Available Here</a></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><p><strong>This story is published in </strong><a href="http://blog.usejournal.com"><strong>Noteworthy</strong></a><strong>, where thousands come every day to learn about the people &amp; ideas shaping the products weÂ love.</strong></p><p><a href="http://blog.usejournal.com"><strong>Follow our publication</strong></a><strong> to see more product &amp; design stories featured by the </strong><a href="https://usejournal.com/?/utm_source=usejournal.com&amp;utm_medium=blog&amp;utm_campaign=guest_post&amp;utm_content=james_hamann"><strong>Journal</strong></a><strong>Â team.</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=414e9402d92a" width="1" height="1"><hr><p><a href="https://blog.usejournal.com/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a">Serverless React Web App with AWS Amplify â€” Part One</a> was originally published in <a href="https://blog.usejournal.com">Noteworthy - The Journal Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Accelerating Mobile App Development with AWS Amplify</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*6afwPNkz6LnroeA0lfyC2g.png"/></figure><p>Over the last couple of months AWS have released a new Library, <a href="https://github.com/aws/aws-amplify">AWS Amplify</a>, both for Web Development and React Native Mobile Development. The purpose is to provide <em>a declarative and easy-to-use interface across different categories of cloud operations. </em>If youâ€™re already using AWS Services, it plugs directly in, but it also designed in such a way to plug in with any other backed/cloud service that youÂ use.</p><p>Having used it on a few projects myself, it made key areas of app development a breeze and accelerates the development of an app greatly. Services include Authentication through <a href="https://aws.amazon.com/cognito/">AWS Cognito,</a> No-SQL Databaseâ€™s through <a href="https://aws.amazon.com/dynamodb/">DynamoDB</a> and hosting through <a href="https://aws.amazon.com/s3/">S3</a> and <a href="https://aws.amazon.com/cloudfront/">CloudFont</a>. It connects everything so easily and quickly that it gives you the time to focus on actually developing theÂ app.</p><p>Iâ€™ll briefly walkthrough the process of scaffolding a simple <strong>awsmobile</strong> project, to demonstrate how easy and quick it is to get going. Iâ€™ll assume you have the basics, like <a href="https://nodejs.org/en/">node</a>, <a href="https://facebook.github.io/react-native/docs/getting-started.html">react-native-cli</a> or <a href="https://facebook.github.io/react-native/docs/getting-started.html">create-react-native-cli</a> installed already.</p><p>Obviously, first things first, make sure youâ€™ve got <a href="https://aws.amazon.com/cli/">aws</a> and <a href="https://github.com/aws/awsmobile-cli">awsmobile</a> CLI (npm install awsmobile-cliâ€Šâ€”â€Šglobal) installed and ready to go, youâ€™ll also want to make sure youâ€™ve got your AWS_ACCESS_KEY and AWS_SECRET_KEY toÂ hand.</p><p>Letâ€™s setup our CLI to ensure it can connect toÂ AWS.</p><pre><strong>#bash </strong></pre><pre>$ awsmobile configure<br>$ configure aws<br>? accessKeyId:  [ENTER YOUR ACCESS KEY ID] #hit enter<br>? secretAccessKey: [ENTER YOUR SECRET ACCESS KEY] #hit enter<br>? region:  eu-west-2 #select your region using arrows and hit enter</pre><p>Now youâ€™re all setup and connected to AWS letâ€™s setup yourÂ app.</p><h4>Setup</h4><p>Iâ€™ll leave it up to you to decide whether you choose to use create-react-native-app or react-native-init, both have there advantages and disadvantages that are beyond the spec of this post. Iâ€™ll be using react-native init.</p><pre>#<strong>bash </strong></pre><pre>react-native init awsMobileApp<br>This will walk you through creating a new React Native project in /Users/jameshamann/Documents/Development/awsMobileApp<br>Using yarn v1.3.2<br>Installing react-native...<br>[...]<br>âœ¨  Done in 6.10s.<br>To run your app on iOS:<br>   cd /Users/jameshamann/Documents/Development/awsMobileApp<br>   react-native run-ios<br>   - or -<br>   Open ios/awsMobileApp.xcodeproj in Xcode<br>   Hit the Run button<br>To run your app on Android:<br>   cd /Users/jameshamann/Documents/Development/awsMobileApp<br>   Have an Android emulator running (quickest way to get started), or a device connected<br>   react-native run-android</pre><p>Next youâ€™ll probably want to set up your Github repo and push everything up. Then install both AWS Amplify and AWS Amplify ReactÂ Native.</p><pre>#<strong>bash </strong></pre><pre>$ npm install aws-amplify --save<br>$ npm install aws-amplify-react-native --save</pre><p>Now weâ€™ll initialise a awsmobile project, which will setup a backend for our app and connect it to AWSMobile hub.</p><pre><strong>#bash</strong></pre><pre>awsmobile init</pre><pre>Please tell us about your project:<br>? Where is your project&#39;s source directory:  /<br>? Where is your project&#39;s distribution directory that stores build artifacts:  /<br>? What is your project&#39;s build command:  npm run-script build<br>? What is your project&#39;s start command for local test run:  npm run-script start</pre><pre>? What awsmobile project name would you like to use:  awsMobileAppExample</pre><pre>Successfully created AWS Mobile Hub project: awsMobileAppExample</pre><pre>retrieving the latest backend awsmobile project information<br>awsmobile project&#39;s details logged at: awsmobilejs/#current-backend-info/backend-details.json<br>awsmobile project&#39;s access information logged at: awsmobilejs/#current-backend-info/aws-exports.js<br>awsmobile project&#39;s access information copied to: aws-exports.js<br>awsmobile project&#39;s specifications logged at: awsmobilejs/#current-backend-info/mobile-hub-project.yml<br>contents in #current-backend-info/ is synchronized with the latest in the aws cloud</pre><pre>Executing yarn add aws-amplify ...<br>[...]<br>Success! your project is now initialized with awsmobilejs</pre><pre>awsmobilejs/.awsmobile<br>     is the workspace of awsmobile-cli, please do not modify its contents</pre><pre>awsmobilejs/#current-backend-info<br>     contains information of the backend awsmobile project from the last<br>     synchronization with the cloud</pre><pre>awsmobilejs/backend<br>     is where you develop the codebase of the backend awsmobile project</pre><pre>awsmobile console<br>     opens the web console of the backend awsmobile project</pre><pre>awsmobile run<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and runs the frontend application locally</pre><pre>awsmobile publish<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and publishes the frontend application to aws S3 for hosting</pre><pre>Happy coding with awsmobile!</pre><p>That simple command pretty much sets everything up for you within a <strong>awsmobilejs</strong> directory within your app. If you head over to the AWS console, you should see your project, likeÂ this.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*Ae5TkV1NbfbXhKpomKPgSQ.png"/><figcaption>AWS MobileÂ Hub</figcaption></figure><p>AWS Mobile includes the main features youâ€™d need for your mobile app, and thereâ€™s obviously plenty of other AWS Services you can tie into your mobile app. The ones that come bundled in can be found by using the awsmobile command.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile features</pre><pre>? select features:  (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)<br>â¯â—¯ user-signin<br> â—¯ user-files<br> â—¯ cloud-api<br> â—¯ database<br> â—‰ analytics<br> â—‰ hosting</pre><pre>[...]<br>enabled: user-signin<br>backend awsmobile project enabled features:<br>analytics, hosting, user-signin</pre><p>From here you can select whatever feature youâ€™d like to add, for arguments sake letâ€™s add authentication.</p><p>Next, weâ€™ll use AWS Amplifyâ€™s component <strong>withAuthenticator.</strong></p><p>Letâ€™s edit our <strong>App.js </strong>to include the component and then wrap our entire app around it. The main thing weâ€™ll need to edit is changing the class from <strong>export default class App extends Component </strong>to <strong>Class App extends Component </strong>and then export the App at the bottom of the file as an argument in our <strong>withAuthenticator </strong>component. Weâ€™ll also needÂ to</p><pre><strong>#javascript - App.js</strong></pre><pre>[...]</pre><pre>import Amplify from &#39;aws-amplify&#39;;<br>import { withAuthenticator } from &#39;aws-amplify-react-native&#39;;<br>import aws_exports from &#39;./aws-exports&#39;;<br>Amplify.configure(aws_exports);<br>[...]</pre><pre>class App extends Component&lt;Props&gt; { </pre><pre>[...]</pre><pre>}</pre><pre>export default withAuthenticator(App);</pre><p>Now letâ€™s boot our app up in an emulator. It should look similar to the below, with all the basics setup, including routing.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JLYQ4CNKr4DkriQS8WXL1Q.png"/><figcaption>Authentication Front EndÂ Setup</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dvNp1DqBL5xAwAP0ilppyA.png"/></figure><p>When trying to sign up, however, youâ€™ll notice thereâ€™s an error <strong>No userPool.</strong> Thatâ€™s because we havenâ€™t synced our backend with the cloudÂ yet.</p><pre><strong>#bash </strong></pre><pre>$awsmobile push</pre><pre>[...]</pre><p>Once this is complete, reboot your app on the emulator and try signing up. Boom, youâ€™ve got a full authentication system ready to go, built in with SMS confirmations. (please check AWS Billing/Charges to make sure you donâ€™t incur any unwanted charges). Once a user Signs up, theyâ€™ll be visible in your AWS CognitoÂ Pool.</p><p>Itâ€™s super simple to get setup and going with AWS, plus with the addition of AWS Amplify, itâ€™s even easier to connect essential AWS Services to yourÂ app.</p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb2034e60160" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>A brief guide to Semantic Versioning</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sr-foEv_uj2kJ4Ew6mhDvw.jpeg"/></figure><p>Whenever releasing a product or app, youâ€™ll want to version it. This helps users understand what stage the app is at and also helps when integrating the app into package managers. In Software Development, we version apps by following <strong>Semantic Versioning, </strong>which is a general template that everyone uses and understands.</p><blockquote>Why bother?</blockquote><p>Versioning our apps helps us keep track of whatâ€™s been added/removed at what point. It can get real hectic, real fast, especially in the early stages when youâ€™re releasing new features and fixing bugs. Youâ€™re gonna want to reference things that have been added or things that have beenÂ fixed.</p><blockquote>Where would I keep a track ofÂ this?</blockquote><p>You can <strong>tag </strong>your releases on <strong>Github </strong>using <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging"><strong>git tag.</strong></a><strong> </strong>Essentially, you just tag a version number to a specific commit, like a merge, push it and this appears on the repository under â€œreleasesâ€, with any notes youâ€™d like to add. Itâ€™s best to keep track of all these changes in a <strong>CHANGELOG, </strong>thereâ€™s a nice format to follow outlined <a href="https://keepachangelog.com/en/1.0.0/">here.</a> This way you can keep track of whatâ€™s been fixed and any upcoming features that are being released into the next version. Itâ€™s also important to remember, software is built for people. So people need to actually understand whatâ€™s going on and at what stage your apps currently at, having a well documented<strong> CHANGELOG</strong> helps provide a clear timeline and explanation of yourÂ app.</p><blockquote>Ok, so how do I go about versioning my app/package?</blockquote><h4>0â€Šâ€”â€ŠPre-MVP/Alpha</h4><p>At this stage, youâ€™re developing your app and still building towards an MVP. Thereâ€™s no real point differentating between versions here because itâ€™s not a useable product yet. During this period, the version will remain atÂ <strong>0.</strong></p><h4><strong>Major.Minor.Patchâ€Šâ€”â€ŠAlpha/Beta</strong></h4><p>Once you reach your <strong>MVP, </strong>you might iterate over this and create <strong>Alpha/Beta </strong>releases for users to test and supply feedback on. When creating your first release, youâ€™ll want to start versioning. This helps you keep track of your app and creates a timeline of what features were added when and what bugs have and have not been fixed yet. You might be wondering, what exactly constitutes a major, minor or patchÂ release.</p><p><strong>Major Releaseâ€Šâ€”â€Š</strong>Increment the first digit by 1 if the new features break backwards compatibility/current features</p><p><strong>Minor Releaseâ€Šâ€”â€Š</strong>Increment the middle digit by 1 if the new features donâ€™t break any existing features and are compatible with the app in itâ€™s currentÂ state.</p><p><strong>Patch Releaseâ€Šâ€”â€Š</strong>Increment the last digit by 1 if youâ€™re publishing bug/patch fixes to yourÂ app.</p><p>Before publishing your first, useable version, you might find yourself incrementing the middle and the last digit to keep track of Alpha/Beta releases. Only once youâ€™re ready for a proper, first release, should you start versioning fromÂ 1.0.0.</p><p>I canâ€™t stress enough the benefits of keeping a clean, well documented CHANGELOG. Regardless of whether your project is open source or not, itâ€™s vital to keep track of whatâ€™s been worked on. It helps guide you when deciding what features need work and gives you good insight into your releaseÂ cycle.</p><p>If youâ€™re interested in reading more, you can get the full breakdown of <a href="https://semver.org/">Semantic Versioning on theirÂ site.</a></p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c6055d87c90e" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi Ezequiel FrescÃ³ Werchowsky, thanks for reading and getting in touch!</b></h4> <p style="text-align:justify"><p>Hi <a href="https://medium.com/u/92d053321ec7">Ezequiel FrescÃ³ Werchowsky</a>, thanks for reading and getting in touch! Apologies, it seems like I mightâ€™ve done, thank you for letting me know, Iâ€™ll update the post with theÂ changes.</p><p>Regarding your error, it looks like itâ€™s an issue with AWS and not being able to read your credentials. Have you downloaded the AWS CLI (<a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html">https://docs.aws.amazon.com/cli/latest/userguide/installing.html</a>), if so run the command: aws configure. This will prompt you to enter you AWS_ACCESS_KEY and your AWS_SECRET_ACCESS_KEY, which can be retrieved from the AWS console, under â€œMy Secruity Credentialsâ€, on the top right dropdown by your username.</p><p>Try the above and let me know if you run into any other issues, Iâ€™m happy toÂ help!</p><p>Thanks, James</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3be6aa3813e8" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Ryan Pereira Thanks for reading and getting in touch!</b></h4> <p style="text-align:justify"><p><a href="https://medium.com/u/bf1bb52caac4">Ryan Pereira</a> Thanks for reading and getting inÂ touch!</p><p>Here, Iâ€™m explaining that you should setup a brand new jekyll site and add your Gem, that youâ€™ve just built, to the Gemfile and running bundle install. When adding your gem, you need to specify itâ€™s path, like this:<strong> gem â€œYOURTHEMEâ€ =&gt;Â :path =&gt; â€œpath/to/your/gemâ€.</strong></p><p>Looking at the error from your previous comment, I suggest running gem install bundler and gem install jekyll again, looks like maybe an issue with the Ruby Version. In which case it might be best to upgrade to 2.4 +. To upgrade your ruby version, you can install <a href="https://rvm.io/">RVM</a> (ruby version manager).</p><p>This is only applicable if youâ€™re looking to build your own Gem Theme and publish it. If you wish to use an existing theme, you can use the one I created (jekyll-material-theme) and customise it or grab one from <a href="http://jekyllthemes.org/">http://jekyllthemes.org/</a>.</p><p>Hope this helps a little! Let me know if you need anythingÂ else.</p><p>Thanks, James</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3e1c288759dc" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Configuring your Elastic Beanstalk App for SSL</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/859/1*a96dh5kNx9M4xzB2EiRjuQ.png"/></figure><p>Itâ€™s always a good idea to add a SSL certificate. It gives people piece of mind when visiting your site that information isnâ€™t being accessed by third-parties and also<a href="https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html"> boosts your SEO ranking in Google.</a> Setting your Elastic Beanstalk app up for SSL isnâ€™t too difficult and requires just a few simpleÂ steps.</p><h4>Getting Started</h4><p>Iâ€™m going to assume you have a domain already registered, either living in <a href="https://aws.amazon.com/route53/">Route 53</a> or another domain provider. To start with, if you havenâ€™t done so already, youâ€™ll need to point your domain to your EB app. This can be done by creating an Alias <strong>A Record </strong>and setting itâ€™s value equal to your EB Appâ€™s <strong>URL. </strong>This can be found on the Elastic Beanstalk Dashboard.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AxGaW7tST3TXrMEGB5f59A.png"/><figcaption>Elastic Beanstalk Management Console</figcaption></figure><p>In this example, itâ€™s <a href="http://ssl-example.eu-west-2.elasticbeanstalk.com">http://ssl-example.eu-west-2.elasticbeanstalk.com</a>. When adding this to your domain, ensure the A record is set to <strong>Yes </strong>for <strong>Alias.</strong> The value will then be your appâ€™s Elastic Beanstalk URL.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/824/1*lPbprwruQj6NT15ArSHKsw.png"/><figcaption>Route 53 Configuration for an AÂ Record</figcaption></figure><p>Now, if you visit your domain, in my case <a href="http://sslexample.jameshamann.com">sslexample.jameshamann.com</a>, youâ€™ll see your app! You can try to type <a href="https://yourdomain.com">https://yourdomain.com</a> but as thereâ€™s no certificate, the request will timeout. So letâ€™s add a certificate!</p><h4>Configure yourÂ App</h4><p>In order to use a SSL certificate for your Elastic Beanstalk App, youâ€™ll need to change the configuration of your app to use <strong>Load Balancers </strong>as opposed to a single instance. This can cost more, so please check your billing dashboard to ensure youâ€™re not going over budget or anything.</p><blockquote>What are Application Load Balancers?</blockquote><p>In essence, instead of running a single instance, a load balancer distributes traffic across multiple targets, instances, across multiple availability zones, which boosts availability of yourÂ app.</p><p>In our example the SSL certificate is applied to the load balancer, so connections between the Client and Load Balancer are secure and encrypted.</p><p>In order to configure your app, head to the <strong>Configuration </strong>tab of your Elastic Beanstalk dashboard and click the <strong>modify </strong>link on the <strong>CapacityÂ </strong>card.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*p_0OSYzUKzxnVcDyIx1UTg.png"/><figcaption>Configuration Tab of Elastic Beanstalk Appâ€Šâ€”â€ŠCapacity card located at the topÂ right</figcaption></figure><p>Once here, the only thing I advise you to change is the maximum number of instances, from <strong>4 to 1</strong>, however thatâ€™s up toÂ you.</p><p>Donâ€™t change anything else, just hitÂ <strong>Save.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gLJNgOZBKkiCGlXF7fT-WA.png"/><figcaption>Adding a LoadÂ Balancer</figcaption></figure><p>This will then take you back to the configuration page, where youâ€™ll need to hit <strong>Apply </strong>for your changes to take place. As your app will be unavailable for a short period whilst the changes take place, youâ€™ll need to confirm again after hittingÂ Apply.</p><h4>Creating an SSL Certificate withÂ ACM</h4><p>Now we need to actually create our certificate. As weâ€™re using Elastic Beanstalk, it makes sense to create a certificate in ACM (Amazon Certificate Manager).</p><p>In my case, I opted for a wildcard certificate for the domain <strong>jameshamann.com. </strong>This means all alias domains, i.e sslexample.jameshamann.com will be covered by the same SSL certificate. To do this, head over to <strong>ACM </strong>and request a certificate. Type in your domain, if you wish to setup a wild card add a * to the beginning of yourÂ domain.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9m-OrW6A1FSoG69zCP7J7A.png"/><figcaption>AWS Certificate Manager Requesting a Certificate</figcaption></figure><p>Youâ€™ll have two options to validate that youâ€™re the owner of the domain. DNS or Email. I chose DNS, but whatever you choose, just make sure you have access to the correct email domains if choosingÂ email.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2ljBzx4kwrwjG4WOyqIfQA.png"/><figcaption>DNS Config forÂ domain</figcaption></figure><p>To verify via DNS, youâ€™ll need to add a CNAME record with whatever values are generated in your <strong>DNS_Configuration.csv </strong>file.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/872/1*xF8yRtr4dISmP3LOZTjsnw.png"/><figcaption>Enter the Name value from theÂ .csv file and the Value from theÂ .csv file and hitÂ create.</figcaption></figure><p>This will take a little time to verify, but once done, your certificate should move from <strong>Pending </strong>toÂ <strong>Issued.</strong></p><h4>Bringing it allÂ together</h4><p>Lastly, we need to apply our newly created SSL Certificate to our Appâ€™s Load Balancer. To do this, navigate to the Configuration Tab of your Elastic Beanstalk App. There should be a new card labelled <strong>Load Balancer.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RDqYx_EicYyrVFw-x-wVyA.png"/><figcaption>Click <strong>modify </strong>on the <strong>Load BalancerÂ </strong>card</figcaption></figure><p>In order to add the certificate, weâ€™ll need to open up port <strong>443 </strong>(SSL Port) and assign our certificate.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IVTxvbsh7tQ9RlaQ-1bOBA.png"/></figure><p>If your certificate doesnâ€™t appear in the dropdown, try refreshing and waiting a bit. Once it does, choose it and hit save. Again, youâ€™ll be directed back to the Configuration page where youâ€™ll have to <strong>Apply </strong>yourÂ changes.</p><p>Once completeled, navigate to <a href="https://yourdomain.com"><strong>https://yourdomain.com</strong></a><strong> </strong>and you should see your site served throughÂ HTTPS.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hs4xzNHX06qnQXAW2jWRhQ.png"/><figcaption>Site Secured!</figcaption></figure><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9065ca091f49" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Node.js RESTful API with DynamoDB Local</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ejTEhVznAjlYSXsWz5zZ7A.png"/></figure><p>Node is usually used along side MongoDB in the <strong>MEAN</strong> stack. However, using Amazonâ€™s DynamoDB has itâ€™s own benefits, not least from speed, scalability, affordability and freeing your time up from configuring database clusters/updates. Through this post Iâ€™ll discuss how to setup DynamoDB with your Node projectÂ locally.</p><h4>Versions</h4><ul><li>Node 9.2.1</li><li>Express 4.15.5</li><li>DynamoDB Localâ€Šâ€”â€Š<a href="https://s3.eu-central-1.amazonaws.com/dynamodb-local-frankfurt/dynamodb_local_latest.tar.gz">Latest</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html">JRE</a> (Java Runtime Environment) 6.x orÂ newer</li></ul><h4>Setting up your NodeÂ Project</h4><p>To get things moving quickly, weâ€™ll use the express generator to scaffold a project forÂ us.</p><pre><strong>#bash</strong></pre><pre>$ express node-dynamo-db<br>   <br>   create : node-dynamo-db<br>   create : node-dynamo-db/package.json<br>   create : node-dynamo-db/app.js<br>   create : node-dynamo-db/public<br>   create : node-dynamo-db/routes<br>   create : node-dynamo-db/routes/index.js<br>   create : node-dynamo-db/routes/users.js<br>   create : node-dynamo-db/views<br>   create : node-dynamo-db/views/index.jade<br>   create : node-dynamo-db/views/layout.jade<br>   create : node-dynamo-db/views/error.jade<br>   create : node-dynamo-db/bin<br>   create : node-dynamo-db/bin/www<br>   create : node-dynamo-db/public/javascripts<br>   create : node-dynamo-db/public/images<br>   create : node-dynamo-db/public/stylesheets<br>   create : node-dynamo-db/public/stylesheets/style.css</pre><pre>install dependencies:<br>     $ cd node-dynamo-db &amp;&amp; npm install</pre><pre>run the app:<br>     $ DEBUG=node-dynamo-db:* npm start</pre><pre>$ cd node-dynamo-db<br>$ npm install</pre><p>Fire up your server to ensure itâ€™s all working as intended.</p><pre>$ npm start</pre><p>Navigate to <a href="http://localhost:3000">http://localhost:3000</a> and youâ€™ll see the welcome page from express, likeÂ below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*t5zAKeNYDFMigF_oyNIUdA.png"/><figcaption>Generic Express WelcomeÂ Page</figcaption></figure><p>Next, as thereâ€™s no live-reloading, weâ€™ll install Nodemon to watch our files and whenever a change is made, itâ€™ll restart the server for us. Without Nodemon, youâ€™re gonna get frustrated real fast. Once installed, weâ€™ll update our <strong>start </strong>command within the <strong>package.json</strong> to run the <strong>nodemon </strong>command as opposed toÂ node.</p><pre><strong>#bash </strong></pre><pre>$ npm install -g nodemon</pre><pre>--------------------------------------------------------------------</pre><pre><strong>#package.json </strong></pre><pre>{<br>  &quot;name&quot;: &quot;node-dynamo-db&quot;,<br>  &quot;version&quot;: &quot;0.0.0&quot;,<br>  &quot;private&quot;: true,<br>  &quot;scripts&quot;: {<br><strong>    &quot;start&quot;: &quot;nodemon  ./bin/www&quot;<br></strong>  },<br>  &quot;dependencies&quot;: {<br>    &quot;body-parser&quot;: &quot;~1.18.2&quot;,<br>    &quot;cookie-parser&quot;: &quot;~1.4.3&quot;,<br>    &quot;debug&quot;: &quot;~2.6.9&quot;,<br>    &quot;express&quot;: &quot;~4.15.5&quot;,<br>    &quot;jade&quot;: &quot;~1.11.0&quot;,<br>    &quot;morgan&quot;: &quot;~1.9.0&quot;,<br>    &quot;serve-favicon&quot;: &quot;~2.4.5&quot;<br>  }<br>}</pre><h4>Setting upÂ DynamoDB</h4><p>First download the file from the link above, unpack it and navigate into the directory. Youâ€™ll notice DynamoDB is provided as an executableÂ .jar file. In order to start the database up, we need to run the following command within the directory theÂ .jar file isÂ located.</p><pre><strong>#bash </strong></pre><pre>$ java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb</pre><pre>Initializing DynamoDB Local with the following configuration:<br>Port: 8000<br>InMemory: false<br>DbPath: null<br>SharedDb: true<br>shouldDelayTransientStatuses: false<br>CorsParams: *</pre><p>Boom, youâ€™ve got a local instance of DynamoDB running! Problem is, unless youâ€™re gifted with photographic memory, youâ€™re probably not going to rememeber the above command and even if you do, itâ€™s ballache to write out each time. Lets speed things up and create an <a href="https://medium.com/@jameshamann/automation-with-cron-d10f7cbbb638">alias</a> command within ourÂ <strong>.bashrc </strong>orÂ <strong>.zshrc, </strong>depending on what you use. Mine looks likeÂ this.</p><pre><strong>#bash .zshrc or .bashrc</strong></pre><pre>alias ddb=&quot;cd path/to/dynamodb_local_latest &amp;&amp; java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb&quot;</pre><p>Iâ€™ve named my alias <strong>ddb, </strong>it navigates to the directory and then executes theÂ .jar, simple as that. Now when reloading my terminal window and running ddb, DynamoDB should spinÂ up.</p><pre><strong>#bash</strong></pre><pre>$ ddb</pre><pre>Initializing DynamoDB Local with the following configuration:<br>Port: 8000<br>InMemory: false<br>DbPath: null<br>SharedDb: true<br>shouldDelayTransientStatuses: false<br>CorsParams: *</pre><p>Now weâ€™re all set to start creating our table and to begin seeding some data into our table. For the purpose of this demo, Iâ€™ll be making a database revolving aroundÂ cars.</p><p>Before moving forward, letâ€™s just update our <strong>package.json </strong>to automate some of the commands weâ€™ll be running fairly frequently.</p><pre>{<br>  &quot;name&quot;: &quot;crafty-api&quot;,<br>  &quot;version&quot;: &quot;0.0.0&quot;,<br>  &quot;private&quot;: true,<br>  &quot;scripts&quot;: {<br>   <strong> &quot;start&quot;: &quot;nodemon app.js&quot;,<br></strong>    <strong>&quot;create-db&quot;: &quot;cd dynamodb &amp;&amp; node createCarsTable.js &amp;&amp; cdÂ ..&quot;,<br>    &quot;delete-db&quot;: &quot;cd dynamodb &amp;&amp; node deleteCarsTable.js &amp;&amp; cdÂ ..&quot;,<br>    &quot;load-data&quot;: &quot;cd dynamodb &amp;&amp; node loadCarData.js &amp;&amp; cdÂ ..&quot;, <br>    &quot;read-data&quot;: &quot;cd dynamodb &amp;&amp; node readDataTest.js &amp;&amp; cdÂ ..&quot;<br></strong>  },<br>  &quot;dependencies&quot;: {<br>    &quot;aws-sdk&quot;: &quot;^2.176.0&quot;,<br>    &quot;body-parser&quot;: &quot;~1.18.2&quot;,<br>    &quot;cookie-parser&quot;: &quot;~1.4.3&quot;,<br>    &quot;cors&quot;: &quot;^2.8.4&quot;,<br>    &quot;debug&quot;: &quot;~2.6.9&quot;,<br>    &quot;ejs&quot;: &quot;^2.5.7&quot;,<br>    &quot;express&quot;: &quot;~4.15.5&quot;,<br>    &quot;jade&quot;: &quot;~1.11.0&quot;,<br>    &quot;morgan&quot;: &quot;~1.9.0&quot;,<br>    &quot;newman&quot;: &quot;^3.9.1&quot;,<br>    &quot;node-uuid&quot;: &quot;^1.4.8&quot;,<br>    &quot;serve-favicon&quot;: &quot;~2.4.5&quot;,<br>    &quot;uuid&quot;: &quot;^3.2.1&quot;<br>  }<br>}</pre><p>This is what my current one looks like and it just speeds things up so much, so consider adding your own to speed up your workflow.</p><p>First things first, weâ€™re gonna need to create a table and choose a <strong>partition key. </strong>Amazon provided pretty good advice <a href="https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key/">here</a> on what constitutes as a good key. Reason we need a key is because Dynamo DB partitions our data across multiple storage units and uses that key to both store and read the data. Therefore, <strong>the partition key must be a unique value</strong>. Good examples are user_ids and devices_ids.</p><p>For my table Iâ€™ve chosenÂ <strong>car_id.</strong></p><pre><strong>#JavaScript - createCarsTable.js</strong></pre><pre>var AWS = require(&quot;aws-sdk&quot;);</pre><pre>AWS.config.update({<br>  region: &quot;eu-west-2&quot;,<br>  endpoint: &quot;<a href="http://localhost:8000">http://localhost:8000</a>&quot;<br>});</pre><pre>var dynamodb = new AWS.DynamoDB();</pre><pre>var params = {<br>    TableName : &quot;Cars&quot;,<br>    KeySchema: [<br>        { AttributeName: &quot;id&quot;, KeyType: &quot;HASH&quot;}, <strong> //Partition key</strong></pre><pre>],<br>    AttributeDefinitions: [<br>        { AttributeName: &quot;id&quot;, AttributeType: &quot;N&quot; },</pre><pre>],<br>    ProvisionedThroughput: {<br>        ReadCapacityUnits: 5,<br>        WriteCapacityUnits: 5<br>    }<br>};</pre><pre>dynamodb.createTable(params, function(err, data) {<br>    if (err) {<br>        console.error(&quot;Unable to create table. Error JSON:&quot;, JSON.stringify(err, null, 2));<br>    } else {<br>        console.log(&quot;Created table. Table description JSON:&quot;, JSON.stringify(data, null, 2));<br>    }<br>});</pre><p>Now run youâ€™re <strong>create-db </strong>command, making sure Dynamo DB is running in the background on another terminal window, on portÂ 8000.</p><pre><strong>#bash</strong></pre><pre>yarn create-db<br>yarn run v1.3.2<br>$ cd dynamodb &amp;&amp; node createCarsTable.js &amp;&amp; cd ..<br>Created table. Table description JSON: {<br>  &quot;TableDescription&quot;: {<br>    &quot;AttributeDefinitions&quot;: [<br>      {<br>        &quot;AttributeName&quot;: &quot;id&quot;,<br>        &quot;AttributeType&quot;: &quot;N&quot;<br>      }<br>    ],<br>    &quot;TableName&quot;: &quot;Cars&quot;,<br>    &quot;KeySchema&quot;: [<br>      {<br>        &quot;AttributeName&quot;: &quot;id&quot;,<br>        &quot;KeyType&quot;: &quot;HASH&quot;<br>      }<br>    ],<br>    &quot;TableStatus&quot;: &quot;ACTIVE&quot;,<br>    &quot;CreationDateTime&quot;: &quot;2018-02-01T16:08:25.308Z&quot;,<br>    &quot;ProvisionedThroughput&quot;: {<br>      &quot;LastIncreaseDateTime&quot;: &quot;1970-01-01T00:00:00.000Z&quot;,<br>      &quot;LastDecreaseDateTime&quot;: &quot;1970-01-01T00:00:00.000Z&quot;,<br>      &quot;NumberOfDecreasesToday&quot;: 0,<br>      &quot;ReadCapacityUnits&quot;: 5,<br>      &quot;WriteCapacityUnits&quot;: 5<br>    },<br>    &quot;TableSizeBytes&quot;: 0,<br>    &quot;ItemCount&quot;: 0,<br>    &quot;TableArn&quot;: &quot;arn:aws:dynamodb:ddblocal:000000000000:table/Cars&quot;<br>  }<br>}<br>âœ¨  Done in 0.47s.</pre><p>Now youâ€™re table is setup and ready to seed dataÂ into.</p><p>In this example, weâ€™re using Dynamo DBâ€™s <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#putItem-property"><strong>PutItem</strong></a><strong> </strong>method to seed some data into our Database.</p><pre>#<strong>JSON - carData.json </strong></pre><pre>[<br>  { &quot;id&quot;: 1,<br>    &quot;type&quot; : &quot;Automatic&quot;,<br>    &quot;name&quot; : &quot;Toyota Yaris&quot;,<br>    &quot;manufacturer&quot; : &quot;Toyota&quot;,<br>    &quot;fuel_type&quot; : &quot;Petrol&quot;,<br>    &quot;description&quot; : &quot;A smooth ride&quot;<br>  },<br>  { &quot;id&quot;: 2,<br>    &quot;type&quot; : &quot;Manual&quot;,<br>    &quot;name&quot; : &quot;Volkswagen Golf&quot;,<br>    &quot;manufacturer&quot; : &quot;Volkswagen&quot;,<br>    &quot;fuel_type&quot; : &quot;Petrol&quot;,<br>    &quot;description&quot; : &quot;Good Value&quot;<br>  }<br>]</pre><pre>------------------------------------------------------------------</pre><pre>#<strong>JavaScript - loadCarData.js</strong></pre><pre>var AWS = require(&quot;aws-sdk&quot;);<br>var fs = require(&#39;fs&#39;);</pre><pre>AWS.config.update({<br>    region: &quot;eu-west-2&quot;,<br>    endpoint: &quot;<a href="http://localhost:8000">http://localhost:8000</a>&quot;<br>});</pre><pre>var docClient = new AWS.DynamoDB.DocumentClient();</pre><pre>console.log(&quot;Importing Cars into DynamoDB. Please wait.&quot;);</pre><pre>var cars = JSON.parse(fs.readFileSync(&#39;carData.json&#39;, &#39;utf8&#39;));</pre><pre>cars.forEach(function(car) {<br>  console.log(car)</pre><pre>var params = {<br>        TableName: &quot;Cars&quot;,<br>        Item: {<br>            &quot;id&quot;: car.id,<br>            &quot;type&quot;: car.type,<br>            &quot;name&quot;: car.name,<br>            &quot;manufacturer&quot;: car.manufacturer,<br>            &quot;fuel_type&quot;: car.fuel_type,<br>            &quot;description&quot;: car.description<br>        }<br>    };</pre><pre>docClient.put(params, function(err, data) {<br>       if (err) {<br>           console.error(&quot;Unable to add Car&quot;, car.name, &quot;. Error JSON:&quot;, JSON.stringify(err, null, 2));<br>       } else {<br>           console.log(&quot;PutItem succeeded:&quot;, car.name);<br>       }<br>    });<br>});</pre><p>If you run your <strong>load-data </strong>command, it should seed in the two items in our <strong>carData.json </strong>file and log the names back in the console, likeÂ below.</p><pre>#<strong>bash </strong></pre><pre>yarn load-data<br>yarn run v1.3.2<br>$ cd dynamodb &amp;&amp; node loadCarData.js &amp;&amp; cd ..<br>Importing Cars into DynamoDB. Please wait.<br>{ id: 1,<br>  type: &#39;Automatic&#39;,<br>  name: &#39;Toyota Yaris&#39;,<br>  manufacturer: &#39;Toyota&#39;,<br>  fuel_type: &#39;Petrol&#39;,<br>  description: &#39;A smooth ride&#39; }<br>{ id: 2,<br>  type: &#39;Manual&#39;,<br>  name: &#39;Volkswagen Golf&#39;,<br>  manufacturer: &#39;Volkswagen&#39;,<br>  fuel_type: &#39;Petrol&#39;,<br>  description: &#39;Good Value&#39; }<br>PutItem succeeded: Toyota Yaris<br>PutItem succeeded: Volkswagen Golf<br>âœ¨  Done in 0.46s.</pre><p>Now our datas in there, but how do we know? Letâ€™s run a quick test using Dynamo DBs<a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html"> DocumentClientÂ </a><strong>.get </strong>method. <strong>DocumentClient </strong>is just a class that simplifies working with DynamoDBÂ Items.</p><pre>#<strong>JavaScript - readDataTest.js </strong></pre><pre>var AWS = require(&quot;aws-sdk&quot;);</pre><pre>AWS.config.update({<br>  region: &quot;eu-west-2&quot;,<br>  endpoint: &quot;<a href="http://localhost:8000">http://localhost:8000</a>&quot;<br>});</pre><pre>var docClient = new AWS.DynamoDB.DocumentClient()</pre><pre>var table = &quot;Cars&quot;;</pre><pre>var id = 1;</pre><pre>var params = {<br>    TableName: table,<br>    Key:{<br>        &quot;id&quot;: id<br>    }<br>};</pre><pre>docClient.get(params, function(err, data) {<br>    if (err) {<br>        console.error(&quot;Unable to read item. Error JSON:&quot;, JSON.stringify(err, null, 2));<br>    } else {<br>        console.log(&quot;GetItem succeeded:&quot;, JSON.stringify(data, null, 2));<br>    }<br>});</pre><p>Remembering our JSON file, we should expect the <strong>Toyota Yaris</strong> to be returned to theÂ consoleâ€¦</p><pre>#<strong>bash</strong><br>$ yarn read-data<br>yarn run v1.3.2<br>$ cd dynamodb &amp;&amp; node readDataTest.js &amp;&amp; cd ..<br>GetItem succeeded: {<br>  &quot;Item&quot;: {<br>    &quot;name&quot;: &quot;Toyota Yaris&quot;,<br>    &quot;description&quot;: &quot;A smooth ride&quot;,<br>    &quot;id&quot;: 1,<br>    &quot;type&quot;: &quot;Automatic&quot;,<br>    &quot;fuel_type&quot;: &quot;Petrol&quot;,<br>    &quot;manufacturer&quot;: &quot;Toyota&quot;<br>  }<br>}<br>âœ¨  Done in 0.56s.</pre><p>BAM! DynamoDB is setup and seeded with data, now we just need to bring all the elements together.</p><h4><strong>Bringing it allÂ together</strong></h4><p>At the moment, our Node backend isnâ€™t actually talking to Dynamo DB at all, lets change that by incorporating some of the methods weâ€™ve used above and create a route that returns <strong>allÂ cars.</strong></p><p>To do this weâ€™re going to using <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html">DynamoDBs DocClient</a> <strong>scanÂ </strong>method.</p><pre>#<strong>Javascript app.js</strong></pre><pre>var express = require(&#39;express&#39;);<br>var path = require(&#39;path&#39;);<br>var favicon = require(&#39;serve-favicon&#39;);<br>var logger = require(&#39;morgan&#39;);<br>var cookieParser = require(&#39;cookie-parser&#39;);<br>var bodyParser = require(&#39;body-parser&#39;);<br>var AWS = require(&quot;aws-sdk&quot;);</pre><pre>var app = express();</pre><pre>app.listen(3000, () =&gt; console.log(&#39;Cars API listening on port 3000!&#39;))</pre><pre>AWS.config.update({<br>  region: &quot;eu-west-2&quot;,<br>  endpoint: &quot;<a href="http://localhost:8000">http://localhost:8000</a>&quot;<br>});</pre><pre>var docClient = new AWS.DynamoDB.DocumentClient();</pre><pre>app.use(logger(&#39;dev&#39;));<br>app.use(bodyParser.json());<br>app.use(bodyParser.urlencoded({ extended: false }));<br>app.use(cookieParser());<br>app.set(&#39;view engine&#39;, &#39;jade&#39;);</pre><pre>app.get(&#39;/&#39;, function (req, res) {<br>  res.send({ title: &quot;Cars API Entry Point&quot; })<br>})</pre><pre>app.get(&#39;/cars&#39;, function (req, res) {</pre><pre>var params = {<br>    TableName: &quot;Cars&quot;,<br>    ProjectionExpression: &quot;#id, #name, #type, #manufacturer, #fuel_type, #description&quot;,<br>    ExpressionAttributeNames: {<br>        &quot;#id&quot;: &quot;id&quot;,<br>        &quot;#name&quot;: &quot;name&quot;,<br>        &quot;#type&quot;: &quot;type&quot;,<br>        &quot;#manufacturer&quot;: &quot;manufacturer&quot;,<br>        &quot;#fuel_type&quot;: &quot;fuel_type&quot;,<br>        &quot;#description&quot;: &quot;description&quot;<br>    }<br>};</pre><pre>console.log(&quot;Scanning Cars table.&quot;);<br>docClient.scan(params, onScan);</pre><pre>function onScan(err, data) {<br>    if (err) {<br>        console.error(&quot;Unable to scan the table. Error JSON:&quot;, JSON.stringify(err, null, 2));<br>    } else {<br>        res.send(data)<br>        // print all the Cars<br>        console.log(&quot;Scan succeeded.&quot;);<br>        data.Items.forEach(function(car) {<br>           console.log(car.id, car.type, car.name)<br>        });</pre><pre>if (typeof data.LastEvaluatedKey != &quot;undefined&quot;) {<br>            console.log(&quot;Scanning for more...&quot;);<br>            params.ExclusiveStartKey = data.LastEvaluatedKey;<br>            docClient.scan(params, onScan);<br>        }<br>    }<br>  }<br>})</pre><p>This is what you want your <strong>app.js </strong>file to look like. I know we can refactor this and move some code to the routes folder, however for the purposes of keeping this article as to the point as possible, Iâ€™ll leave that toÂ you.</p><p>As the file shows, we create a new route called <strong>/cars </strong>and create a params variable, which contains the name of the table and what we want to be returned from our scan. We then create a function called <strong>onScan </strong>which sends our data to the client and logs our results to console. This also contains some error catching, should there be any issues with yourÂ request.</p><p>Now, if you navigate to <a href="http://localhost:3000/cars"><strong>http://localhost:3000/cars</strong></a><strong> </strong>you should see something resembling theÂ below.</p><pre>#<strong>JSON - response from </strong><a href="http://localhost:3000/cars"><strong>http://localhost:3000/cars</strong></a></pre><pre>{&quot;Items&quot;:[{&quot;name&quot;:&quot;Volkswagen Golf&quot;,&quot;description&quot;:&quot;Good Value&quot;,&quot;id&quot;:2,&quot;fuel_type&quot;:&quot;Petrol&quot;,&quot;type&quot;:&quot;Manual&quot;,&quot;manufacturer&quot;:&quot;Volkswagen&quot;},{&quot;name&quot;:&quot;Toyota Yaris&quot;,&quot;description&quot;:&quot;A smooth ride&quot;,&quot;id&quot;:1,&quot;fuel_type&quot;:&quot;Petrol&quot;,&quot;type&quot;:&quot;Automatic&quot;,&quot;manufacturer&quot;:&quot;Toyota&quot;}],&quot;Count&quot;:2,&quot;ScannedCount&quot;:2}</pre><p>Great job! Now youâ€™ve got building blocks of a Node.js RESTful API using AWS DynamoDB.</p><p>Letâ€™s do one more route where we ask DynamoDB to return a car, byÂ <strong>id.</strong></p><p>Letâ€™s call our route <strong>/cars/:id. </strong>Weâ€™ll pass the ID in via our request url. Weâ€™ll then use the ID to query the table and return us the correct car. We get the<strong> id </strong>value by slicing the string to return us only theÂ number.</p><p>Remember, however, when we created our table we specified that the <strong>id was a number type.</strong> Therefore if we try to pass the value, as it is, to DynamoDB, itâ€™ll spit back an error. <strong>We first need to convert our id value from string to integer using parseInt().</strong></p><pre><strong>#JavaScript - app.js</strong></pre><pre>[...]</pre><pre>app.get(&#39;/cars/:id&#39;, function (req, res) {</pre><pre>var carID = parseInt(req.url.slice(6));<br>  console.log(req.url)<br>  console.log(carID)</pre><pre>var params = {<br>      TableName : &quot;Cars&quot;,<br>      KeyConditionExpression: &quot;#id = :id&quot;,<br>      ExpressionAttributeNames:{<br>          &quot;#id&quot;: &quot;id&quot;<br>      },<br>      ExpressionAttributeValues: {<br>          &quot;:id&quot;: carID<br>      }<br>  };</pre><pre>docClient.query(params, function(err, data) {<br>    if (err) {<br>        console.error(&quot;Unable to query. Error:&quot;, JSON.stringify(err, null, 2));<br>    } else {<br>        console.log(&quot;Query succeeded.&quot;);<br>        res.send(data.Items)<br>        data.Items.forEach(function(car) {<br>            console.log(car.id, car.name, car.type);<br>        });<br>    }<br>});</pre><pre>});</pre><p>We save our converted <strong>carID </strong>value in a variable and use this in our params object. We then use the <strong>query </strong>method to gather and return the data to the client. If all is setup correctly, you should be able to navigate to <a href="http://localhost:3000/cars/1"><strong>http://localhost:3000/cars/1</strong></a><strong> </strong>and see that the Yaris is returned as JSON. If you check your terminal youâ€™ll see the <strong>id, name and type </strong>of the carÂ queried.</p><pre>#<strong>JSON - </strong><a href="http://localhost:3000/cars/1"><strong>http://localhost:3000/cars/1</strong></a></pre><pre>[{&quot;name&quot;:&quot;Toyota Yaris&quot;,&quot;description&quot;:&quot;A smooth ride&quot;,&quot;id&quot;:1,&quot;type&quot;:&quot;Automatic&quot;,&quot;fuel_type&quot;:&quot;Petrol&quot;,&quot;manufacturer&quot;:&quot;Toyota&quot;}]</pre><pre>#<strong>bash</strong></pre><pre>$ yarn start<br>[nodemon] starting `node app.js`<br>Cars API listening on port 3000!<br>/cars/1<br>1<br>Query succeeded.<br>1 &#39;Toyota Yaris&#39; &#39;Automatic&#39;<br>GET /cars/1 200 47.279 ms - 126</pre><p>From here you can add additional routes to search by car name, car type and look to implement POSTing to the DB. Hint: this will be similar to our <strong>loadCarData.js </strong>file, using DynamoDBâ€™s <strong>PutItem </strong>function.</p><p>Next time Iâ€™ll look to deploy our sample app to AWS Elastic Beanstalk along with AWS DynamoDB and implement a build pipeline with CircleCI and testing usingÂ Postman.</p><p>If you wish, you can check all the code out here, at the example <a href="https://github.com/jameshamann/node-dynamo-db-example">GithubÂ Repo</a>.</p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7e342a934a24" width="1" height="1"><hr><p><a href="https://medium.com/quick-code/node-js-restful-api-with-dynamodb-local-7e342a934a24">Node.js RESTful API with DynamoDB Local</a> was originally published in <a href="https://medium.com/quick-code">Quick Code</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></p> </div> </div> <p style="text-align: center"><a class="waves-effect waves-light btn green darken-2" target="_blank" href="https://medium.com/@jameshamann/"><i class="material-icons right">library_books</i>Read more at Medium</a></p> </div> <script type="text/javascript" src="/assets/js/jquery-3.2.1.min.js"></script> <script type="text/javascript" src="/assets/js/materialize.min.js"></script> <script src="/assets/js/init.js"></script> </body> <footer class="page-footer"> <div class="footer-copyright" style="padding-left: 30px"> <i class="material-icons" style="padding-right:5px">copyright</i><p>2017 Copyright James Hamann | All rights reserved</p> </div> </footer> </html>