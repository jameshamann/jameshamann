<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" type="text/css" href="/assets/css/materialize.css"> <link rel="stylesheet" href="https://cdn.rawgit.com/konpa/devicon/df6431e323547add1b4cf45992913f15286456d3/devicon.min.css"> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> <title>James Hamann</title> <script type="text/javascript">screen.width<=699&&(document.location="mobile.html");</script> </head> <h2 style="text-align:center"> Latest Blog Posts </h2> <p style="text-align:center;"><a class="waves-effect waves-light btn green darken-2" target="_blank" href="https://medium.com/@jameshamann/"><i class="material-icons right">library_books</i>Read more at Medium</a></p> <div class="fixed-action-btn horizontal"> <a class="btn-floating btn-large waves-effect waves-default pulse" href="/"> <i class="material-icons">arrow_back</i> </a> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless GraphQL React App using AWS Amplify — Part One</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*UZtf6EZ8RIeLZm8dU1tjuQ.jpeg"/></figure><h3>Serverless GraphQL React App using AWS Amplify — Part One</h3><p>Previously I’ve posted about creating a <a href="https://blog.usejournal.com/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a"><strong>Serverless React Web App using AWS Amplify</strong></a><strong>. </strong>After playing around with AppSync in Amplify and enjoying the results, I thought it’d be useful to start a series of posts on how to setup a simple Serverless GraphQL React App using Amplify.</p><p>If you want to understand more about GraphQL, you can read my previous post on it <a href="https://medium.com/datadriveninvestor/a-brief-introduction-into-graphql-62fcb0eb491d">here</a>.</p><p>I’ll be keeping things pretty generic and going with the same old recipe of a simple inventory app, where we can <strong>Create, Read, Update </strong>and <strong>Delete (CRUD) </strong>items.</p><h4>Getting Started</h4><p>First things first, you’re going to need to make sure you have completed the below before starting:</p><ul><li>Create AWS Account</li><li>Install <a href="https://github.com/facebook/create-react-app#creating-an-app">Create-React-App</a></li><li>Install <a href="https://aws-amplify.github.io/docs/">AWS Amplify</a></li></ul><p>Now we’re ready to kick on!</p><pre>#bash</pre><pre>$ yarn create react-app my-app</pre><pre>[...]<br>✨  Done in 45.41s.</pre><pre>$ cd my-app</pre><pre>$ yarn start</pre><p>If everything was installed and setup correctly, you’ll see the default react page.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oFTixyf4bjbn8NbJrNUtEQ.png"/></figure><p>Great, now let’s get Amplify setup. The CLI tool makes it so easy, all you need to do is follow the prompts and everything else will fall into place!</p><pre><strong>#bash</strong></pre><pre>$ amplify init<br>Note: It is recommended to run this command from the root of your app directory<br>? Enter a name for the project serverlessGraphqlApp<br>? Choose your default editor: Atom Editor<br>? Choose the type of app that you&#39;re building javascript<br>Please tell us about your project<br>? What javascript framework are you using react<br>? Source Directory Path:  src<br>? Distribution Directory Path: build<br>? Build Command:  yarn build<br>? Start Command: yarn start<br>Using default provider awscloudformation<br>[...]</pre><pre>✔ Successfully created initial AWS cloud resources for deployments.</pre><pre>Your project has been successfully initialized and connected to the cloud!<br></pre><p>You’ll notice this creates an <strong>amplify </strong>folder which contains two other folders, one will resemble your local backend and the other will replicate what’s currently live in the cloud. As we continue building our app, keep an eye on the folder, it’ll provide a good snapshot of what back-end resources we’re using.</p><p>That’s the basic setup complete, next we’ll scaffold our front-end together.</p><h4>Front-End Setup</h4><p>In order to keep things simpler for the purpose of this post, I’ve chosen to use the React UI framework, <a href="https://material-ui.com/">Material-UI</a>. This will help us scaffold our app’s components together quite quickly and provide a nice, clean UI to work with. Feel free to use any UI framework you like, though.</p><p>Let’s start by installing material-ui, making some sub folders for our screens and components and creating two new files: <strong>home.js </strong>and <strong>appNavBar.js </strong>in their respective directories.</p><pre><strong>#bash</strong></pre><pre>$ yarn add @material-ui/core<br>[...]<br>$ mkdir src/screens<br>$ mkdir src/components<br>$ touch src/screens/home.js<br>$ touch src/components/appNavBar.js</pre><p>Using the examples over at material-ui, our <strong>appNavBar</strong>.js file should look like the below.</p><pre><strong>#src/components/appNavBar.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import PropTypes from &#39;prop-types&#39;;<br>import { withStyles } from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/styles&#39;;<br>import AppBar from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/AppBar&#39;;<br>import Toolbar from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/Toolbar&#39;;<br>import Typography from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/Typography&#39;;</pre><pre>const styles = theme =&gt; ({<br>  button: {<br>    margin: theme.spacing.unit,<br>    float: &#39;right&#39;,<br>  },<br>  root: {<br>    flexGrow: 1<br>  },<br>  grow: {<br>   flexGrow: 1,<br> },<br>});</pre><pre>class AppNavBar extends Component {</pre><pre>render(){<br>    const { classes } = this.props;<br>    return (<br>      &lt;div className={classes.root}&gt;<br>        &lt;AppBar position=&quot;static&quot; color=&quot;default&quot;&gt;<br>          &lt;Toolbar&gt;<br>            &lt;Typography variant=&quot;h6&quot; color=&quot;inherit&quot; className={classes.grow}&gt;<br>              Items<br>            &lt;/Typography&gt;<br>          &lt;/Toolbar&gt;<br>        &lt;/AppBar&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>AppNavBar.propTypes = {<br>  classes: PropTypes.object.isRequired,<br>};</pre><pre>export default withStyles(styles)(AppNavBar);</pre><p>Next, we’ll import our <strong>AppNavBar</strong> component into our newly created <strong>home.js </strong>file.</p><pre><strong>#src/screens/home.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import AppNavBar from &#39;../components/appNavBar&#39;</pre><pre>class Home extends Component {<br>  render() {<br>    return (<br>      &lt;AppNavBar /&gt;<br>    );<br>  }<br>}</pre><pre>export default Home;</pre><p>Now, let’s import our <strong>Home</strong> screen into our main <strong>App.js </strong>file.</p><pre><strong>#src/App.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import logo from &#39;./logo.svg&#39;;<br>import &#39;./App.css&#39;;<br>import Home from &#39;./screens/home&#39;</pre><pre>class App extends Component {<br>  render() {<br>    return (<br><strong>      &lt;Home /&gt;<br></strong>    );<br>  }<br>}</pre><pre>export default App;</pre><p>Finally, let’s add a dialog form that will serve as our <strong>AddItem </strong>form.</p><p>Using Material UIs Dialog component, we’ll create a form with fields for an item’s name, price, description and rating.</p><pre><strong>#bash </strong></pre><pre>$ touch src/components/addItem.js</pre><pre>--------------------------------------------------------------------<br>#<strong>addItem.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import TextField from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/TextField&#39;;<br>import Dialog from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/Dialog&#39;;<br>import DialogActions from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/DialogActions&#39;;<br>import DialogContent from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/DialogContent&#39;;<br>import DialogContentText from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/DialogContentText&#39;;<br>import DialogTitle from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/DialogTitle&#39;;<br>import AddIcon from &#39;<a href="http://twitter.com/material">@material</a>-ui/icons/Add&#39;;<br>import Button from &#39;<a href="http://twitter.com/material">@material</a>-ui/core/Button&#39;;</pre><pre>class AddItem extends Component {</pre><pre>state = {<br>    open: false,<br>  };</pre><pre>handleClickOpen = () =&gt; {<br>    this.setState({ open: true });<br>  };</pre><pre>handleClose = () =&gt; {<br>    this.setState({ open: false });<br>  };</pre><pre>handleChange = name =&gt; event =&gt; {<br>    this.setState({<br>      [name]: event.target.value,<br>    });<br>  };</pre><pre>render() {<br>      return (<br>      &lt;div style={{display: &#39;flex&#39;, flexWrap: &#39;wrap&#39;}}&gt;<br>      &lt;Button variant=&quot;fab&quot; mini color=&quot;inherit&quot; aria-label=&quot;Add&quot; onClick={this.handleClickOpen}&gt;<br>        &lt;AddIcon /&gt;<br>      &lt;/Button&gt;</pre><pre>&lt;Dialog<br>          open={this.state.open}<br>          onClose={this.handleClose}<br>          aria-labelledby=&quot;form-dialog-title&quot;<br>        &gt;<br>          &lt;DialogTitle id=&quot;form-dialog-title&quot;&gt;Add a New Item&lt;/DialogTitle&gt;<br>          &lt;DialogContent&gt;<br>            &lt;DialogContentText&gt;</pre><pre>&lt;/DialogContentText&gt;<br>              &lt;TextField<br>                style={{marginRight: 10}}<br>                id=&quot;beerName&quot;<br>                label=&quot;Name&quot;<br>                type=&quot;string&quot;<br>                onChange={this.handleChange(&#39;itemName&#39;)}<br>              /&gt;<br>              &lt;TextField<br>                style={{marginRight: 10}}<br>                id=&quot;beerABV&quot;<br>                label=&quot;ABV%&quot;<br>                type=&quot;number&quot;<br>                onChange={this.handleChange(&#39;itemPrice&#39;)}<br>              /&gt;<br>              &lt;TextField<br>                style={{marginRight: 10}}<br>                id=&quot;beerRating&quot;<br>                label=&quot;Rating&quot;<br>                type=&quot;number&quot;<br>                onChange={this.handleChange(&#39;itemRating&#39;)}<br>              /&gt;<br>              &lt;TextField<br>                style={{marginTop: 10}}<br>                multiline<br>                id=&quot;beerDescription&quot;<br>                label=&quot;Description&quot;<br>                type=&quot;string&quot;<br>                rows=&quot;4&quot;<br>                fullWidth<br>                onChange={this.handleChange(&#39;itemDescription&#39;)}<br>              /&gt;<br>          &lt;/DialogContent&gt;<br>          &lt;DialogActions&gt;<br>            &lt;Button onClick={this.handleClose} color=&quot;primary&quot;&gt;<br>              Cancel<br>            &lt;/Button&gt;<br>            &lt;Button onClick={this.handleSubmit} color=&quot;primary&quot;&gt;<br>              Add Item<br>            &lt;/Button&gt;<br>          &lt;/DialogActions&gt;<br>        &lt;/Dialog&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default AddItem;</pre><p>Looking a little closer, the functions <strong>handleClickOpen </strong>and <strong>handleClose </strong>are pretty self explanatory. The function <strong>handleChange </strong>also does exactly what it says, it handles the change of each text field value. To keep a track of each attribute’s value, we pass it’s name as the argument. Using this method, we can add as many fields as we like, as long as we pass the name of that field as an argument when calling the function.</p><p>Lastly, let’s make sure to import our <strong>AddItem </strong>component in our <strong>AppNavBar</strong>.</p><pre><strong>#src/components/appBar.js</strong></pre><pre>[...]<br><strong>import AddItem from &#39;./addItem&#39;</strong></pre><pre>class AppNavBar extends Component {</pre><pre>render(){<br>    const { classes } = this.props;<br>    return (<br>      &lt;div className={classes.root}&gt;<br>        &lt;AppBar position=&quot;static&quot; color=&quot;default&quot;&gt;<br>          &lt;Toolbar&gt;<br>            &lt;Typography variant=&quot;h6&quot; color=&quot;inherit&quot; className={classes.grow}&gt;<br>              Items<br>            &lt;/Typography&gt;              <br><strong>            &lt;AddItem /&gt;<br></strong>          &lt;/Toolbar&gt;<br>        &lt;/AppBar&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>AppNavBar.propTypes = {<br>  classes: PropTypes.object.isRequired,<br>};</pre><pre>export default withStyles(styles)(AppNavBar);</pre><p>If all is well, our groundbreaking app should look like this…</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2FYAYKjYAppQ8YiJrxiZ%2Ftwitter%2Fiframe&amp;url=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FYAYKjYAppQ8YiJrxiZ%2Fgiphy.gif&amp;image=https%3A%2F%2Fi.giphy.com%2Fmedia%2FYAYKjYAppQ8YiJrxiZ%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy" width="435" height="271" frameborder="0" scrolling="no"><a href="https://medium.com/media/8a40f2b5169d119e3c3d9c320650daf5/href">https://medium.com/media/8a40f2b5169d119e3c3d9c320650daf5/href</a></iframe><p>Awesome, great work!</p><p>In Part 2 we’ll be looking at implementing the simple CRUD functions as well as further developing the layout and UI of our app.</p><p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8ff92d3705e7" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi Jason I’m currently in the process of rewriting/updating the post — the reason this is occurring…</b></h4> <p style="text-align:justify"><p>Hi <a href="https://medium.com/u/683c9ff5cc8c">Jason</a> I’m currently in the process of rewriting/updating the post — the reason this is occurring is because awsmobile has somewhat been rebranded into <a href="https://aws-amplify.github.io/">AWS Amplify</a>, it’s very similar but some of what’s written here needs to be updated.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5c44b4740656" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>SSL Certificates with Rails, AWS Elastic Beanstalk and Let’s Encrypt</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7RGQw7wVDroPkv-U_ZW3Cw.png"/></figure><p>Having recently worked on an App hosted in Elastic Beanstalk, I realised it was difficult to install an SSL Certificate, unless your environment was setup with a load balancer.</p><h4>What is load balancing?</h4><p>Load Balancing automatically distributes incoming requests/traffic across multiple targets, for example EC2 instances. This increases performance and reduces downtime, which is great, but if you’re still starting out, prototyping or setting up a staging site, it might be overkill.</p><p>As well as this, there’s the cost factor. Roughly speaking, if you configure Elastic Beanstalk to use load balancing, it’ll cost around £20-£30 per month, depending on how many instances you choose.</p><p>Obviously, nothing stops you from SSHing into your instance and installing the certificate manually, but if you’re not to experienced with linux or devops it can become a bit confusing.</p><h4>Setting up your Rails App for SSL with Elastic Beanstalk</h4><p>Firstly, we’re going to need to create a new directory within the root our Rails App (if it doesn’t exist already) <strong>.ebextensions</strong> and create a new file <strong>certbot.config. </strong>Within this file, any script and commands we write will be executed during deployment. Depending on what you want to achieve, you’re able to run commands at any stage of the deployment and build cycle. Please note the below config is only applicable for nginx servers, other servers may require slightly different configs.</p><p>Copy and paste the below snippet into your new file, <strong>ensure the spacing/indentation remains the same.</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1a72d91198b6f0fc229243584156cddd/href">https://medium.com/media/1a72d91198b6f0fc229243584156cddd/href</a></iframe><p>Let’s quickly breakdown what’s happening in this file.</p><p>First we add port 443, used for SSL connections, to the security group. Next, we create a custom nginx config file, containing the server’s configuration for port 443 and state the location of the SSL Certificate, as well as the location of our app on the server. Lastly, we run a suite of commands which installs certbot and requests a new certifcate for domain <strong>certdomain </strong>and saves them in the location stated in our SSL config.</p><p>Let’s Encrypt issued certificates tend to last around 3 months, but certbot will automatically check the renewal date and renew your certificate if it’s coming up to renewal.</p><p>I’ve personally had a few issues with this in the past and have setup a cron job to run on my eb instance every week checking for renewals. If you’re deploying regularly, it shouldn’t be an issue but I’d suggest keeping an eye on your certificate expiration date to see if certbot is renewing when it’s supposed to. You can do this quite easily in Chrome by clicking the padlock in the URL bar and then the <strong>Certificate </strong>button. A drop down will appear with info on your certificate and it’s expiration date.</p><p>Before running a new deployment you will be required to <strong>change line 58 to your email address</strong>. As well as this, you will need to <strong>set the environment variable certdomain equal to your domain, eg: example.com</strong>. The latter can be done on the Elastic Beanstalk Configuration Dashboard, under the Software Tab.</p><p>Once this is completed and your app has successfully deployed with all the updates, you should be able to visit your new https site. If this is still not working, you might need to reload ngnix. To do this, SSH into your instance and run:</p><pre>#Your EB Instance</pre><pre>$ <strong>sudo service nginx reload</strong><br>Reloading nginx:                                           [  OK  ]</pre><p>All done! You’ve successfully installed an SSL certificate on a Single Instance Elastic Beanstalk App.</p><p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8b047d527a60" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>A brief introduction into GraphQL</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*di7bhLC_gIwXRtEBiOvwSg.png"/></figure><p>I know I’m a bit late to the GraphQL party but having had sometime recently, I thought I’d play around with it on a new side project I’m working on. Initially I found myself a bit lost, but after reading through the <a href="https://graphql.org/">sites</a> docs and understanding it’s purpose and the problem it solves, it made so much sense.</p><h4>What exactly is GraphQL?</h4><p>Created in 2012 and open sourced by Facebook in 2015,</p><blockquote>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data.</blockquote><p>Essentially it’s a library that describes how we retrieve data from the server to the client. Some of the main features are:</p><ul><li>A Schema to describe your data</li><li>Retrieve as many or as little resources as you require in a single request</li><li>Continually develop your API without versioning</li></ul><p>Let’s explore these features in a little more depth.</p><h4>Schema</h4><p>A huge benefit I found from the outset was being able to define my data, it’s types and relationships in a single Schema document. GraphQL is strongly typed, which means everything in the query is checked before an operation is executed. This ensures the syntax, data types and query are all valid before execution.</p><pre><strong>#yourSchema.graphql</strong></pre><pre>type Item {<br>  id: ID!<br>  name: String!<br>  comments: [Comment] <br>  description: String<br>}</pre><pre>type Comment {<br>  id: ID!<br>  content: String!<br>  photo: Photo<br>}</pre><p>This is a basic example of a Schema document. There are five default scalar types that come out of the box, those are <strong>String, Float, Integer, Boolean </strong>and <strong>ID. </strong>As well as these default types, you’re able to create custom scalar types, for example if you had a <strong>Date</strong> or <strong>Time </strong>data type you could define a custom scalar to be used in your Schema. The <strong>! </strong>denotes whether a field is required or not.</p><p>Having a Schema provides a useful reference of your data and ensures there’s no ambiguity.</p><h4>Retrieve as many or as little resources as you require in a single request</h4><p>This is one of the features which is incredibly useful. The example query below will retrieve a list of all the items.</p><pre>query {<br>    items {<br>      id<br>      name<br>      description<br>   }<br>};</pre><p>However, say we’re on a list view, we might only want the name and description.</p><pre>query {<br>    items {<br>      name<br>      description<br>  }<br>};</pre><p>This allows us to query and <strong>retrieve only the data we require, </strong>making it easier, quicker and more efficient to work with. It also reduces over-fetching.</p><p>As well as this, we have the ability to fetch the comments relating to that item with a few extra lines in our query request.</p><pre>query {<br>    items {<br>      id<br>      name<br>      comment {<br>        id<br>        content<br>        photo<br>      }<br>      description<br>    }<br>};</pre><p>Now let’s imagine we’ve got a complex dashboard view where we need to fetch multiple attributes from multiple resources. No problem!</p><pre>query {<br>    items {<br>      name<br>      description<br>    }<br>    comments {<br>      content <br>    }<br>    todos {<br>     todo<br>     description <br>    }<br>};</pre><p>This single request will fetch only the desired attributes we’ve specified, from the multiple resources listed. It negates the need to perform many http requests to receive all the data you require, unlike REST APIs</p><h4>Continually develop your API without versioning</h4><p>REST APIs require versioning when deprecating or introducing new fields, as the server dictates the response and therefore the client needs to be able to process that response. The key difference with GraphQL is that the query itself dictates the response, as highlighted above, therefore the client will be compatible regardless of what new fields are added or deprecated.</p><h4>Pros</h4><ul><li>Rapid prototyping and product development</li><li>Reduces over and under fetching of resources</li><li>Allow your API to evolve continuously without versioning</li><li>Strongly Typed — GraphQL can ensure the syntax, data types and query are valid before execution</li></ul><h4>Cons</h4><ul><li>Caching can be tricky</li><li>For more complicated use cases, queries can become bloated, nested and complex</li><li>Typical Rate Limiting is a little different, as with one endpoint, and with every query being different, the operation can either be expensive or cheap.</li></ul><h4>Conclusion</h4><p>GraphQL offers an alternative way to architect your client — server relationship, it helps decouple your API from it’s consumers and makes it easy to iterate over your product without the fear of introducing breaking changes.</p><p>In a future post I’ll be taking a look at setting up a Serverless GraphQL React app in AWS and demonstrating some more of GraphQL’s features and benefits.</p><p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=62fcb0eb491d" width="1" height="1"><hr><p><a href="https://medium.com/datadriveninvestor/a-brief-introduction-into-graphql-62fcb0eb491d">A brief introduction into GraphQL</a> was originally published in <a href="https://medium.com/datadriveninvestor">Data Driven Investor</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify — Part Three</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nIEoRXRsVjf9C-CIvK8uEQ.jpeg"/></figure><p>Following on from my previous post,<a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-two-d740ee8e7456"> Serverless React Web App with AWS Amplify — Part Two</a>, today we’ll be <strong>adding authentication and looking at deployment and distribution</strong> in the final part of this mini series.</p><p><strong>All source code for the project can be found </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>At the moment our app should look somewhat similar to the below, with the ability to add/edit/delete items.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*R59qZ3CoSiPQ9otvyH8z4g.png"/><figcaption>Current App</figcaption></figure><h4>User Authentication</h4><p>Let’s start by enabling the <strong>user-signin </strong>feature using the <strong>awsmobile CLI</strong>.</p><pre>#bash</pre><pre>$ awsmobile user-signin enable --prompt<br>? Sign-in is currently disabled, what do you want to do next <br>Enable sign-in with default settings </pre><pre>#Choose default settings </pre><pre>$ awsmobile push<strong> #push your changes to the cloud</strong></pre><p>To keep things simple, we’ll use Amplify’s <strong>withAuthenticator </strong>component to handle our auth flow. This component wraps our entire app up and renders a complete sign up/sign in UI, which is customisable through the AWS Mobile Hub. If you wish, you can also handle the Sign In/Sign Up process using the <strong>Auth </strong>component, which gives you greater flexibility of the entire auth flow.</p><pre><strong># App.js </strong></pre><pre>[...]</pre><pre>import { withAuthenticator } from &#39;aws-amplify-react&#39;</pre><pre>[...]</pre><pre>export default<strong> withAuthenticator(App, true);</strong></pre><p>After adding the above code to your <strong>App.js </strong>file, reload your app and it should look something like this. The added <strong>true</strong> ensures a sign out button is rendered.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jcbTNpCNnFk4SVewgVazDw.png"/><figcaption>Sign In/Sign Up Page</figcaption></figure><p>Try going through the Sign Up flow, you’ll notice MFA (multi-factor auth) is enabled by default, so when putting your mobile number in you’ll get a confirmation code to use each time to sign in/sign up. It’s probably overkill for an app like this, but it does improve security. Once going through the flow and signing in with your newly created user account, you should be directed to your app’s home page.</p><p>That’s user authentication done! Pretty simple isn’t it? You can also view all users signed up to your app by heading over to the User Pool on Cognito and clicking on <strong>Users and Groups. </strong>The easiest way to get to your Cognito Pool is to open up the Mobile Hub, head to the User Sign In card and click “Edit in Cognito.”</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2eo_a_HReunkQGCtOWzC9A.png"/><figcaption>AWS Mobile Hub, Cognito Pool Settings</figcaption></figure><p><strong>Please remember, whenever you make changes in the hub/on the web app, be sure to pull the changes back into your local project. </strong>I’ve caused myself so many stupid issues by not doing this and your project gets real messy, real fast and can get out of sync, so make sure your local copy is always in sync with the cloud.</p><h4>Federated Identity Login</h4><p>Now we’ve added user auth, but most modern web apps incorporate some form of social login, so let’s add <strong>Google Sign-In</strong> to ours.</p><p>You’ll need to get a <strong>google_client_id</strong>. It’s fairly straight forward and Google provide easy to follow instructions <a href="https://developers.google.com/identity/sign-in/web/sign-in">here</a>. When asked what you’re developing for, choose <strong>Web Server </strong>and then<strong> </strong>add the <strong>Authorized JavaScript</strong> <strong>origins </strong>as <a href="http://localhost:3000"><strong>http://localhost:3000</strong></a><strong>. </strong>Be sure to keep this tab open for the time being, as we’ll be going back and fourth retrieving the Client ID as well as changing some settings later on.</p><p>Next, we’ll need to add our Client ID to our Cognito Pool, this can be done by configuring the <strong>user-signin</strong> feature, using the <strong>awsmobile</strong> <strong>CLI</strong> tool.</p><pre><strong>#bash </strong></pre><pre>→ awsmobile user-signin configure</pre><pre>? Sign-in is currently enabled, what do you want to do next Go to advance settings<br>? Which sign-in method you want to configure Google sign-in (currently disabled)<br>? Google Web App Client ID <strong>xxxxYOURCLIENTIDxxxxx</strong>.apps.googleusercontent.com<br>? Google Android Client ID <strong>xxxxYOURCLIENTIDxxxxx</strong>.apps.googleusercontent.com<br>? Google iOS Client ID <strong>xxxxYOURCLIENTIDxxxxx</strong>.apps.googleusercontent.com</pre><pre>$ <strong>awsmobile push //don&#39;t forget to push your changes, otherwise it won&#39;t work. </strong></pre><p>Finally, we’ll need to tweak our code to include our <strong>google_client_id, </strong>so that the <strong>withAuthenticator </strong>component can use it. As long as you restrict the origins from the Google Dev Console, as we did earlier, there isn’t a specific need to hide this ID, so we don’t need to worry about loading environment variables just yet.</p><p>The first thing we need to change is in our <strong>App.js </strong>file. We revert back to exporting the App as it is, not wrapping it in the <strong>withAuthenticator </strong>component.</p><pre>#<strong>App.js </strong></pre><pre>[...]</pre><pre><strong>export default App;</strong></pre><p>Next, in our <strong>index.js </strong>file, we import <strong>App.js </strong>and create a new <strong>constant</strong> named <strong>AppWithAuth, </strong>which is essentially what we had previously in our <strong>App.js </strong>file. We then create another constant called <strong>federated </strong>and set this equal to a JSON config containing our <strong>google_client_id. </strong>Lastly, we use our constant <strong>AppWithAuth </strong>within the render function and include our <strong>google_client_id </strong>from the <strong>federated </strong>constant we just created<strong>.</strong></p><pre>#<strong>index.js</strong></pre><pre><strong>import App from &#39;./App&#39;;</strong></pre><pre><strong>import { withAuthenticator } from &#39;aws-amplify-react&#39;</strong></pre><pre><strong>const AppWithAuth = withAuthenticator(App, true);</strong></pre><pre><strong>const federated = {<br>  google_client_id: &#39;xxxxxYOURCLIENTIDxxxxxx.apps.googleusercontent.com&#39;,<br>};</strong></pre><pre>ReactDOM.render(<strong>&lt;AppWithAuth federated={federated}/&gt;</strong>, document.getElementById(&#39;root&#39;));<br>registerServiceWorker();</pre><p>After reloading your app, you should be able to successfully login using Google!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/918/1*Htm6pZz-9Ui5JllsEIvbog.png"/><figcaption>Our new sign in/sign up up form with Google Sign in Button</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LQOd4fa97FA4BDHAU3VlTQ.png"/><figcaption>After successful Google Login, the user’s name is displayed on the header with a Sign Out button.</figcaption></figure><p>The process for adding Facebook/Amazon Logins is pretty much the same, you’d just need to acquire a client ID from their developer dashboard.</p><p>That’s it for Authentication! We successfully added a sign in/sign up form and incorporated Google Login. It’s still quite rough around the edges and could do with some styling, but functionality wise it’s pretty much there.</p><h4>Deployment and Distribution</h4><p>Let’s make sure people can actually access and use our app by deploying it and distributing it. AWS Amplify includes one simple command that sets everything up for deployment and distribution.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile publish</pre><pre>File sizes after gzip:</pre><pre>379.32 KB  build/static/js/main.c1215b8f.js<br>  99.09 KB   build/static/css/main.340cfbbb.css</pre><pre>The project was built assuming it is hosted at the server root.<br>You can control this with the homepage field in your package.json.<br>For example, add this to build it for GitHub Pages:</pre><pre>&quot;homepage&quot; : &quot;<a href="http://myname.github.io/myapp">http://myname.github.io/myapp</a>&quot;,</pre><pre>The build folder is ready to be deployed.<br>You may serve it with a static server:</pre><pre>yarn global add serve<br>  serve -s build</pre><pre>Find out more about deployment here:</pre><pre><a href="http://bit.ly/2vY88Kr">http://bit.ly/2vY88Kr</a></pre><pre>Successful!<br>your application is published and hosted at:<br><a href="http://serverlesswebappexam-hosting-mobilehub-1099236211.s3-website.eu-west-2.amazonaws.com">http://serverlesswebappexam-hosting-mobilehub-1099236211.s3-website.eu-west-2.amazonaws.com</a><br>your application is also distributed through aws CloudFront<br><a href="https://d2x9wan2jbunv.cloudfront.net">https://d2x9wan2jbunv.cloudfront.net</a></pre><p>This command will build your app and upload the files to a s3 bucket, configured to host static websites. It’ll also go one step further and distribute this through their Global CDN, CloudFront, making your site quicker and easier to access for users all over the world!</p><p>Once uploading has finished, you’ll notice two URLS, one is the bucket URL and one is the cloudfront distribution. If you try logging in on either you’ll get this error.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iwqEIiKvRuX_ACBeTtDQLw.png"/><figcaption>Redirect_URI_Mismatch error — Update the Authorised Origins within the Google Cloud API Settings</figcaption></figure><p>This occurs because the request is coming from a domain that hasn’t been approved, so let’s quickly add our new CloudFront URL to the <strong>Authorised Javascript origins, </strong>in the Google Cloud API Settings.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wH_pzN_rIx8A5EeGGpYxvg.png"/></figure><p>After adding this and saving, you should be able to login successfully using Google.</p><p>As it’s quite simple to do, I thought it’d be useful to finish by showing you how to point your new app to your personal domain, if you have one. In order to do this, you’ll need your domain name in <a href="https://aws.amazon.com/route53/?sc_channel=PS&amp;sc_campaign=acquisition_UK&amp;sc_publisher=google&amp;sc_medium=ACQ-P|PS-GO|Brand|SU|Delivery|Route%2053|UK|EN|Text&amp;sc_content=route_53_e&amp;sc_detail=route%2053%20aws&amp;sc_category=route_53&amp;sc_segment=285292336467&amp;sc_matchtype=e&amp;sc_country=UK&amp;s_kwcid=AL!4422!3!285292336467!e!!g!!route%2053%20aws&amp;ef_id=WWyBdQAABRdHCY3h:20180813110206:s">AWS Route 53</a>.</p><p>Firstly, we need to configure our Cloudfront Distribution to include our alternate domain name. Open up the CloudFront Dashboard, locate your distribution and update the <strong>Alternate Domain Names. </strong>I’ll be using the domain <strong>serverlessreactexample.jameshamann.com.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hgffLxZz6lMyzd36wDFDdQ.png"/></figure><p>You’ll also need to choose <strong>Custom SSL Certificate </strong>and select the correct certificate for your domain. Setting up a Certificate in AWS Certificate Manager is incredibly easy and straightforward, you can follow the docs <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">here</a>. One thing to note, make sure the certificates you create <strong>are stored in US-East (N. Virginia) </strong>in order to access them from CloudFront. You can always check what region you’re in by checking the top right of the app bar, next to your name. When you’re all done, hit <strong>Yes, Edit</strong>. Now we wait, updates to CloudFront distributions can take some time, so take a little break.</p><p>Once your changes are deployed, head over to the Route 53 Dashboard and click on your registered domain. Next, click <strong>Create Record Set </strong>and fill in your URL in the <strong>Name </strong>field. You’ll then need to change <strong>Alias </strong>to <strong>Yes</strong> and copy your CloudFront URL into the <strong>Alias Target </strong>field.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/838/1*90g_YRIltD4f6A_zSpE1bg.png"/></figure><p>Hit <strong>Create </strong>and wait for your changes to go live! The time taken can vary so don’t worry if it’s not instant, go grab a coffee or beer and come back later to check. <strong>Don’t forget to add your new domain name to the Authorised Javascript Origins, in your Google Cloud API settings, to ensure Google Login works correctly.</strong></p><p>Congrats! You’ve now got a fully functioning, albeit a bit rough looking, Serverless React Web App! Now you have a great foundation to move forward with, allowing you to build, test and deploy your app in nice, quick iterations.</p><h4>Further Development</h4><p>There’s quite a few different things you can do to further enhance your app. Here’s a few to help get the ideas bubbling:</p><ul><li>Adding a CI/CD Pipeline with CircleCI, <a href="https://blog.cloudboost.io/react-with-circleci-aws-s3-and-aws-cloudfront-844a1b2c75c9">check one of my previous posts on this topic</a>.</li><li>Cleaning up the Views, ensuring the Sign out button is rendered on the correct App bar.</li><li>Adding pictures using <a href="https://aws-amplify.github.io/amplify-js/media/storage_guide">Amplify’s storage feature.</a></li><li>Porting to Mobile using React Native — this is probably quite complex for now and would require rewriting some sections of the code, but if you’re up for a challenge give it a go!</li><li>Adding reviews/comments for users to leave on an item</li><li>Refine UI</li><li>Incorporate <a href="https://aws-amplify.github.io/amplify-js/media/interactions_guide">Amplify’s Chatbot feature</a>, making your app a little more interactive</li></ul><p>These are just a few ideas, but there’s lots more you can do to further develop and build new features.</p><p><strong>All source code for the project can be found </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d3f1a30176e8" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi Paweł Zubkiewicz thanks for reading!</b></h4> <p style="text-align:justify"><p>Hi <a href="https://medium.com/u/cc11fb48d78b">Paweł Zubkiewicz</a> thanks for reading! I’m not sure about DynamoDB being publicly accessible? To access DynamoDB you need AWS Credentials, which have access to the correct resources. In this model, Amplify takes care of Authentication through the API module. All requests made are automatically signed with a AWS v4 signature, so any requests made to DynamoDB are secured through your API.</p><p>In answer to your second question, cognito is integrated into Amplify and pretty easy to setup. This is another way you could authenticate access, by creating a cognito group or user with the relevant permissions.</p><p>Hope this helps!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c52cd74f69fa" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Architecting your IoT App using Raspberry Pi and AWS</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dzxCfHB9TOC2o8DGXVf3qA.png"/></figure><p>Having done a lot of work with IoT sensors and Raspberry Pi recently, and considering it’s growing popularity, I thought I’d share how I went about architecting the infrastructure of the application, which can be applied to pretty much any IoT app you may be working on. Whilst the principals will apply to all major cloud hosting providers, I’ll be discussing AWS specific services.</p><h4>Project Outline</h4><p>A Smart Watering System for Farms/Plants, driven by data obtained from IoT Sensors and Forecasting APIs.</p><h4>Hardware Used</h4><ul><li>Raspberry Pi 3 Model B and SD Card loaded with Raspbian</li><li>Female to Female Dupont Wires</li><li>DHT11 Temp/Humidity Sensor</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*SEIzFKM352ssKoN1NkG5_w.jpeg"/></figure><p>The above is obviously still in the prototyping phase, which hopefully explains the mess. The end product will be cased in a watertight enclosure. In addition to the Temperature Sensor, the above picture also contains a Photo Resistor which captures information about light levels, but is currently not being used.</p><h4>Architecture Diagram</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/720/1*wFQ0HOSHDiyTTdkjhhu0Xw.png"/></figure><p>This diagram illustrates all of the components used and how they interact with each other. Let’s break it down a little further and understand what’s happening.</p><p>First the Pi IoT sensors publish raw data about the temperature, humidity, soil moisture and hours of sunlight. This is sent to an IoT topic via an MQTT message. This is a super light weight pub/sub messaging protocol designed specifically for devices in locations with limited network bandwidth, which is great for IoT. Next, an AWS IoT rule and action is created, which subscribes to the topic that the sensors are publishing to and sends these messages to a Kinesis data stream and DynamoDB Table.</p><p>Using Kinesis is entirely optional and dependant on what you’re building. The benefit of Kinesis is that it allows you the option of creating multiple delivery streams for your data. You could have one stream that delivers to a Lambda Function for record transformation, which writes to DynamoDB, or another stream for a Kinesis’ Analytics Application, even a delivery stream for an ElasticSearch app. It gives you the flexibility of being able to stream the data to multiple destinations for multiple uses. On the other hand, it can over complicate the app and be a bit of overkill in some cases, but it’s worth considering and making a final decision based on your app’s requirements. In this example the Kinesis Delivery Stream writes to an S3 Bucket, as an archive.</p><p>Once in DynamoDB, the application looks similar to a typical serverless application. The back-end logic is handled by Lambda and API Gateway and then sent to the client/Raspberry Pi. The React Front End is stored in an S3 bucket and distributed via CloudFront to the client. The client will display the sensor data as well as having the ability to control the water flow manually.</p><p>To automate the watering, the data from the sensors will be evaluated alongside data from Forecasting APIs and, based on certain criteria, the app will decide whether the area needs water and, if so, it would calculate the amount required based on all the data available. In the event watering is required a message will be published from Lambda to the Raspberry Pi on another topic, containing the “Open Valve” message as well as the amount of time to keep the valve open.</p><p>To add a level of interactivity, a chatbot could be included which would prompt the user the current status and give the user the option to interact back, querying past events. In addition to this, data visualisation tools could be used to create dashboards, historical data could even be loaded into a Machine Learning Model to predict the likelihood of watering and the optimum amount of water. There are lots of applications and ways in which you can expand a small project into something more, to gain experience using new tools and technologies.</p><p>Whilst this model explains the infrastructure in the context of this project, it is easily applied to any other IoT app you may have in mind. Connecting a Raspberry Pi to the cloud allows it to do so much more and gives you the opportunity to build new, different apps and explore different technologies.</p><p>In another post we’ll look at the specifics of setting this up within the AWS Environment and getting a Raspberry Pi Connected on the IoT Console.</p><p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b8b89e3ac39a" width="1" height="1"><hr><p><a href="https://medium.com/coinmonks/architecting-your-iot-app-using-raspberry-pi-and-aws-b8b89e3ac39a">Architecting your IoT App using Raspberry Pi and AWS</a> was originally published in <a href="https://medium.com/coinmonks">Coinmonks</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi Gerald Carter, sorry for the delay in getting back to you.</b></h4> <p style="text-align:justify"><p>Hi <a href="https://medium.com/u/36a1ef21a16f">Gerald Carter</a>, sorry for the delay in getting back to you. Looking at the error you mentioned above, it might be down to the command you used in your pipelines script or the name of your app/environment on AWS.</p><p>Using my example above, my elastic beanstalk app was called <strong>MyApplication </strong>and the environment I used was <strong>MyApplication-staging.</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/25d8f89a2b52e2311772f9f1df132cb5/href">https://medium.com/media/25d8f89a2b52e2311772f9f1df132cb5/href</a></iframe><p>On line 17 I mention the name of the Application, <strong>MyApplication</strong>.</p><p>On line 18, I mention the environment I wish to deploy my app to, <strong>MyApplicaton-staging.</strong></p><p>Both of these need to be setup before pushing. Double check what you called your app/environment in AWS and make sure this matches the build script.</p><p>Hope this helps!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=17eb9e04aef4" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify — Part Two</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*e-avRWEkg9mFn5BuWm4X4w.jpeg"/></figure><p>Following on from my previous post, <a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a">Serverless React Web App with AWS Amplify — Part One</a>, today we’ll layout the Front End and implement our basic CRUD Functions.</p><p><strong>All source code for the project can be found </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><h4>Front End</h4><p>To bootstrap the front end, we’ll use <a href="https://react.semantic-ui.com/introduction">React Semantic UI</a>, a simple UI Framework that provides a great set of React Components.</p><pre><strong>#bash</strong></pre><pre>$ yarn add semantic-ui-react<br>[...]<br>$ yarn add semantic-ui-css</pre><p>To get the CSS styling, you’ll need to import it in your <strong>index.js </strong>file, like so.</p><pre><strong># index.js</strong></pre><pre>import React from &#39;react&#39;;<br>import ReactDOM from &#39;react-dom&#39;;<br>import &#39;./index.css&#39;;<br>import App from &#39;./App&#39;;<br><strong>import &#39;semantic-ui-css/semantic.css&#39;<br></strong>import registerServiceWorker from &#39;./registerServiceWorker&#39;;</pre><pre>ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));<br>registerServiceWorker();</pre><p>Now let’s setup the folder structure. I like to keep screens in one folder and re-useable components in another. With that it mind, let’s make two new directories within the <strong>src </strong>directory.</p><pre>#<strong>bash</strong></pre><pre>$ mkdir src/components<br>$ mkdir src/screens</pre><pre># <strong>Project Layout</strong></pre><pre>├── README.md<br>├── awsmobilejs<br>│   ├── #current-backend-info<br>│   │   ├── aws-exports.js<br>│   │   ├── backend-details.json<br>│   │   ├── cloud-api<br>│   │   │   └── sampleLambda<br>│   │   │       ├── app.js<br>│   │   │       ├── lambda.js<br>│   │   │       ├── package-lock.json<br>│   │   │       └── package.json<br>│   │   └── mobile-hub-project.yml<br>│   └── backend<br>│       ├── cloud-api<br>│       │   └── sampleLambda<br>│       │       ├── app.js<br>│       │       ├── lambda.js<br>│       │       ├── package-lock.json<br>│       │       └── package.json<br>│       └── mobile-hub-project.yml<br>├── package.json<br>├── public<br>│   ├── favicon.ico<br>│   ├── index.html<br>│   └── manifest.json<br>├── src<br>│   ├── App.css<br>│   ├── App.js<br>│   ├── App.test.js<br>│   ├── aws-exports.js<br>│   ├── components<br>│   ├── index.css<br>│   ├── index.js<br>│   ├── logo.svg<br>│   ├── registerServiceWorker.js<br>│   └── screens<br>└── yarn.lock</pre><p>We’ll obviously need a few different views here, one to display all our items, one to create our items, one to edit/delete our items and one which shows a little more information about the item. We’ll use our <strong>App.js </strong>as the dashboard/index view for our app and add a navbar to navigate around the app.</p><pre><strong># App.js</strong></pre><pre>[...]</pre><pre>render() {<br>    return (<br>      &lt;Segment&gt;<br>        &lt;Menu&gt;<br>           &lt;Menu.Item name=&#39;home&#39;&gt; &lt;Icon name=&quot;shop&quot;/&gt;&lt;/Menu.Item&gt;<br>           &lt;Menu.Item name=&#39;Items&#39;/&gt;<br>           &lt;Menu.Item name=&#39;aboutUs&#39; /&gt;<br>         &lt;/Menu&gt;<br>      &lt;/Segment&gt;<br>    );<br>  }<br>}</pre><p>Now, let’s create an <strong>ItemDashboard</strong> page that shows all of our Item’s.</p><pre><strong>#bash</strong></pre><pre>touch src/screens/itemDashboard.js</pre><pre>--------------------------------------------------------------------</pre><pre>#<strong>itemDashboard.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import {Container, Card} from &#39;semantic-ui-react&#39;</pre><pre>class ItemDashboard extends Component {</pre><pre>render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;Container style={{padding: 10}}&gt;<br>          &lt;Card.Group&gt;<br>              &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    Item Name<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Item Price<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                  Description of the Item<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default ItemDashboard;</pre><p>Now we’ll import this into our <strong>App.js </strong>and render it within our <strong>&lt;Segment&gt;</strong> section.</p><pre># <strong>App.js</strong></pre><pre>[...]<br>  <br>render() {<br>    return (<br>      &lt;Segment&gt;<br>        &lt;Menu&gt;<br>           &lt;Menu.Item name=&#39;home&#39;&gt; &lt;Icon name=&quot;shop&quot;/&gt;&lt;/Menu.Item&gt;<br>           &lt;Menu.Item name=&#39;Items&#39;/&gt;<br>           &lt;Menu.Item name=&#39;aboutUs&#39; /&gt;<br>         &lt;/Menu&gt;<br><strong>         &lt;ItemDashboard /&gt;<br></strong>      &lt;/Segment&gt;<br>    );<br>  }<br>}</pre><p>At the moment our app should look nice and basic, something like this.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BxDPNJ33L4G073eyYITptg.png"/><figcaption>Basic Item Dashboard</figcaption></figure><p>Next, let’s implement a modal, which will serve as our create page.</p><p>We’ll use Semantic UI’s Modal and Form components to create the basic outline of our page. Let’s create a new file <strong>createItem.js </strong>which will live in our <strong>screens </strong>directory.</p><pre>#bash</pre><pre>$ touch src/screens/createItem.js</pre><pre>--------------------------------------------------------------------</pre><pre>#<strong>createItem.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import { Form, Modal, Button, Container } from &#39;semantic-ui-react&#39;</pre><pre>class CreateItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.state = {}<br>    this.handleChange = this.handleChange.bind(this);<br>  }</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre>handleSubmit(event) {</pre><pre>}</pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>    return (<br>        &lt;Modal trigger={&lt;Button onClick={this.handleOpen}&gt;+ Add Item&lt;/Button&gt;} closeIcon={true} open={this.state.modalOpen} onClose={this.handleClose}&gt;<br>          &lt;Modal.Header&gt;Add an Item&lt;/Modal.Header&gt;<br>          &lt;Modal.Content&gt;<br>            &lt;Form&gt;<br>              &lt;Form.Group unstackable widths={2}&gt;<br>                &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Enter Item Name...&#39; onChange={this.handleChange} /&gt;<br>                &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Enter Item Price...&#39; onChange={this.handleChange} type=&#39;number&#39; /&gt;<br>              &lt;/Form.Group&gt;<br>              &lt;Form.TextArea name=&#39;item_description&#39; label=&#39;Item Description&#39; placeholder=&#39;Add a Description of the Item...&#39; onChange={this.handleChange} /&gt;</pre><pre>&lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>            &lt;/Form&gt;<br>          &lt;/Modal.Content&gt;<br>        &lt;/Modal&gt;<br>      );<br>    }<br>  }</pre><pre>export default CreateItemModal;</pre><p>Most of the above code is recycled from examples on Semantic’s website. Studying the code, you’ll notice I’ve also added two functions that <strong>handleChange </strong>and <strong>handleSubmit </strong>within our form. This ensures all data is captured and submitted correctly, we’ll revisit both of these later when we connect everything together.</p><p>One thing I should mention, that I encountered during my own development, is a funky bug with the modal where half of it would be cut, off screen. The issue is tracked <a href="https://github.com/Semantic-Org/Semantic-UI-React/issues/2558">here</a> and the solution below worked perfectly, for me. Please do let me know if you run into any funky issues around the modal that aren’t resolved with the below.</p><p><strong>Proposed Workaround for Modal Issue:</strong></p><pre>#<strong>App.css</strong></pre><pre>.ui.page.modals.transition.visible {<br>    display: flex !important;<br>}</pre><pre># suggested by loopmode on GitHub Issues thread.</pre><p>Make sure to import and add the component in our <strong>ItemDashboard</strong>.</p><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>[...]</pre><pre>render() {<br>    return (<br>      &lt;div&gt;<br>       &lt;CreateItemModal/&gt;        <br>        &lt;Container style={{padding: 10}}&gt;<br>          &lt;Card.Group&gt;<br>              &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    Item Name<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Item Price<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                  Description of the Item<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );</pre><pre>[...]</pre><p>The finished <strong>createItemModal</strong> should look something like the below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3bkmnkqVbDb7PsbZ3gkqSg.png"/></figure><p>Looking good! Now let’s hook everything up so that we can actually create items that display on our Dashboard.</p><h4>Create</h4><p>Now that we have a form we’ll need to populate the function <strong>handleSubmit </strong>we wrote in earlier.</p><p>Similar to our get request previously, we’ll have to set the <strong>apiName</strong>, <strong>path,</strong> and this time, the body of what we’re sending. We’ll then use Amplify’s <strong>API </strong>component to post and log the contents to the console.</p><pre><strong>#createItem.js</strong></pre><pre><strong>import Amplify, { API } from &#39;aws-amplify&#39;;</strong></pre><pre>class CreateItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.state = {}<br>    this.handleChange = this.handleChange.bind(this);<br><strong>    this.handleSubmit = this.handleSubmit.bind(this);</strong></pre><pre>}</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre><strong>handleSubmit(event) {<br>    let apiName = &#39;sampleCloudApi&#39;;<br>    let path = &#39;/items&#39;;<br>    let newItem = {<br>      body: {<br>          name: this.state.itemName, price: this.state.itemPrice, description: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>    this.handleClose()<br>  }</strong></pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>    return (<br>        &lt;Modal trigger={&lt;Button onClick={this.handleOpen}&gt;+ Add Item&lt;/Button&gt;} closeIcon={true} open={this.state.modalOpen} onClose={this.handleClose}&gt;<br>          &lt;Modal.Header&gt;Add an Item&lt;/Modal.Header&gt;<br>          &lt;Modal.Content&gt;<br>            &lt;Form <strong>onSubmit={this.handleSubmit}</strong>&gt;<br>              &lt;Form.Group unstackable widths={2}&gt;<br>                &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Enter Item Name...&#39; onChange={this.handleChange}  <strong>value={this.state.itemName} </strong>/&gt;<br>                &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;£0.00&#39; onChange={this.handleChange}  <strong>value={this.state.itemPrice} </strong>/&gt;<br>              &lt;/Form.Group&gt;<br>             &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item    Description&#39; placeholder=&#39;Add a Description of the Item...&#39; onChange={this.handleChange}  <strong>value={this.state.itemDescription}</strong> /&gt;</pre><pre>&lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>            &lt;/Form&gt;<br>          &lt;/Modal.Content&gt;<br>        &lt;/Modal&gt;<br>      );<br>    }<br>  }</pre><pre>export default CreateItemModal;</pre><p>The <strong>handleSubmit </strong>function declares the variables necessary for posting to our backend. The body is formed of the values we set in each form element: <strong>itemName, itemPrice </strong>and <strong>itemDescription. </strong>The last thing we need to do is bind our function to our component so that it doesn’t show up undefined when we call our function.</p><p>Now let’s give the form a quick test to see if everything’s working.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/844/1*NEmUzgh6sEsxzqJoIeu_1A.png"/></figure><p>After submitting the form, with some content obviously, you should see the contents in the console, like above.</p><p>Great! However, this isn’t saving anywhere, we still need to configure our Database.</p><h4>DynamoDB Setup</h4><p>Earlier on we setup a Database with the default example setup, we’re going to remove this and configure the database from scratch. DynamoDB requires us to specify a Primary Key, which determines how items within our Table are uniquely organised. There’s a lot of different schools of thought on what’s best to do here, which are way out of scope of this post. To keep things simple I’ll create a <strong>UUID, </strong>which will be generated when a user submits a new Item using the form.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile database configure</pre><pre>? Select from one of the choices below. Remove table from the project<br>? Select table to be deleted AWSMobileTable<br>? Are you sure you want to delete the table Yes</pre><pre>$ awsmobile database configure</pre><pre>Welcome to NoSQL database wizard<br>You will be asked a series of questions to help determine how to best construct your NoSQL database table.</pre><pre>? Should the data of this table be open or restricted by user? Open<br>? Table name ServerlessReactExample</pre><pre>You can now add columns to the table.</pre><pre>? What would you like to name this column ID<br>? Choose the data type string<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemName<br>? Choose the data type string<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemPrice<br>? Choose the data type number<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemDescription<br>? Choose the data type string<br>? Would you like to add another column No</pre><pre>Before you create the database, you must specify how items in your table are uniquely organized. This is done by specifying a Primary key. The primary key uniquely identifies each item in the table, so that no two items can have the same key.<br>This could be and individual column or a combination that has &quot;primary key&quot; and a &quot;sort key&quot;.<br>To learn more about primary key:<br><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey</a></pre><pre>? Select primary key ID<br>? Select sort key (No Sort Key)</pre><pre>You can optionally add global secondary indexes for this table. These are useful when running queries defined by a different column than the primary key.<br>To learn more about indexes:<br><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes</a></pre><pre>? Add index No</pre><pre>$ awsmobile push<br>[...]<br>contents in #current-backend-info/ is synchronized with the latest in the aws cloud</pre><p>Again, to keep things simple I’ve not added a sort key or an index, just the Primary key which is require for setting up the db.</p><p>Let’s quickly tweak our <strong>handleSubmit </strong>function to generate a uuid whenever we submit. In order to achieve this we’ll use <a href="https://github.com/kelektiv/node-uuid"><strong>node-uuid</strong></a><strong>. </strong>There’s a few different versions you can generate, but we’ll use the <strong>uuidv1, </strong>which creates a timestamp uuid. This can be converted and tested on a site like <a href="https://www.famkruithof.net/uuid/uuidgen">this</a>.</p><pre>#bash </pre><pre>$ yarn add node-uuid</pre><pre>------------------------------------------------------------------</pre><pre><strong>#createItem.js</strong></pre><pre><strong>const uuidv1 = require(&#39;uuid/v1&#39;);</strong></pre><pre>[...]<br>handleSubmit(event) {<br>    console.log(this);<br>    let apiName = &#39;sampleCloudApi&#39;;<br>    let path = &#39;/items&#39;;<br>    let newItem = {<br>      body: {<br>          <strong>ID: uuidv1()</strong>, name: this.state.itemName, price: this.state.itemPrice, description: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>    this.handleClose()<br>  }<br>[...]</pre><p>Lastly, we need to configure our <strong>cloud-api </strong>to use our newly created database.</p><pre>#bash</pre><pre>awsmobile cloud-api configure</pre><pre>This feature will create an API using Amazon API Gateway and AWS Lambda. You can optionally have the lambda function perform CRUD operations against your Amazon DynamoDB table.</pre><pre>? Select from one of the choices below. Create CRUD API for an existing Amazon DynamoDB table<br>? Select Amazon DynamoDB table to connect to a CRUD API ServerlessReactExample<br>Adding lambda function code on:<br>/Users/jameshamann/Documents/Development/serverless-web-app-example/awsmobilejs/backend/cloud-api/rverlessReactExample/<br>...<br>Path to be used on API for get and remove an object should be like:<br>/ServerlessReactExample/object/:ID</pre><pre>Path to be used on API for list objects on get method should be like:<br>/ServerlessReactExample/:ID</pre><pre>JSON to be used as data on put request should be like:<br>{<br>  &quot;ID&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemDescription&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemName&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemPrice&quot;: &quot;INSERT VALUE HERE&quot;<br>}<br>To test the api from the command line (after awsmobile push) use this commands<br>awsmobile cloud-api invoke ServerlessReactExampleCRUD &lt;method&gt; &lt;path&gt; [init]</pre><pre>$ awsmobile push</pre><p>This does change the name of your <strong>API, </strong>you’ll notice mine is now called <strong>ServerlessReactExampleCRUD,</strong> with a <strong>path </strong>of <strong>/ServerlessReactExample. </strong>So in order to get things to work,<strong> </strong>you’ll need to update the <strong>apiName and path </strong>in your code to reflect this.</p><p>Now let’s create a new item in our form and hit Submit. We still don’t see anything, but if we head over to the <a href="https://aws.amazon.com/dynamodb">AWS DynamoDB Console</a>, we’ll see our item has been successfully saved in our database!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xZ2kgys68NggdswMMe_yQA.png"/></figure><h4>Read</h4><p>Now that we can successfully Create items, let’s work on Reading them in our dashboard. Instead of reading one Item at a time, I’m going to fetch all Items in our database and display them on our itemDashboard. To do this, we’ll need to slightly alter our Lambda code to include a function that returns all items from our DynamoDB Table.</p><p>DynamoDB provides us with a <strong>.scan </strong>method, which returns all items, similar to a <em>SELECT * from tablename</em> in SQL. Let’s start off by editing our <strong>app.js </strong>within our <strong>backend </strong>folder and include a route that retrieves all data.</p><pre>#<strong>awsmobilejs/backend/yourLambdaFunctionName/app.js</strong></pre><pre>[...]</pre><pre>app.get(&#39;/ServerlessReactExample&#39;, function(req, res) {</pre><pre>var params = {<br>    TableName: tableName,<br>    Select: &#39;ALL_ATTRIBUTES&#39;,<br>};</pre><pre>dynamodb.scan(params, (err, data) =&gt; {<br>       if (err) {<br>         res.json({error: &#39;Could not load items: &#39; + err.message});<br>       }</pre><pre>res.json({<br>           data: data.Items.map(item =&gt; {<br>             return item;<br>           })<br>       });<br>   });<br>});</pre><pre>[...]</pre><pre>-------------------------------------------------------------------</pre><pre>#bash</pre><pre>$ awsmobile push<br>[...]</pre><p>Be sure to add the function just above the other routes and to push your changes to the aws cloud.</p><p>Once everything has been pushed and updated, reload your app and, if everything’s setup correctly, you should see all items from the database.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/848/1*mOAAlE3_bDNddPPw-4C01g.png"/><figcaption>After refreshing</figcaption></figure><p>Let’s update our itemDashboard so that it correctly displays the data fetched from the database. We’ll iterate through our JSON response and for each item, we’ll display the <strong>name, price </strong>and <strong>description </strong>on a <strong>Card. </strong>We’ll require another library, <strong>lodash</strong>, which basically makes working with objects a lot easier.</p><pre>#bash </pre><pre>$ yarn add loadash</pre><pre>-------------------------------------------------------------------</pre><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import {Container, Card} from &#39;semantic-ui-react&#39;<br><strong>import Amplify, { API } from &#39;aws-amplify&#39;;<br>import _ from &#39;lodash&#39;;</strong></pre><pre>let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>let path = &#39;/ServerlessReactExample&#39;;</pre><pre>class ItemDashboard extends Component {</pre><pre><strong>constructor(props){<br>    super(props)<br>    this.state = {itemData: {}}<br>  }</strong></pre><pre><strong>getItems(){<br>    API.get(apiName, path).then(response =&gt; {<br>      console.log(response)<br>      this.setState({<br>       itemData: response.data<br>      });<br>    });<br>  }</strong></pre><pre>componentDidMount(){<br>    <strong>this.getItems()<br></strong>  }</pre><pre>render() {<br><strong>    const itemData = this.state.itemData;<br></strong>    <strong>return (<br>      &lt;div&gt;</strong></pre><pre>&lt;CreateItemModal/&gt;<strong>        <br>&lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  £ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</strong></pre><pre>export default ItemDashboard;</pre><p>We move our GET request into it’s own function, <strong>getItems() </strong>and call it during the <strong>componentDidMount </strong>function. Then, in our <strong>render </strong>function, we set <strong>itemData </strong>equal to <strong>this.state.itemData, </strong>which is set during our <strong>getItems() function. </strong>In the UI, we _<strong>.map </strong>over our <strong>itemData </strong>and for each Item we return a Card with the <strong>ItemName</strong>, <strong>ItemPrice </strong>and <strong>ItemDescription</strong>. After reloading your app, the result should look something like the below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dSNJl7GoDS8FYqbMxKn5WQ.png"/></figure><p>Before moving on, you’ll notice in order to see your results after a form submission you’ll need to refresh. Let’s fix that with a callback and set the state of <strong>this.state.itemData </strong>to get updated when we submit our form.</p><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>[...]</pre><pre>render() {<br>    const itemData = this.state.itemData;<br>    return (<br>      &lt;div&gt;</pre><pre><strong>&lt;CreateItemModal getItems={this.getItems}/&gt;<br></strong>&lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  £ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>[...]</pre><pre>-------------------------------------------------------------------<br>#<strong>src/screens/createItem.js</strong></pre><pre>[...]</pre><pre>handleSubmit(event) {<br>    console.log(this);<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &#39;/ServerlessReactExample&#39;;<br>    let newItem = {<br>      body: {<br>          &quot;ID&quot;: uuidv1(),<br>          &quot;ItemName&quot;: this.state.itemName,<br>          &quot;ItemPrice&quot;: this.state.itemPrice,<br>          &quot;ItemDescription&quot;: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>   <strong> this.props.getItems()</strong><br>    this.handleClose()<br>  }</pre><pre>[...]</pre><p>We pass the function down from <strong>ItemDashboard </strong>to <strong>createItem</strong>.</p><h4>Update</h4><p>Next, we’ll look at Updating our Items, if we want to change the price, for example.</p><p>Let’s create another modal, exactly the same as our <strong>createItem.js, </strong>but let’s call it <strong>editItem.js. </strong>Alot of the contents will be similar as it’s essentially the same form, just for editing an item.</p><pre><strong>#src/screens/editItem.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import { Form, Modal, Button, Container, Icon } from &#39;semantic-ui-react&#39;<br>import Amplify, { API } from &#39;aws-amplify&#39;;<br>const uuidv1 = require(&#39;uuid/v1&#39;);</pre><pre>class EditItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br><strong>    this.state = { item: this.props.item };<br></strong>  }</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre>handleSubmit(event) {<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &#39;/ServerlessReactExample&#39;;<br><strong>    let editItem = {<br></strong>      body: {<br><strong>          &quot;ID&quot;: this.props.item[0].ID,<br></strong>          &quot;ItemName&quot;: this.state.itemName,<br>          &quot;ItemPrice&quot;: this.state.itemPrice,<br>          &quot;ItemDescription&quot;: this.state.itemDescription<br>        }<br>      }<br>    API.put(apiName, path, editItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });</pre><pre>    this.props.getItems()<br>    this.handleClose()<br>    event.preventDefault();<br>  }</pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>      <strong>return (<br>        &lt;Container style={{padding: 10}}&gt;<br>            &lt;Modal trigger={&lt;Button icon onClick={this.handleOpen}&gt;&lt;Icon name=&#39;edit&#39; /&gt;&lt;/Button&gt;}open={this.state.modalOpen}  closeIcon </strong> <strong>onClose={this.handleClose}&gt;<br>              &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;<br>              &lt;Modal.Content&gt;<br>                &lt;Form onSubmit={this.handleSubmit}&gt;<br>                &lt;Form.Group unstackable widths={2}&gt;<br>                  &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Edit Item Name...&#39; onChange={this.handleChange}  value={this.state.itemName} /&gt;<br>                  &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;£0.00&#39; onChange={this.handleChange}  value={this.state.itemPrice} /&gt;<br>                &lt;/Form.Group&gt;<br>                &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item Description&#39; placeholder=&#39;Edit Description of the Item...&#39; onChange={this.handleChange}  value={this.state.itemDescription} /&gt;<br>                  &lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>                &lt;/Form&gt;<br>            &lt;/Modal.Content&gt;<br>          &lt;/Modal&gt;<br>       &lt;/Container&gt;</strong><br>      );<br>    }<br>  }</pre><pre>export default EditItemModal;</pre><p>Essentially this is the same code as what’s in <strong>createItem.js, </strong>the only difference is we’re receiving props we’ve sent from our parent component <strong>itemDashboard.js, </strong>in order to retrieve the item’s ID. This is important, as we require the ID in order to make sure we’re updating the correct item in our database.</p><p>To send the Item to our <strong>EditItemModal </strong>, we need to create a function that fetches the item. We’ll do this in our <strong>ItemDashboard</strong> and send the response to our <strong>EditItemModal </strong>through props.</p><pre><strong>#src/screens/ItemDashboard.js<br>[...]</strong></pre><pre><strong>import EditItemModal from &#39;./editItem.js&#39;</strong></pre><pre>[...]</pre><pre><strong>getItem(id){<br>  let single_path = &#39;/ServerlessReactExample/&#39; + id<br>  console.log(single_path)<br>  API.get(apiName, single_path).then(response =&gt; {<br>    console.log(response)<br>    this.setState({<br>      item: response<br>    })<br>  });<br>}</strong></pre><pre>[...]</pre><pre>return (<br>      &lt;div&gt;<br>        &lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            <strong>&lt;Card onClick={() =&gt; this.getItem(ID)}&gt;</strong><br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  £ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br><strong>              &lt;EditItemModal item={Object.values(this.state.item) getItems={(this.getItems)} /&gt;<br></strong>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );</pre><p>Don’t forget to import the <strong>EditItemModal, </strong>as we’ll be rendering this within our dashboard on each card. Our function, <strong>getItem, </strong>takes an ID as it’s argument, the ID is then appended to the path used within our GET request, which returns all information on the requested Item. We then set the state of <strong>item </strong>equal to the response of our call and send that data through to our <strong>EditItemModal.</strong></p><p>Once Complete, you should have a dashboard similar to this, with the ability to edit the item you’ve clicked on.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DRRHjfv4wJGjOo7bnTDN1w.png"/></figure><p>Awesome! Lastly, let’s quickly implement our last CRUD function, delete.</p><h4>Delete</h4><p>Implementing a delete function is fairly quick, as most of the work is already done. We’ll add the delete function to our <strong>EditItemModal</strong>, as it’s probably the best place for it.</p><pre>#<strong>src/screens/editItem.js</strong></pre><pre>[...]</pre><pre>constructor(props) {<br>    super(props)<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br><strong>    this.deleteItem = this.deleteItem.bind(this);</strong></pre><pre>this.state = { item: this.props.item };<br>  }</pre><pre><strong>deleteItem(){<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &quot;/ServerlessReactExample/object/&quot; + this.props.item[0].ID<br>    API.del(apiName, path).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    this.props.getItems()</strong></pre><pre><strong>    this.handleClose()<br>  }</strong></pre><pre><strong>[...]</strong></pre><p>Very simply, our function makes a delete request, using <strong>API </strong>component, with the ID appended to the path. The ID is required so the function know’s which Item to delete from our database. Don’t forget to bind our function to <strong>this</strong>, otherwise we’ll get undefined errors when trying to retrieve our <strong>ID.</strong></p><p>Lastly, let’s render a Delete button on our Modal and link it all together.</p><pre>#<strong>src/screens/editItem.js</strong></pre><pre>return (<br>        &lt;Container style={{padding: 10}}&gt;<br>            &lt;Modal trigger={&lt;Button icon onClick={this.handleOpen}&gt;&lt;Icon name=&#39;edit&#39; /&gt;&lt;/Button&gt;} open={this.state.modalOpen} closeIcon onClose={this.handleClose}&gt;<br>              &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;<br>              &lt;Modal.Content&gt;<br>                &lt;Form onSubmit={this.handleSubmit}&gt;<br>                &lt;Form.Group unstackable widths={2}&gt;<br>                  &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Edit Item Name...&#39; onChange={this.handleChange}  value={this.state.itemName} /&gt;<br>                  &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;£0.00&#39; onChange={this.handleChange}  value={this.state.itemPrice} /&gt;<br>                &lt;/Form.Group&gt;<br>                &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item Description&#39; placeholder=&#39;Edit Description of the Item...&#39; onChange={this.handleChange}  value={this.state.itemDescription} /&gt;<br>                  &lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>                &lt;/Form&gt;<br>            &lt;/Modal.Content&gt;<br>           <strong> &lt;Modal.Actions&gt;<br>              &lt;Button icon labelPosition=&#39;left&#39; onClick={this.deleteItem}&gt;<br>              &lt;Icon name=&#39;delete&#39; /&gt;<br>                Delete Item<br>              &lt;/Button&gt;<br>            &lt;/Modal.Actions&gt;</strong><br>          &lt;/Modal&gt;<br>       &lt;/Container&gt;</pre><p>Once completed, your <strong>EditItemModal</strong> should look like this. When clicking delete, and after a refresh, you’ll notice the item has been removed.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-G3bneervjaVbEsLngqtRA.png"/></figure><p>This has been quite a long post, so well done if you’ve made it this far! You now have a, real basic, Serverless React Web App! There are still a lot of things that need to be cleaned up and refactored, like perhaps adding the Item Title to the <strong>EditItemModal</strong>, so we know what we’re editing and adding maybe adding some validation to our forms? There’s a lot of scope for improvement and enhancement here, but this gives you a solid foundation to move forward.</p><p>The next, and final, part on this mini series will be focused around Adding Authentication, with Amplify, as well as the Deployment and Distribution of your app through AWS.</p><p><strong>All source code for the project can be found </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d740ee8e7456" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify — Part One</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_0jTP7l27uwj2CPLpqnVdw.jpeg"/></figure><p>Having previously posted about <a href="https://medium.com/@jameshamann/accelerating-mobile-app-development-with-aws-amplify-fb2034e60160">Accelerating Mobile Development with AWS Amplify</a>, I thought I’d do the same for the Web, using <a href="https://github.com/aws/aws-amplify">AWS Amplify</a>, Amazon’s new JavaScript Library for app development.</p><p><strong>All source code for the project can be found </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>Before diving in, it’s probably worth understanding, at least at a high level, the architecture behind serverless apps and how they work.</p><h4>What is a Serverless Application?</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eIECK-X8x_9wfu9uShspHw.png"/><figcaption>High Level Serverless Application Model</figcaption></figure><p>This diagram represents, at a high level, the architecture of a serverless application. Our static content (React Web App) is stored in an S3 bucket served up to the client, either from CloudFront or directly. This communicates with API Gateway. From here this triggers a Lambda function (which handles all our back end logic) and communicates with DynamoDB to get, save, delete or whatever depending on what request was sent from the client.</p><h4>What are the benefits?</h4><p>Cost. You only pay for the compute time you use. This works great if you have large fluctuations in traffic/requests. It also takes the hassle of maintaining a server away and some what simplifies things so you can focus on building your product. Obviously, every app has it’s own requirements and serverless architecture may not fit in all cases, but for the most part it provides a good framework to deploy applications at low cost, with minimal configuration.</p><h4>What we’ll be building</h4><p>To keep things nice and simple, and to avoid the stale recycled todo example, we’ll build an online inventory with basic CRUD functions. I’m sure it goes without saying but you’d need an AWS Account, which you can get get <a href="https://aws.amazon.com/">here</a>. I’d also advise you to keep an eye on your billing statement so you don’t incur any unexpected charges.</p><h4>Getting Started</h4><p>Firstly, we’ll need to install the <strong>awsmobile-cli </strong>and configure it with our AWS Keys.</p><pre><strong>#bash</strong></pre><pre>$ npm install -g awsmobile-cli<br>[...]<br><br>$ awsmobile configure<br>$ configure aws<br>? accessKeyId:  [ENTER YOUR ACCESS KEY ID] #hit enter<br>? secretAccessKey: [ENTER YOUR SECRET ACCESS KEY] #hit enter<br>? region:  eu-west-2 #select your region using arrows and hit enter</pre><p>Next, we’ll use <a href="https://github.com/facebook/create-react-app">create-react-app</a> to scaffold up a React App for us.</p><pre><strong>#bash </strong></pre><pre>$ create-react-app serverless-web-app-example<br>[...]<br>✨  Done in 17.74s.</pre><pre>Success! Created serverless-web-app-example at /Users/jameshamann/Documents/Development/serverless-web-app-example<br>Inside that directory, you can run several commands:</pre><pre>yarn start<br>    Starts the development server.</pre><pre>yarn build<br>    Bundles the app into static files for production.</pre><pre>yarn test<br>    Starts the test runner.</pre><pre>yarn eject<br>    Removes this tool and copies build dependencies, configuration files<br>    and scripts into the app directory. If you do this, you can’t go back!</pre><pre>We suggest that you begin by typing:</pre><pre>cd serverless-web-app-example<br>  yarn start</pre><pre>Happy hacking!<br>$ cd serverless-web-app-example</pre><p>Let’s fire up our app to make sure it’s all setup correctly.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kBjOFtIFilxIiY6WQMR0sA.png"/><figcaption>React Starter Page</figcaption></figure><p>Great, looks good! Now lets install <strong>aws-amplify </strong>and <strong>aws-amplify-react</strong> (which just contains helpers and higher order components for react) within our project.</p><pre><strong>#bash</strong> </pre><pre>$ npm install aws-amplify --save <br>[...]<br>$ npm install aws-amplify-react --save<br>[...]</pre><p>Once this is all installed, we’ll need to setup our backend. To initialise a project, we use the <strong>awsmobile init </strong>command within the root of our project. You’ll be prompted a few questions, usually the default answers provided are correct so you should be able to hit enter for each of them.</p><pre><strong>#bash </strong></pre><pre>$ awsmobile init<br>[...]</pre><pre>✨  Done in 5.30s.<br>yarn add aws-amplify-react returned 0</pre><pre>Success! your project is now initialized with awsmobilejs</pre><pre>awsmobilejs/.awsmobile<br>     is the workspace of awsmobile-cli, please do not modify its contents</pre><pre>awsmobilejs/#current-backend-info<br>     contains information of the backend awsmobile project from the last<br>     synchronization with the cloud</pre><pre>awsmobilejs/backend<br>     is where you develop the codebase of the backend awsmobile project</pre><pre>awsmobile console<br>     opens the web console of the backend awsmobile project</pre><pre>awsmobile run<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and runs the frontend application locally</pre><pre>awsmobile publish<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and publishes the frontend application to aws S3 for hosting</pre><pre>Happy coding with awsmobile!</pre><p>This command creates all the necessary resources in AWS for your backend, as well as creating a <strong>awsmobilejs </strong>folder within the root of your project, which contains basic information about your project.</p><p>Lastly, we’ll need to hook up our client (React app) to our newly created backend. In your app’s entry point (usually App.js) include the bolded code in the snippet. This just imports the Amplify Library and configures it using a file called <strong>aws_exports </strong>which is generated when you initialise your backend, in the previous step.</p><pre><strong># App.js </strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import logo from &#39;./logo.svg&#39;;<br>import &#39;./App.css&#39;;<br><strong>import Amplify from &#39;aws-amplify&#39;;<br>import aws_exports from &#39;./aws-exports&#39;;</strong></pre><pre><strong>Amplify.configure(aws_exports);</strong></pre><pre>class App extends Component {<br>  render() {<br>    return (<br>      &lt;div className=&quot;App&quot;&gt;<br>        &lt;header className=&quot;App-header&quot;&gt;<br>          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;<br>          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;<br>        &lt;/header&gt;<br>        &lt;p className=&quot;App-intro&quot;&gt;<br>          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br>        &lt;/p&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default App;</pre><h4>Lambda and API Setup</h4><p>Now we’ve got the basic infrastructure setup, let’s setup Lambda, API Gateway and DynamoDB for our basic CRUD functions. To do this, run the <strong>awsmobile features </strong>command. From here, you can see what features you’re able to activate and what features are available as default. For now we only require <strong>cloud-api </strong>and <strong>database </strong>to be selected and activated.</p><pre><strong>#bash </strong></pre><pre>awsmobile features</pre><pre>? select features:<br> ◯ user-signin<br> ◯ user-files<br> ◉ cloud-api<br>❯◉ database<br> ◉ analytics<br> ◉ hosting</pre><pre># hit space to select the features you&#39;d like and enter to confirm</pre><p>Whenever you change something locally, as we’ve just done, we’ll need to push it to AWS so the changes can take effect.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile push</pre><p>Once everything’s been initialised and pushed, have a poke around the <strong>backend</strong> directory, within <strong>awsmobilejs.</strong> There should be a <strong>cloud-api </strong>directory that contains your Lambda Project and a bunch of boilerplate code to get you started. By default, Lambda is setup to use AWS’s Serverless Express Framework for Node.js, so if you’re experienced with Node.js and Express, everything should look pretty familiar.</p><p>At this point, I like to do a quick check to make sure the Client and Backend are setup and talking to each other. To do this, I write a get request within the <strong>componentDidMount </strong>function, so as soon as our Component mounts, it fetches data from our backend and logs it to the console. AWS Amplify provides a component, API, to handle all requests to our backend.</p><pre><strong># App.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import logo from &#39;./logo.svg&#39;;<br>import &#39;./App.css&#39;;<br><strong>import Amplify, { API } from &#39;aws-amplify&#39;;<br></strong>import aws_exports from &#39;./aws-exports&#39;;</pre><pre>Amplify.configure(aws_exports);</pre><pre><strong>let apiName = &#39;sampleCloudApi&#39;;<br>let path = &#39;/items&#39;;</strong></pre><pre>class App extends Component {</pre><pre><strong>componentDidMount(){<br>    API.get(apiName, path).then(response =&gt; {<br>      console.log(response)<br>    });<br>  }</strong></pre><pre>render() {<br>    return (<br>      &lt;div className=&quot;App&quot;&gt;<br>        &lt;header className=&quot;App-header&quot;&gt;<br>          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;<br>          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;<br>        &lt;/header&gt;<br>        &lt;p className=&quot;App-intro&quot;&gt;<br>          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br>        &lt;/p&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default App;</pre><p>If you’ve poked around the Lambda app.js file, you’ll notice we should be expecting a response of <strong>({success: ‘get call succeed!’, url: req.url}).</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*T-GpqFtmKzSIPWZeuqQ0Zw.png"/></figure><p>Ok, you might need to squint, but if you check the console you’ll see our request object <strong>{success: “get call succeeded!”, url: /items”}. </strong>Great! Everything’s hooked up and ready to go.</p><p>In the next part we’ll look at setting our Front End Pages up and creating the basic CRUD Functions.</p><p>As always, thanks for reading, hit 👏 if you like what you read and be sure to follow to keep up to date with future posts.</p><h4><a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-two-d740ee8e7456">Serverless React Web App with AWS Amplify — Part Two Available Here</a></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><p><strong>This story is published in </strong><a href="http://blog.usejournal.com"><strong>Noteworthy</strong></a><strong>, where thousands come every day to learn about the people &amp; ideas shaping the products we love.</strong></p><p><a href="http://blog.usejournal.com"><strong>Follow our publication</strong></a><strong> to see more product &amp; design stories featured by the </strong><a href="https://usejournal.com/?/utm_source=usejournal.com&amp;utm_medium=blog&amp;utm_campaign=guest_post&amp;utm_content=james_hamann"><strong>Journal</strong></a><strong> team.</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=414e9402d92a" width="1" height="1"><hr><p><a href="https://blog.usejournal.com/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a">Serverless React Web App with AWS Amplify — Part One</a> was originally published in <a href="https://blog.usejournal.com">Noteworthy - The Journal Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></p> </div> </div> <p style="text-align: center"><a class="waves-effect waves-light btn green darken-2" target="_blank" href="https://medium.com/@jameshamann/"><i class="material-icons right">library_books</i>Read more at Medium</a></p> </div> <script type="text/javascript" src="/assets/js/jquery-3.2.1.min.js"></script> <script type="text/javascript" src="/assets/js/materialize.min.js"></script> <script src="/assets/js/init.js"></script> </body> <footer class="page-footer"> <div class="footer-copyright" style="padding-left: 30px"> <i class="material-icons" style="padding-right:5px">copyright</i><p>2017 Copyright James Hamann | All rights reserved</p> </div> </footer> </html>