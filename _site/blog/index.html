<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" type="text/css" href="/jameshamannassets/css/materialize.css"> <link rel="stylesheet" href="https://cdn.rawgit.com/konpa/devicon/df6431e323547add1b4cf45992913f15286456d3/devicon.min.css"> <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> <title>James Hamann</title> <script type="text/javascript">screen.width<=699&&(document.location="mobile.html");</script> </head> <body> <h2 style="text-align:center"> Latest Blog Posts </h2> <p style="text-align:center;"><a class="waves-effect waves-light btn green darken-2" target="_blank" href="https://medium.com/@jameshamann/"><i class="material-icons right">library_books</i>Read more at Medium</a></p> <div class="fixed-action-btn horizontal"> <a class="btn-floating btn-large waves-effect waves-default pulse" href="/"> <i class="material-icons">arrow_back</i> </a> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify â€” Part Three</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nIEoRXRsVjf9C-CIvK8uEQ.jpeg"/></figure><p>Following on from my previous post,<a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-two-d740ee8e7456"> Serverless React Web App with AWS Amplifyâ€Šâ€”â€ŠPart Two</a>, today weâ€™ll be <strong>adding authentication and looking at deployment and distribution</strong> in the final part of this miniÂ series.</p><p><strong>All source code for the project can be foundÂ </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>At the moment our app should look somewhat similar to the below, with the ability to add/edit/delete items.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*R59qZ3CoSiPQ9otvyH8z4g.png"/><figcaption>Current App</figcaption></figure><h4>User Authentication</h4><p>Letâ€™s start by enabling the <strong>user-signin </strong>feature using the <strong>awsmobile CLI</strong>.</p><pre>#bash</pre><pre>$ awsmobile user-signin enable --prompt<br>? Sign-in is currently disabled, what do you want to do next <br>Enable sign-in with default settings </pre><pre>#Choose default settings </pre><pre>$ awsmobile push<strong> #push your changes to the cloud</strong></pre><p>To keep things simple, weâ€™ll use Amplifyâ€™s <strong>withAuthenticator </strong>component to handle our auth flow. This component wraps our entire app up and renders a complete sign up/sign in UI, which is customisable through the AWS Mobile Hub. If you wish, you can also handle the Sign In/Sign Up process using the <strong>Auth </strong>component, which gives you greater flexibility of the entire authÂ flow.</p><pre><strong># App.js </strong></pre><pre>[...]</pre><pre>import { withAuthenticator } from &#39;aws-amplify-react&#39;</pre><pre>[...]</pre><pre>export default<strong> withAuthenticator(App, true);</strong></pre><p>After adding the above code to your <strong>App.js </strong>file, reload your app and it should look something like this. The added <strong>true</strong> ensures a sign out button is rendered.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jcbTNpCNnFk4SVewgVazDw.png"/><figcaption>Sign In/Sign UpÂ Page</figcaption></figure><p>Try going through the Sign Up flow, youâ€™ll notice MFA (multi-factor auth) is enabled by default, so when putting your mobile number in youâ€™ll get a confirmation code to use each time to sign in/sign up. Itâ€™s probably overkill for an app like this, but it does improve security. Once going through the flow and signing in with your newly created user account, you should be directed to your appâ€™s homeÂ page.</p><p>Thatâ€™s user authentication done! Pretty simple isnâ€™t it? You can also view all users signed up to your app by heading over to the User Pool on Cognito and clicking on <strong>Users and Groups. </strong>The easiest way to get to your Cognito Pool is to open up the Mobile Hub, head to the User Sign In card and click â€œEdit in Cognito.â€</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2eo_a_HReunkQGCtOWzC9A.png"/><figcaption>AWS Mobile Hub, Cognito PoolÂ Settings</figcaption></figure><p><strong>Please remember, whenever you make changes in the hub/on the web app, be sure to pull the changes back into your local project. </strong>Iâ€™ve caused myself so many stupid issues by not doing this and your project gets real messy, real fast and can get out of sync, so make sure your local copy is always in sync with theÂ cloud.</p><h4>Federated IdentityÂ Login</h4><p>Now weâ€™ve added user auth, but most modern web apps incorporate some form of social login, so letâ€™s add <strong>Google Sign-In</strong> toÂ ours.</p><p>Youâ€™ll need to get a <strong>google_client_id</strong>. Itâ€™s fairly straight forward and Google provide easy to follow instructions <a href="https://developers.google.com/identity/sign-in/web/sign-in">here</a>. When asked what youâ€™re developing for, choose <strong>Web Server </strong>and then<strong> </strong>add the <strong>Authorized JavaScript</strong> <strong>origins </strong>as <a href="http://localhost:3000"><strong>http://localhost:3000</strong></a><strong>. </strong>Be sure to keep this tab open for the time being, as weâ€™ll be going back and fourth retrieving the Client ID as well as changing some settings laterÂ on.</p><p>Next, weâ€™ll need to add our Client ID to our Cognito Pool, this can be done by configuring the <strong>user-signin</strong> feature, using the <strong>awsmobile</strong> <strong>CLI</strong>Â tool.</p><pre><strong>#bash </strong></pre><pre>â†’ awsmobile user-signin configure</pre><pre>? Sign-in is currently enabled, what do you want to do next Go to advance settings<br>? Which sign-in method you want to configure Google sign-in (currently disabled)<br>? Google Web App Client ID <strong>xxxxYOURCLIENTIDxxxxx</strong>.apps.googleusercontent.com<br>? Google Android Client ID <strong>xxxxYOURCLIENTIDxxxxx</strong>.apps.googleusercontent.com<br>? Google iOS Client ID <strong>xxxxYOURCLIENTIDxxxxx</strong>.apps.googleusercontent.com</pre><pre>$ <strong>awsmobile push //don&#39;t forget to push your changes, otherwise it won&#39;t work. </strong></pre><p>Finally, weâ€™ll need to tweak our code to include our <strong>google_client_id, </strong>so that the <strong>withAuthenticator </strong>component can use it. As long as you restrict the origins from the Google Dev Console, as we did earlier, there isnâ€™t a specific need to hide this ID, so we donâ€™t need to worry about loading environment variables justÂ yet.</p><p>The first thing we need to change is in our <strong>App.js </strong>file. We revert back to exporting the App as it is, not wrapping it in the <strong>withAuthenticator </strong>component.</p><pre>#<strong>App.js </strong></pre><pre>[...]</pre><pre><strong>export default App;</strong></pre><p>Next, in our <strong>index.js </strong>file, we import <strong>App.js </strong>and create a new <strong>constant</strong> named <strong>AppWithAuth, </strong>which is essentially what we had previously in our <strong>App.js </strong>file. We then create another constant called <strong>federated </strong>and set this equal to a JSON config containing our <strong>google_client_id. </strong>Lastly, we use our constant <strong>AppWithAuth </strong>within the render function and include our <strong>google_client_id </strong>from the <strong>federated </strong>constant we justÂ created<strong>.</strong></p><pre>#<strong>index.js</strong></pre><pre><strong>import App from &#39;./App&#39;;</strong></pre><pre><strong>import { withAuthenticator } from &#39;aws-amplify-react&#39;</strong></pre><pre><strong>const AppWithAuth = withAuthenticator(App, true);</strong></pre><pre><strong>const federated = {<br>  google_client_id: &#39;xxxxxYOURCLIENTIDxxxxxx.apps.googleusercontent.com&#39;,<br>};</strong></pre><pre>ReactDOM.render(<strong>&lt;AppWithAuth federated={federated}/&gt;</strong>, document.getElementById(&#39;root&#39;));<br>registerServiceWorker();</pre><p>After reloading your app, you should be able to successfully login usingÂ Google!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/918/1*Htm6pZz-9Ui5JllsEIvbog.png"/><figcaption>Our new sign in/sign up up form with Google Sign inÂ Button</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LQOd4fa97FA4BDHAU3VlTQ.png"/><figcaption>After successful Google Login, the userâ€™s name is displayed on the header with a Sign OutÂ button.</figcaption></figure><p>The process for adding Facebook/Amazon Logins is pretty much the same, youâ€™d just need to acquire a client ID from their developer dashboard.</p><p>Thatâ€™s it for Authentication! We successfully added a sign in/sign up form and incorporated Google Login. Itâ€™s still quite rough around the edges and could do with some styling, but functionality wise itâ€™s pretty muchÂ there.</p><h4>Deployment and Distribution</h4><p>Letâ€™s make sure people can actually access and use our app by deploying it and distributing it. AWS Amplify includes one simple command that sets everything up for deployment and distribution.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile publish</pre><pre>File sizes after gzip:</pre><pre>379.32 KB  build/static/js/main.c1215b8f.js<br>  99.09 KB   build/static/css/main.340cfbbb.css</pre><pre>The project was built assuming it is hosted at the server root.<br>You can control this with the homepage field in your package.json.<br>For example, add this to build it for GitHub Pages:</pre><pre>&quot;homepage&quot; : &quot;<a href="http://myname.github.io/myapp">http://myname.github.io/myapp</a>&quot;,</pre><pre>The build folder is ready to be deployed.<br>You may serve it with a static server:</pre><pre>yarn global add serve<br>  serve -s build</pre><pre>Find out more about deployment here:</pre><pre><a href="http://bit.ly/2vY88Kr">http://bit.ly/2vY88Kr</a></pre><pre>Successful!<br>your application is published and hosted at:<br><a href="http://serverlesswebappexam-hosting-mobilehub-1099236211.s3-website.eu-west-2.amazonaws.com">http://serverlesswebappexam-hosting-mobilehub-1099236211.s3-website.eu-west-2.amazonaws.com</a><br>your application is also distributed through aws CloudFront<br><a href="https://d2x9wan2jbunv.cloudfront.net">https://d2x9wan2jbunv.cloudfront.net</a></pre><p>This command will build your app and upload the files to a s3 bucket, configured to host static websites. Itâ€™ll also go one step further and distribute this through their Global CDN, CloudFront, making your site quicker and easier to access for users all over theÂ world!</p><p>Once uploading has finished, youâ€™ll notice two URLS, one is the bucket URL and one is the cloudfront distribution. If you try logging in on either youâ€™ll get thisÂ error.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iwqEIiKvRuX_ACBeTtDQLw.png"/><figcaption>Redirect_URI_Mismatch errorâ€Šâ€”â€ŠUpdate the Authorised Origins within the Google Cloud APIÂ Settings</figcaption></figure><p>This occurs because the request is coming from a domain that hasnâ€™t been approved, so letâ€™s quickly add our new CloudFront URL to the <strong>Authorised Javascript origins, </strong>in the Google Cloud API Settings.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wH_pzN_rIx8A5EeGGpYxvg.png"/></figure><p>After adding this and saving, you should be able to login successfully usingÂ Google.</p><p>As itâ€™s quite simple to do, I thought itâ€™d be useful to finish by showing you how to point your new app to your personal domain, if you have one. In order to do this, youâ€™ll need your domain name in <a href="https://aws.amazon.com/route53/?sc_channel=PS&amp;sc_campaign=acquisition_UK&amp;sc_publisher=google&amp;sc_medium=ACQ-P|PS-GO|Brand|SU|Delivery|Route%2053|UK|EN|Text&amp;sc_content=route_53_e&amp;sc_detail=route%2053%20aws&amp;sc_category=route_53&amp;sc_segment=285292336467&amp;sc_matchtype=e&amp;sc_country=UK&amp;s_kwcid=AL!4422!3!285292336467!e!!g!!route%2053%20aws&amp;ef_id=WWyBdQAABRdHCY3h:20180813110206:s">AWS RouteÂ 53</a>.</p><p>Firstly, we need to configure our Cloudfront Distribution to include our alternate domain name. Open up the CloudFront Dashboard, locate your distribution and update the <strong>Alternate Domain Names. </strong>Iâ€™ll be using the domain <strong>serverlessreactexample.jameshamann.com.</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hgffLxZz6lMyzd36wDFDdQ.png"/></figure><p>Youâ€™ll also need to choose <strong>Custom SSL Certificate </strong>and select the correct certificate for your domain. Setting up a Certificate in AWS Certificate Manager is incredibly easy and straightforward, you can follow the docs <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">here</a>. One thing to note, make sure the certificates you create <strong>are stored in US-East (N. Virginia) </strong>in order to access them from CloudFront. You can always check what region youâ€™re in by checking the top right of the app bar, next to your name. When youâ€™re all done, hit <strong>Yes, Edit</strong>. Now we wait, updates to CloudFront distributions can take some time, so take a littleÂ break.</p><p>Once your changes are deployed, head over to the Route 53 Dashboard and click on your registered domain. Next, click <strong>Create Record Set </strong>and fill in your URL in the <strong>Name </strong>field. Youâ€™ll then need to change <strong>Alias </strong>to <strong>Yes</strong> and copy your CloudFront URL into the <strong>Alias TargetÂ </strong>field.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/838/1*90g_YRIltD4f6A_zSpE1bg.png"/></figure><p>Hit <strong>Create </strong>and wait for your changes to go live! The time taken can vary so donâ€™t worry if itâ€™s not instant, go grab a coffee or beer and come back later to check. <strong>Donâ€™t forget to add your new domain name to the Authorised Javascript Origins, in your Google Cloud API settings, to ensure Google Login works correctly.</strong></p><p>Congrats! Youâ€™ve now got a fully functioning, albeit a bit rough looking, Serverless React Web App! Now you have a great foundation to move forward with, allowing you to build, test and deploy your app in nice, quick iterations.</p><h4>Further Development</h4><p>Thereâ€™s quite a few different things you can do to further enhance your app. Hereâ€™s a few to help get the ideas bubbling:</p><ul><li>Adding a CI/CD Pipeline with CircleCI, <a href="https://blog.cloudboost.io/react-with-circleci-aws-s3-and-aws-cloudfront-844a1b2c75c9">check one of my previous posts on thisÂ topic</a>.</li><li>Cleaning up the Views, ensuring the Sign out button is rendered on the correct AppÂ bar.</li><li>Adding pictures using <a href="https://aws-amplify.github.io/amplify-js/media/storage_guide">Amplifyâ€™s storageÂ feature.</a></li><li>Porting to Mobile using React Nativeâ€Šâ€”â€Šthis is probably quite complex for now and would require rewriting some sections of the code, but if youâ€™re up for a challenge give it aÂ go!</li><li>Adding reviews/comments for users to leave on anÂ item</li><li>Refine UI</li><li>Incorporate <a href="https://aws-amplify.github.io/amplify-js/media/interactions_guide">Amplifyâ€™s Chatbot feature</a>, making your app a little more interactive</li></ul><p>These are just a few ideas, but thereâ€™s lots more you can do to further develop and build new features.</p><p><strong>All source code for the project can be foundÂ </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d3f1a30176e8" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi PaweÅ‚ Zubkiewicz thanks for reading!</b></h4> <p style="text-align:justify"><p>Hi <a href="https://medium.com/u/cc11fb48d78b">PaweÅ‚ Zubkiewicz</a> thanks for reading! Iâ€™m not sure about DynamoDB being publicly accessible? To access DynamoDB you need AWS Credentials, which have access to the correct resources. In this model, Amplify takes care of Authentication through the API module. All requests made are automatically signed with a AWS v4 signature, so any requests made to DynamoDB are secured through yourÂ API.</p><p>In answer to your second question, cognito is integrated into Amplify and pretty easy to setup. This is another way you could authenticate access, by creating a cognito group or user with the relevant permissions.</p><p>Hope thisÂ helps!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c52cd74f69fa" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Architecting your IoT App using Raspberry Pi and AWS</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dzxCfHB9TOC2o8DGXVf3qA.png"/></figure><p>Having done a lot of work with IoT sensors and Raspberry Pi recently, and considering itâ€™s growing popularity, I thought Iâ€™d share how I went about architecting the infrastructure of the application, which can be applied to pretty much any IoT app you may be working on. Whilst the principals will apply to all major cloud hosting providers, Iâ€™ll be discussing AWS specific services.</p><h4>Project Outline</h4><p>A Smart Watering System for Farms/Plants, driven by data obtained from IoT Sensors and Forecasting APIs.</p><h4>Hardware Used</h4><ul><li>Raspberry Pi 3 Model B and SD Card loaded withÂ Raspbian</li><li>Female to Female DupontÂ Wires</li><li>DHT11 Temp/Humidity Sensor</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*SEIzFKM352ssKoN1NkG5_w.jpeg"/></figure><p>The above is obviously still in the prototyping phase, which hopefully explains the mess. The end product will be cased in a watertight enclosure. In addition to the Temperature Sensor, the above picture also contains a Photo Resistor which captures information about light levels, but is currently not beingÂ used.</p><h4>Architecture Diagram</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/720/1*wFQ0HOSHDiyTTdkjhhu0Xw.png"/></figure><p>This diagram illustrates all of the components used and how they interact with each other. Letâ€™s break it down a little further and understand whatâ€™s happening.</p><p>First the Pi IoT sensors publish raw data about the temperature, humidity, soil moisture and hours of sunlight. This is sent to an IoT topic via an MQTT message. This is a super light weight pub/sub messaging protocol designed specifically for devices in locations with limited network bandwidth, which is great for IoT. Next, an AWS IoT rule and action is created, which subscribes to the topic that the sensors are publishing to and sends these messages to a Kinesis data stream and DynamoDBÂ Table.</p><p>Using Kinesis is entirely optional and dependant on what youâ€™re building. The benefit of Kinesis is that it allows you the option of creating multiple delivery streams for your data. You could have one stream that delivers to a Lambda Function for record transformation, which writes to DynamoDB, or another stream for a Kinesisâ€™ Analytics Application, even a delivery stream for an ElasticSearch app. It gives you the flexibility of being able to stream the data to multiple destinations for multiple uses. On the other hand, it can over complicate the app and be a bit of overkill in some cases, but itâ€™s worth considering and making a final decision based on your appâ€™s requirements. In this example the Kinesis Delivery Stream writes to an S3 Bucket, as anÂ archive.</p><p>Once in DynamoDB, the application looks similar to a typical serverless application. The back-end logic is handled by Lambda and API Gateway and then sent to the client/Raspberry Pi. The React Front End is stored in an S3 bucket and distributed via CloudFront to the client. The client will display the sensor data as well as having the ability to control the water flow manually.</p><p>To automate the watering, the data from the sensors will be evaluated alongside data from Forecasting APIs and, based on certain criteria, the app will decide whether the area needs water and, if so, it would calculate the amount required based on all the data available. In the event watering is required a message will be published from Lambda to the Raspberry Pi on another topic, containing the â€œOpen Valveâ€ message as well as the amount of time to keep the valveÂ open.</p><p>To add a level of interactivity, a chatbot could be included which would prompt the user the current status and give the user the option to interact back, querying past events. In addition to this, data visualisation tools could be used to create dashboards, historical data could even be loaded into a Machine Learning Model to predict the likelihood of watering and the optimum amount of water. There are lots of applications and ways in which you can expand a small project into something more, to gain experience using new tools and technologies.</p><p>Whilst this model explains the infrastructure in the context of this project, it is easily applied to any other IoT app you may have in mind. Connecting a Raspberry Pi to the cloud allows it to do so much more and gives you the opportunity to build new, different apps and explore different technologies.</p><p>In another post weâ€™ll look at the specifics of setting this up within the AWS Environment and getting a Raspberry Pi Connected on the IoTÂ Console.</p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*nkCbG-E0EXjdaOtcaPQ6_g.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b8b89e3ac39a" width="1" height="1"><hr><p><a href="https://medium.com/coinmonks/architecting-your-iot-app-using-raspberry-pi-and-aws-b8b89e3ac39a">Architecting your IoT App using Raspberry Pi and AWS</a> was originally published in <a href="https://medium.com/coinmonks">Coinmonks</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi Gerald Carter, sorry for the delay in getting back to you.</b></h4> <p style="text-align:justify"><p>Hi <a href="https://medium.com/u/36a1ef21a16f">Gerald Carter</a>, sorry for the delay in getting back to you. Looking at the error you mentioned above, it might be down to the command you used in your pipelines script or the name of your app/environment onÂ AWS.</p><p>Using my example above, my elastic beanstalk app was called <strong>MyApplication </strong>and the environment I used was <strong>MyApplication-staging.</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/25d8f89a2b52e2311772f9f1df132cb5/href">https://medium.com/media/25d8f89a2b52e2311772f9f1df132cb5/href</a></iframe><p>On line 17 I mention the name of the Application, <strong>MyApplication</strong>.</p><p>On line 18, I mention the environment I wish to deploy my app to, <strong>MyApplicaton-staging.</strong></p><p>Both of these need to be setup before pushing. Double check what you called your app/environment in AWS and make sure this matches the buildÂ script.</p><p>Hope thisÂ helps!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=17eb9e04aef4" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify â€” Part Two</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*e-avRWEkg9mFn5BuWm4X4w.jpeg"/></figure><p>Following on from my previous post, <a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a">Serverless React Web App with AWS Amplifyâ€Šâ€”â€ŠPart One</a>, today weâ€™ll layout the Front End and implement our basic CRUD Functions.</p><p><strong>All source code for the project can be foundÂ </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><h4>Front End</h4><p>To bootstrap the front end, weâ€™ll use <a href="https://react.semantic-ui.com/introduction">React Semantic UI</a>, a simple UI Framework that provides a great set of React Components.</p><pre><strong>#bash</strong></pre><pre>$ yarn add semantic-ui-react<br>[...]<br>$ yarn add semantic-ui-css</pre><p>To get the CSS styling, youâ€™ll need to import it in your <strong>index.js </strong>file, likeÂ so.</p><pre><strong># index.js</strong></pre><pre>import React from &#39;react&#39;;<br>import ReactDOM from &#39;react-dom&#39;;<br>import &#39;./index.css&#39;;<br>import App from &#39;./App&#39;;<br><strong>import &#39;semantic-ui-css/semantic.css&#39;<br></strong>import registerServiceWorker from &#39;./registerServiceWorker&#39;;</pre><pre>ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));<br>registerServiceWorker();</pre><p>Now letâ€™s setup the folder structure. I like to keep screens in one folder and re-useable components in another. With that it mind, letâ€™s make two new directories within the <strong>src </strong>directory.</p><pre>#<strong>bash</strong></pre><pre>$ mkdir src/components<br>$ mkdir src/screens</pre><pre># <strong>Project Layout</strong></pre><pre>â”œâ”€â”€ README.md<br>â”œâ”€â”€ awsmobilejs<br>â”‚   â”œâ”€â”€ #current-backend-info<br>â”‚   â”‚   â”œâ”€â”€ aws-exports.js<br>â”‚   â”‚   â”œâ”€â”€ backend-details.json<br>â”‚   â”‚   â”œâ”€â”€ cloud-api<br>â”‚   â”‚   â”‚   â””â”€â”€ sampleLambda<br>â”‚   â”‚   â”‚       â”œâ”€â”€ app.js<br>â”‚   â”‚   â”‚       â”œâ”€â”€ lambda.js<br>â”‚   â”‚   â”‚       â”œâ”€â”€ package-lock.json<br>â”‚   â”‚   â”‚       â””â”€â”€ package.json<br>â”‚   â”‚   â””â”€â”€ mobile-hub-project.yml<br>â”‚   â””â”€â”€ backend<br>â”‚       â”œâ”€â”€ cloud-api<br>â”‚       â”‚   â””â”€â”€ sampleLambda<br>â”‚       â”‚       â”œâ”€â”€ app.js<br>â”‚       â”‚       â”œâ”€â”€ lambda.js<br>â”‚       â”‚       â”œâ”€â”€ package-lock.json<br>â”‚       â”‚       â””â”€â”€ package.json<br>â”‚       â””â”€â”€ mobile-hub-project.yml<br>â”œâ”€â”€ package.json<br>â”œâ”€â”€ public<br>â”‚   â”œâ”€â”€ favicon.ico<br>â”‚   â”œâ”€â”€ index.html<br>â”‚   â””â”€â”€ manifest.json<br>â”œâ”€â”€ src<br>â”‚   â”œâ”€â”€ App.css<br>â”‚   â”œâ”€â”€ App.js<br>â”‚   â”œâ”€â”€ App.test.js<br>â”‚   â”œâ”€â”€ aws-exports.js<br>â”‚   â”œâ”€â”€ components<br>â”‚   â”œâ”€â”€ index.css<br>â”‚   â”œâ”€â”€ index.js<br>â”‚   â”œâ”€â”€ logo.svg<br>â”‚   â”œâ”€â”€ registerServiceWorker.js<br>â”‚   â””â”€â”€ screens<br>â””â”€â”€ yarn.lock</pre><p>Weâ€™ll obviously need a few different views here, one to display all our items, one to create our items, one to edit/delete our items and one which shows a little more information about the item. Weâ€™ll use our <strong>App.js </strong>as the dashboard/index view for our app and add a navbar to navigate around theÂ app.</p><pre><strong># App.js</strong></pre><pre>[...]</pre><pre>render() {<br>    return (<br>      &lt;Segment&gt;<br>        &lt;Menu&gt;<br>           &lt;Menu.Item name=&#39;home&#39;&gt; &lt;Icon name=&quot;shop&quot;/&gt;&lt;/Menu.Item&gt;<br>           &lt;Menu.Item name=&#39;Items&#39;/&gt;<br>           &lt;Menu.Item name=&#39;aboutUs&#39; /&gt;<br>         &lt;/Menu&gt;<br>      &lt;/Segment&gt;<br>    );<br>  }<br>}</pre><p>Now, letâ€™s create an <strong>ItemDashboard</strong> page that shows all of ourÂ Itemâ€™s.</p><pre><strong>#bash</strong></pre><pre>touch src/screens/itemDashboard.js</pre><pre>--------------------------------------------------------------------</pre><pre>#<strong>itemDashboard.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import {Container, Card} from &#39;semantic-ui-react&#39;</pre><pre>class ItemDashboard extends Component {</pre><pre>render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;Container style={{padding: 10}}&gt;<br>          &lt;Card.Group&gt;<br>              &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    Item Name<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Item Price<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                  Description of the Item<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default ItemDashboard;</pre><p>Now weâ€™ll import this into our <strong>App.js </strong>and render it within our <strong>&lt;Segment&gt;</strong> section.</p><pre># <strong>App.js</strong></pre><pre>[...]<br>  <br>render() {<br>    return (<br>      &lt;Segment&gt;<br>        &lt;Menu&gt;<br>           &lt;Menu.Item name=&#39;home&#39;&gt; &lt;Icon name=&quot;shop&quot;/&gt;&lt;/Menu.Item&gt;<br>           &lt;Menu.Item name=&#39;Items&#39;/&gt;<br>           &lt;Menu.Item name=&#39;aboutUs&#39; /&gt;<br>         &lt;/Menu&gt;<br><strong>         &lt;ItemDashboard /&gt;<br></strong>      &lt;/Segment&gt;<br>    );<br>  }<br>}</pre><p>At the moment our app should look nice and basic, something likeÂ this.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BxDPNJ33L4G073eyYITptg.png"/><figcaption>Basic Item Dashboard</figcaption></figure><p>Next, letâ€™s implement a modal, which will serve as our createÂ page.</p><p>Weâ€™ll use Semantic UIâ€™s Modal and Form components to create the basic outline of our page. Letâ€™s create a new file <strong>createItem.js </strong>which will live in our <strong>screens </strong>directory.</p><pre>#bash</pre><pre>$ touch src/screens/createItem.js</pre><pre>--------------------------------------------------------------------</pre><pre>#<strong>createItem.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import { Form, Modal, Button, Container } from &#39;semantic-ui-react&#39;</pre><pre>class CreateItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.state = {}<br>    this.handleChange = this.handleChange.bind(this);<br>  }</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre>handleSubmit(event) {</pre><pre>}</pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>    return (<br>        &lt;Modal trigger={&lt;Button onClick={this.handleOpen}&gt;+ Add Item&lt;/Button&gt;} closeIcon={true} open={this.state.modalOpen} onClose={this.handleClose}&gt;<br>          &lt;Modal.Header&gt;Add an Item&lt;/Modal.Header&gt;<br>          &lt;Modal.Content&gt;<br>            &lt;Form&gt;<br>              &lt;Form.Group unstackable widths={2}&gt;<br>                &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Enter Item Name...&#39; onChange={this.handleChange} /&gt;<br>                &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Enter Item Price...&#39; onChange={this.handleChange} type=&#39;number&#39; /&gt;<br>              &lt;/Form.Group&gt;<br>              &lt;Form.TextArea name=&#39;item_description&#39; label=&#39;Item Description&#39; placeholder=&#39;Add a Description of the Item...&#39; onChange={this.handleChange} /&gt;</pre><pre>&lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>            &lt;/Form&gt;<br>          &lt;/Modal.Content&gt;<br>        &lt;/Modal&gt;<br>      );<br>    }<br>  }</pre><pre>export default CreateItemModal;</pre><p>Most of the above code is recycled from examples on Semanticâ€™s website. Studying the code, youâ€™ll notice Iâ€™ve also added two functions that <strong>handleChange </strong>and <strong>handleSubmit </strong>within our form. This ensures all data is captured and submitted correctly, weâ€™ll revisit both of these later when we connect everything together.</p><p>One thing I should mention, that I encountered during my own development, is a funky bug with the modal where half of it would be cut, off screen. The issue is tracked <a href="https://github.com/Semantic-Org/Semantic-UI-React/issues/2558">here</a> and the solution below worked perfectly, for me. Please do let me know if you run into any funky issues around the modal that arenâ€™t resolved with theÂ below.</p><p><strong>Proposed Workaround for ModalÂ Issue:</strong></p><pre>#<strong>App.css</strong></pre><pre>.ui.page.modals.transition.visible {<br>    display: flex !important;<br>}</pre><pre># suggested by loopmode on GitHub Issues thread.</pre><p>Make sure to import and add the component in our <strong>ItemDashboard</strong>.</p><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>[...]</pre><pre>render() {<br>    return (<br>      &lt;div&gt;<br>       &lt;CreateItemModal/&gt;        <br>        &lt;Container style={{padding: 10}}&gt;<br>          &lt;Card.Group&gt;<br>              &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    Item Name<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Item Price<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                  Description of the Item<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );</pre><pre>[...]</pre><p>The finished <strong>createItemModal</strong> should look something like theÂ below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3bkmnkqVbDb7PsbZ3gkqSg.png"/></figure><p>Looking good! Now letâ€™s hook everything up so that we can actually create items that display on our Dashboard.</p><h4>Create</h4><p>Now that we have a form weâ€™ll need to populate the function <strong>handleSubmit </strong>we wrote inÂ earlier.</p><p>Similar to our get request previously, weâ€™ll have to set the <strong>apiName</strong>, <strong>path,</strong> and this time, the body of what weâ€™re sending. Weâ€™ll then use Amplifyâ€™s <strong>API </strong>component to post and log the contents to theÂ console.</p><pre><strong>#createItem.js</strong></pre><pre><strong>import Amplify, { API } from &#39;aws-amplify&#39;;</strong></pre><pre>class CreateItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.state = {}<br>    this.handleChange = this.handleChange.bind(this);<br><strong>    this.handleSubmit = this.handleSubmit.bind(this);</strong></pre><pre>}</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre><strong>handleSubmit(event) {<br>    let apiName = &#39;sampleCloudApi&#39;;<br>    let path = &#39;/items&#39;;<br>    let newItem = {<br>      body: {<br>          name: this.state.itemName, price: this.state.itemPrice, description: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>    this.handleClose()<br>  }</strong></pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>    return (<br>        &lt;Modal trigger={&lt;Button onClick={this.handleOpen}&gt;+ Add Item&lt;/Button&gt;} closeIcon={true} open={this.state.modalOpen} onClose={this.handleClose}&gt;<br>          &lt;Modal.Header&gt;Add an Item&lt;/Modal.Header&gt;<br>          &lt;Modal.Content&gt;<br>            &lt;Form <strong>onSubmit={this.handleSubmit}</strong>&gt;<br>              &lt;Form.Group unstackable widths={2}&gt;<br>                &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Enter Item Name...&#39; onChange={this.handleChange}  <strong>value={this.state.itemName} </strong>/&gt;<br>                &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Â£0.00&#39; onChange={this.handleChange}  <strong>value={this.state.itemPrice} </strong>/&gt;<br>              &lt;/Form.Group&gt;<br>             &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item    Description&#39; placeholder=&#39;Add a Description of the Item...&#39; onChange={this.handleChange}  <strong>value={this.state.itemDescription}</strong> /&gt;</pre><pre>&lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>            &lt;/Form&gt;<br>          &lt;/Modal.Content&gt;<br>        &lt;/Modal&gt;<br>      );<br>    }<br>  }</pre><pre>export default CreateItemModal;</pre><p>The <strong>handleSubmit </strong>function declares the variables necessary for posting to our backend. The body is formed of the values we set in each form element: <strong>itemName, itemPrice </strong>and <strong>itemDescription. </strong>The last thing we need to do is bind our function to our component so that it doesnâ€™t show up undefined when we call our function.</p><p>Now letâ€™s give the form a quick test to see if everythingâ€™s working.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/844/1*NEmUzgh6sEsxzqJoIeu_1A.png"/></figure><p>After submitting the form, with some content obviously, you should see the contents in the console, likeÂ above.</p><p>Great! However, this isnâ€™t saving anywhere, we still need to configure our Database.</p><h4>DynamoDB Setup</h4><p>Earlier on we setup a Database with the default example setup, weâ€™re going to remove this and configure the database from scratch. DynamoDB requires us to specify a Primary Key, which determines how items within our Table are uniquely organised. Thereâ€™s a lot of different schools of thought on whatâ€™s best to do here, which are way out of scope of this post. To keep things simple Iâ€™ll create a <strong>UUID, </strong>which will be generated when a user submits a new Item using theÂ form.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile database configure</pre><pre>? Select from one of the choices below. Remove table from the project<br>? Select table to be deleted AWSMobileTable<br>? Are you sure you want to delete the table Yes</pre><pre>$ awsmobile database configure</pre><pre>Welcome to NoSQL database wizard<br>You will be asked a series of questions to help determine how to best construct your NoSQL database table.</pre><pre>? Should the data of this table be open or restricted by user? Open<br>? Table name ServerlessReactExample</pre><pre>You can now add columns to the table.</pre><pre>? What would you like to name this column ID<br>? Choose the data type string<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemName<br>? Choose the data type string<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemPrice<br>? Choose the data type number<br>? Would you like to add another column Yes<br>? What would you like to name this column ItemDescription<br>? Choose the data type string<br>? Would you like to add another column No</pre><pre>Before you create the database, you must specify how items in your table are uniquely organized. This is done by specifying a Primary key. The primary key uniquely identifies each item in the table, so that no two items can have the same key.<br>This could be and individual column or a combination that has &quot;primary key&quot; and a &quot;sort key&quot;.<br>To learn more about primary key:<br><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey</a></pre><pre>? Select primary key ID<br>? Select sort key (No Sort Key)</pre><pre>You can optionally add global secondary indexes for this table. These are useful when running queries defined by a different column than the primary key.<br>To learn more about indexes:<br><a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes</a></pre><pre>? Add index No</pre><pre>$ awsmobile push<br>[...]<br>contents in #current-backend-info/ is synchronized with the latest in the aws cloud</pre><p>Again, to keep things simple Iâ€™ve not added a sort key or an index, just the Primary key which is require for setting up theÂ db.</p><p>Letâ€™s quickly tweak our <strong>handleSubmit </strong>function to generate a uuid whenever we submit. In order to achieve this weâ€™ll use <a href="https://github.com/kelektiv/node-uuid"><strong>node-uuid</strong></a><strong>. </strong>Thereâ€™s a few different versions you can generate, but weâ€™ll use the <strong>uuidv1, </strong>which creates a timestamp uuid. This can be converted and tested on a site likeÂ <a href="https://www.famkruithof.net/uuid/uuidgen">this</a>.</p><pre>#bash </pre><pre>$ yarn add node-uuid</pre><pre>------------------------------------------------------------------</pre><pre><strong>#createItem.js</strong></pre><pre><strong>const uuidv1 = require(&#39;uuid/v1&#39;);</strong></pre><pre>[...]<br>handleSubmit(event) {<br>    console.log(this);<br>    let apiName = &#39;sampleCloudApi&#39;;<br>    let path = &#39;/items&#39;;<br>    let newItem = {<br>      body: {<br>          <strong>ID: uuidv1()</strong>, name: this.state.itemName, price: this.state.itemPrice, description: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>    this.handleClose()<br>  }<br>[...]</pre><p>Lastly, we need to configure our <strong>cloud-api </strong>to use our newly created database.</p><pre>#bash</pre><pre>awsmobile cloud-api configure</pre><pre>This feature will create an API using Amazon API Gateway and AWS Lambda. You can optionally have the lambda function perform CRUD operations against your Amazon DynamoDB table.</pre><pre>? Select from one of the choices below. Create CRUD API for an existing Amazon DynamoDB table<br>? Select Amazon DynamoDB table to connect to a CRUD API ServerlessReactExample<br>Adding lambda function code on:<br>/Users/jameshamann/Documents/Development/serverless-web-app-example/awsmobilejs/backend/cloud-api/rverlessReactExample/<br>...<br>Path to be used on API for get and remove an object should be like:<br>/ServerlessReactExample/object/:ID</pre><pre>Path to be used on API for list objects on get method should be like:<br>/ServerlessReactExample/:ID</pre><pre>JSON to be used as data on put request should be like:<br>{<br>  &quot;ID&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemDescription&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemName&quot;: &quot;INSERT VALUE HERE&quot;,<br>  &quot;ItemPrice&quot;: &quot;INSERT VALUE HERE&quot;<br>}<br>To test the api from the command line (after awsmobile push) use this commands<br>awsmobile cloud-api invoke ServerlessReactExampleCRUD &lt;method&gt; &lt;path&gt; [init]</pre><pre>$ awsmobile push</pre><p>This does change the name of your <strong>API, </strong>youâ€™ll notice mine is now called <strong>ServerlessReactExampleCRUD,</strong> with a <strong>path </strong>of <strong>/ServerlessReactExample. </strong>So in order to get things to work,<strong> </strong>youâ€™ll need to update the <strong>apiName and path </strong>in your code to reflectÂ this.</p><p>Now letâ€™s create a new item in our form and hit Submit. We still donâ€™t see anything, but if we head over to the <a href="https://aws.amazon.com/dynamodb">AWS DynamoDB Console</a>, weâ€™ll see our item has been successfully saved in our database!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xZ2kgys68NggdswMMe_yQA.png"/></figure><h4>Read</h4><p>Now that we can successfully Create items, letâ€™s work on Reading them in our dashboard. Instead of reading one Item at a time, Iâ€™m going to fetch all Items in our database and display them on our itemDashboard. To do this, weâ€™ll need to slightly alter our Lambda code to include a function that returns all items from our DynamoDBÂ Table.</p><p>DynamoDB provides us with aÂ <strong>.scan </strong>method, which returns all items, similar to a <em>SELECT * from tablename</em> in SQL. Letâ€™s start off by editing our <strong>app.js </strong>within our <strong>backend </strong>folder and include a route that retrieves allÂ data.</p><pre>#<strong>awsmobilejs/backend/yourLambdaFunctionName/app.js</strong></pre><pre>[...]</pre><pre>app.get(&#39;/ServerlessReactExample&#39;, function(req, res) {</pre><pre>var params = {<br>    TableName: tableName,<br>    Select: &#39;ALL_ATTRIBUTES&#39;,<br>};</pre><pre>dynamodb.scan(params, (err, data) =&gt; {<br>       if (err) {<br>         res.json({error: &#39;Could not load items: &#39; + err.message});<br>       }</pre><pre>res.json({<br>           data: data.Items.map(item =&gt; {<br>             return item;<br>           })<br>       });<br>   });<br>});</pre><pre>[...]</pre><pre>-------------------------------------------------------------------</pre><pre>#bash</pre><pre>$ awsmobile push<br>[...]</pre><p>Be sure to add the function just above the other routes and to push your changes to the awsÂ cloud.</p><p>Once everything has been pushed and updated, reload your app and, if everythingâ€™s setup correctly, you should see all items from the database.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/848/1*mOAAlE3_bDNddPPw-4C01g.png"/><figcaption>After refreshing</figcaption></figure><p>Letâ€™s update our itemDashboard so that it correctly displays the data fetched from the database. Weâ€™ll iterate through our JSON response and for each item, weâ€™ll display the <strong>name, price </strong>and <strong>description </strong>on a <strong>Card. </strong>Weâ€™ll require another library, <strong>lodash</strong>, which basically makes working with objects a lotÂ easier.</p><pre>#bash </pre><pre>$ yarn add loadash</pre><pre>-------------------------------------------------------------------</pre><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import {Container, Card} from &#39;semantic-ui-react&#39;<br><strong>import Amplify, { API } from &#39;aws-amplify&#39;;<br>import _ from &#39;lodash&#39;;</strong></pre><pre>let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>let path = &#39;/ServerlessReactExample&#39;;</pre><pre>class ItemDashboard extends Component {</pre><pre><strong>constructor(props){<br>    super(props)<br>    this.state = {itemData: {}}<br>  }</strong></pre><pre><strong>getItems(){<br>    API.get(apiName, path).then(response =&gt; {<br>      console.log(response)<br>      this.setState({<br>       itemData: response.data<br>      });<br>    });<br>  }</strong></pre><pre>componentDidMount(){<br>    <strong>this.getItems()<br></strong>  }</pre><pre>render() {<br><strong>    const itemData = this.state.itemData;<br></strong>    <strong>return (<br>      &lt;div&gt;</strong></pre><pre>&lt;CreateItemModal/&gt;<strong>        <br>&lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Â£ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</strong></pre><pre>export default ItemDashboard;</pre><p>We move our GET request into itâ€™s own function, <strong>getItems() </strong>and call it during the <strong>componentDidMount </strong>function. Then, in our <strong>render </strong>function, we set <strong>itemData </strong>equal to <strong>this.state.itemData, </strong>which is set during our <strong>getItems() function. </strong>In the UI, we _<strong>.map </strong>over our <strong>itemData </strong>and for each Item we return a Card with the <strong>ItemName</strong>, <strong>ItemPrice </strong>and <strong>ItemDescription</strong>. After reloading your app, the result should look something like theÂ below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dSNJl7GoDS8FYqbMxKn5WQ.png"/></figure><p>Before moving on, youâ€™ll notice in order to see your results after a form submission youâ€™ll need to refresh. Letâ€™s fix that with a callback and set the state of <strong>this.state.itemData </strong>to get updated when we submit ourÂ form.</p><pre>#<strong>src/screens/itemDashboard.js</strong></pre><pre>[...]</pre><pre>render() {<br>    const itemData = this.state.itemData;<br>    return (<br>      &lt;div&gt;</pre><pre><strong>&lt;CreateItemModal getItems={this.getItems}/&gt;<br></strong>&lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            &lt;Card&gt;<br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                    {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Â£ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>[...]</pre><pre>-------------------------------------------------------------------<br>#<strong>src/screens/createItem.js</strong></pre><pre>[...]</pre><pre>handleSubmit(event) {<br>    console.log(this);<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &#39;/ServerlessReactExample&#39;;<br>    let newItem = {<br>      body: {<br>          &quot;ID&quot;: uuidv1(),<br>          &quot;ItemName&quot;: this.state.itemName,<br>          &quot;ItemPrice&quot;: this.state.itemPrice,<br>          &quot;ItemDescription&quot;: this.state.itemDescription<br>        }<br>      }<br>    API.post(apiName, path, newItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    event.preventDefault();<br>   <strong> this.props.getItems()</strong><br>    this.handleClose()<br>  }</pre><pre>[...]</pre><p>We pass the function down from <strong>ItemDashboard </strong>to <strong>createItem</strong>.</p><h4>Update</h4><p>Next, weâ€™ll look at Updating our Items, if we want to change the price, forÂ example.</p><p>Letâ€™s create another modal, exactly the same as our <strong>createItem.js, </strong>but letâ€™s call it <strong>editItem.js. </strong>Alot of the contents will be similar as itâ€™s essentially the same form, just for editing anÂ item.</p><pre><strong>#src/screens/editItem.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import { Form, Modal, Button, Container, Icon } from &#39;semantic-ui-react&#39;<br>import Amplify, { API } from &#39;aws-amplify&#39;;<br>const uuidv1 = require(&#39;uuid/v1&#39;);</pre><pre>class EditItemModal extends Component {</pre><pre>constructor(props) {<br>    super(props)<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br><strong>    this.state = { item: this.props.item };<br></strong>  }</pre><pre>handleChange(event, {name, value}) {<br>    this.setState({ [name]: value });<br>  }</pre><pre>handleSubmit(event) {<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &#39;/ServerlessReactExample&#39;;<br><strong>    let editItem = {<br></strong>      body: {<br><strong>          &quot;ID&quot;: this.props.item[0].ID,<br></strong>          &quot;ItemName&quot;: this.state.itemName,<br>          &quot;ItemPrice&quot;: this.state.itemPrice,<br>          &quot;ItemDescription&quot;: this.state.itemDescription<br>        }<br>      }<br>    API.put(apiName, path, editItem).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });</pre><pre>    this.props.getItems()<br>    this.handleClose()<br>    event.preventDefault();<br>  }</pre><pre>handleOpen = () =&gt; this.setState({ modalOpen: true })</pre><pre>handleClose = () =&gt; this.setState({ modalOpen: false })</pre><pre>render () {<br>      <strong>return (<br>        &lt;Container style={{padding: 10}}&gt;<br>            &lt;Modal trigger={&lt;Button icon onClick={this.handleOpen}&gt;&lt;Icon name=&#39;edit&#39; /&gt;&lt;/Button&gt;}open={this.state.modalOpen}  closeIcon </strong> <strong>onClose={this.handleClose}&gt;<br>              &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;<br>              &lt;Modal.Content&gt;<br>                &lt;Form onSubmit={this.handleSubmit}&gt;<br>                &lt;Form.Group unstackable widths={2}&gt;<br>                  &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Edit Item Name...&#39; onChange={this.handleChange}  value={this.state.itemName} /&gt;<br>                  &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Â£0.00&#39; onChange={this.handleChange}  value={this.state.itemPrice} /&gt;<br>                &lt;/Form.Group&gt;<br>                &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item Description&#39; placeholder=&#39;Edit Description of the Item...&#39; onChange={this.handleChange}  value={this.state.itemDescription} /&gt;<br>                  &lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>                &lt;/Form&gt;<br>            &lt;/Modal.Content&gt;<br>          &lt;/Modal&gt;<br>       &lt;/Container&gt;</strong><br>      );<br>    }<br>  }</pre><pre>export default EditItemModal;</pre><p>Essentially this is the same code as whatâ€™s in <strong>createItem.js, </strong>the only difference is weâ€™re receiving props weâ€™ve sent from our parent component <strong>itemDashboard.js, </strong>in order to retrieve the itemâ€™s ID. This is important, as we require the ID in order to make sure weâ€™re updating the correct item in our database.</p><p>To send the Item to our <strong>EditItemModalÂ </strong>, we need to create a function that fetches the item. Weâ€™ll do this in our <strong>ItemDashboard</strong> and send the response to our <strong>EditItemModal </strong>throughÂ props.</p><pre><strong>#src/screens/ItemDashboard.js<br>[...]</strong></pre><pre><strong>import EditItemModal from &#39;./editItem.js&#39;</strong></pre><pre>[...]</pre><pre><strong>getItem(id){<br>  let single_path = &#39;/ServerlessReactExample/&#39; + id<br>  console.log(single_path)<br>  API.get(apiName, single_path).then(response =&gt; {<br>    console.log(response)<br>    this.setState({<br>      item: response<br>    })<br>  });<br>}</strong></pre><pre>[...]</pre><pre>return (<br>      &lt;div&gt;<br>        &lt;Container style={{padding: 10}}&gt;<br>        &lt;Card.Group&gt;<br>        {_.map(itemData, ({ID, ItemName, ItemPrice, ItemDescription }) =&gt; (<br>            <strong>&lt;Card onClick={() =&gt; this.getItem(ID)}&gt;</strong><br>              &lt;Card.Content&gt;<br>                &lt;Card.Header&gt;<br>                {ItemName}<br>                &lt;/Card.Header&gt;<br>                &lt;Card.Meta&gt;<br>                  Â£ {ItemPrice}<br>                &lt;/Card.Meta&gt;<br>                &lt;Card.Description&gt;<br>                    {ItemDescription}<br>                &lt;/Card.Description&gt;<br>              &lt;/Card.Content&gt;<br><strong>              &lt;EditItemModal item={Object.values(this.state.item) getItems={(this.getItems)} /&gt;<br></strong>            &lt;/Card&gt;<br>          ))}<br>        &lt;/Card.Group&gt;<br>      &lt;/Container&gt;<br>    &lt;/div&gt;<br>    );</pre><p>Donâ€™t forget to import the <strong>EditItemModal, </strong>as weâ€™ll be rendering this within our dashboard on each card. Our function, <strong>getItem, </strong>takes an ID as itâ€™s argument, the ID is then appended to the path used within our GET request, which returns all information on the requested Item. We then set the state of <strong>item </strong>equal to the response of our call and send that data through to our <strong>EditItemModal.</strong></p><p>Once Complete, you should have a dashboard similar to this, with the ability to edit the item youâ€™ve clickedÂ on.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DRRHjfv4wJGjOo7bnTDN1w.png"/></figure><p>Awesome! Lastly, letâ€™s quickly implement our last CRUD function, delete.</p><h4>Delete</h4><p>Implementing a delete function is fairly quick, as most of the work is already done. Weâ€™ll add the delete function to our <strong>EditItemModal</strong>, as itâ€™s probably the best place forÂ it.</p><pre>#<strong>src/screens/editItem.js</strong></pre><pre>[...]</pre><pre>constructor(props) {<br>    super(props)<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br><strong>    this.deleteItem = this.deleteItem.bind(this);</strong></pre><pre>this.state = { item: this.props.item };<br>  }</pre><pre><strong>deleteItem(){<br>    let apiName = &#39;ServerlessReactExampleCRUD&#39;;<br>    let path = &quot;/ServerlessReactExample/object/&quot; + this.props.item[0].ID<br>    API.del(apiName, path).then(response =&gt; {<br>    console.log(response)<br>    }).catch(error =&gt; {<br>        console.log(error.response)<br>    });<br>    this.props.getItems()</strong></pre><pre><strong>    this.handleClose()<br>  }</strong></pre><pre><strong>[...]</strong></pre><p>Very simply, our function makes a delete request, using <strong>API </strong>component, with the ID appended to the path. The ID is required so the function knowâ€™s which Item to delete from our database. Donâ€™t forget to bind our function to <strong>this</strong>, otherwise weâ€™ll get undefined errors when trying to retrieve ourÂ <strong>ID.</strong></p><p>Lastly, letâ€™s render a Delete button on our Modal and link it all together.</p><pre>#<strong>src/screens/editItem.js</strong></pre><pre>return (<br>        &lt;Container style={{padding: 10}}&gt;<br>            &lt;Modal trigger={&lt;Button icon onClick={this.handleOpen}&gt;&lt;Icon name=&#39;edit&#39; /&gt;&lt;/Button&gt;} open={this.state.modalOpen} closeIcon onClose={this.handleClose}&gt;<br>              &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;<br>              &lt;Modal.Content&gt;<br>                &lt;Form onSubmit={this.handleSubmit}&gt;<br>                &lt;Form.Group unstackable widths={2}&gt;<br>                  &lt;Form.Input name=&#39;itemName&#39; label=&#39;Item Name&#39; placeholder=&#39;Edit Item Name...&#39; onChange={this.handleChange}  value={this.state.itemName} /&gt;<br>                  &lt;Form.Input name=&#39;itemPrice&#39; label=&#39;Item Price&#39; placeholder=&#39;Â£0.00&#39; onChange={this.handleChange}  value={this.state.itemPrice} /&gt;<br>                &lt;/Form.Group&gt;<br>                &lt;Form.TextArea name=&#39;itemDescription&#39; label=&#39;Item Description&#39; placeholder=&#39;Edit Description of the Item...&#39; onChange={this.handleChange}  value={this.state.itemDescription} /&gt;<br>                  &lt;Form.Button type=&#39;submit&#39;&gt;Submit&lt;/Form.Button&gt;<br>                &lt;/Form&gt;<br>            &lt;/Modal.Content&gt;<br>           <strong> &lt;Modal.Actions&gt;<br>              &lt;Button icon labelPosition=&#39;left&#39; onClick={this.deleteItem}&gt;<br>              &lt;Icon name=&#39;delete&#39; /&gt;<br>                Delete Item<br>              &lt;/Button&gt;<br>            &lt;/Modal.Actions&gt;</strong><br>          &lt;/Modal&gt;<br>       &lt;/Container&gt;</pre><p>Once completed, your <strong>EditItemModal</strong> should look like this. When clicking delete, and after a refresh, youâ€™ll notice the item has beenÂ removed.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-G3bneervjaVbEsLngqtRA.png"/></figure><p>This has been quite a long post, so well done if youâ€™ve made it this far! You now have a, real basic, Serverless React Web App! There are still a lot of things that need to be cleaned up and refactored, like perhaps adding the Item Title to the <strong>EditItemModal</strong>, so we know what weâ€™re editing and adding maybe adding some validation to our forms? Thereâ€™s a lot of scope for improvement and enhancement here, but this gives you a solid foundation to moveÂ forward.</p><p>The next, and final, part on this mini series will be focused around Adding Authentication, with Amplify, as well as the Deployment and Distribution of your app throughÂ AWS.</p><p><strong>All source code for the project can be foundÂ </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d740ee8e7456" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Serverless React Web App with AWS Amplify â€” Part One</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_0jTP7l27uwj2CPLpqnVdw.jpeg"/></figure><p>Having previously posted about <a href="https://medium.com/@jameshamann/accelerating-mobile-app-development-with-aws-amplify-fb2034e60160">Accelerating Mobile Development with AWS Amplify</a>, I thought Iâ€™d do the same for the Web, using <a href="https://github.com/aws/aws-amplify">AWS Amplify</a>, Amazonâ€™s new JavaScript Library for app development.</p><p><strong>All source code for the project can be foundÂ </strong><a href="https://github.com/jameshamann/serverless-web-app-example"><strong>here.</strong></a></p><p>Before diving in, itâ€™s probably worth understanding, at least at a high level, the architecture behind serverless apps and how theyÂ work.</p><h4>What is a Serverless Application?</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eIECK-X8x_9wfu9uShspHw.png"/><figcaption>High Level Serverless Application Model</figcaption></figure><p>This diagram represents, at a high level, the architecture of a serverless application. Our static content (React Web App) is stored in an S3 bucket served up to the client, either from CloudFront or directly. This communicates with API Gateway. From here this triggers a Lambda function (which handles all our back end logic) and communicates with DynamoDB to get, save, delete or whatever depending on what request was sent from theÂ client.</p><h4>What are the benefits?</h4><p>Cost. You only pay for the compute time you use. This works great if you have large fluctuations in traffic/requests. It also takes the hassle of maintaining a server away and some what simplifies things so you can focus on building your product. Obviously, every app has itâ€™s own requirements and serverless architecture may not fit in all cases, but for the most part it provides a good framework to deploy applications at low cost, with minimal configuration.</p><h4>What weâ€™ll beÂ building</h4><p>To keep things nice and simple, and to avoid the stale recycled todo example, weâ€™ll build an online inventory with basic CRUD functions. Iâ€™m sure it goes without saying but youâ€™d need an AWS Account, which you can get get <a href="https://aws.amazon.com/">here</a>. Iâ€™d also advise you to keep an eye on your billing statement so you donâ€™t incur any unexpected charges.</p><h4>Getting Started</h4><p>Firstly, weâ€™ll need to install the <strong>awsmobile-cli </strong>and configure it with our AWSÂ Keys.</p><pre><strong>#bash</strong></pre><pre>$ npm install -g awsmobile-cli<br>[...]<br><br>$ awsmobile configure<br>$ configure aws<br>? accessKeyId:  [ENTER YOUR ACCESS KEY ID] #hit enter<br>? secretAccessKey: [ENTER YOUR SECRET ACCESS KEY] #hit enter<br>? region:  eu-west-2 #select your region using arrows and hit enter</pre><p>Next, weâ€™ll use <a href="https://github.com/facebook/create-react-app">create-react-app</a> to scaffold up a React App forÂ us.</p><pre><strong>#bash </strong></pre><pre>$ create-react-app serverless-web-app-example<br>[...]<br>âœ¨  Done in 17.74s.</pre><pre>Success! Created serverless-web-app-example at /Users/jameshamann/Documents/Development/serverless-web-app-example<br>Inside that directory, you can run several commands:</pre><pre>yarn start<br>    Starts the development server.</pre><pre>yarn build<br>    Bundles the app into static files for production.</pre><pre>yarn test<br>    Starts the test runner.</pre><pre>yarn eject<br>    Removes this tool and copies build dependencies, configuration files<br>    and scripts into the app directory. If you do this, you canâ€™t go back!</pre><pre>We suggest that you begin by typing:</pre><pre>cd serverless-web-app-example<br>  yarn start</pre><pre>Happy hacking!<br>$ cd serverless-web-app-example</pre><p>Letâ€™s fire up our app to make sure itâ€™s all setup correctly.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kBjOFtIFilxIiY6WQMR0sA.png"/><figcaption>React StarterÂ Page</figcaption></figure><p>Great, looks good! Now lets install <strong>aws-amplify </strong>and <strong>aws-amplify-react</strong> (which just contains helpers and higher order components for react) within ourÂ project.</p><pre><strong>#bash</strong> </pre><pre>$ npm install aws-amplify --save <br>[...]<br>$ npm install aws-amplify-react --save<br>[...]</pre><p>Once this is all installed, weâ€™ll need to setup our backend. To initialise a project, we use the <strong>awsmobile init </strong>command within the root of our project. Youâ€™ll be prompted a few questions, usually the default answers provided are correct so you should be able to hit enter for each ofÂ them.</p><pre><strong>#bash </strong></pre><pre>$ awsmobile init<br>[...]</pre><pre>âœ¨  Done in 5.30s.<br>yarn add aws-amplify-react returned 0</pre><pre>Success! your project is now initialized with awsmobilejs</pre><pre>awsmobilejs/.awsmobile<br>     is the workspace of awsmobile-cli, please do not modify its contents</pre><pre>awsmobilejs/#current-backend-info<br>     contains information of the backend awsmobile project from the last<br>     synchronization with the cloud</pre><pre>awsmobilejs/backend<br>     is where you develop the codebase of the backend awsmobile project</pre><pre>awsmobile console<br>     opens the web console of the backend awsmobile project</pre><pre>awsmobile run<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and runs the frontend application locally</pre><pre>awsmobile publish<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and publishes the frontend application to aws S3 for hosting</pre><pre>Happy coding with awsmobile!</pre><p>This command creates all the necessary resources in AWS for your backend, as well as creating a <strong>awsmobilejs </strong>folder within the root of your project, which contains basic information about yourÂ project.</p><p>Lastly, weâ€™ll need to hook up our client (React app) to our newly created backend. In your appâ€™s entry point (usually App.js) include the bolded code in the snippet. This just imports the Amplify Library and configures it using a file called <strong>aws_exports </strong>which is generated when you initialise your backend, in the previousÂ step.</p><pre><strong># App.js </strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import logo from &#39;./logo.svg&#39;;<br>import &#39;./App.css&#39;;<br><strong>import Amplify from &#39;aws-amplify&#39;;<br>import aws_exports from &#39;./aws-exports&#39;;</strong></pre><pre><strong>Amplify.configure(aws_exports);</strong></pre><pre>class App extends Component {<br>  render() {<br>    return (<br>      &lt;div className=&quot;App&quot;&gt;<br>        &lt;header className=&quot;App-header&quot;&gt;<br>          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;<br>          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;<br>        &lt;/header&gt;<br>        &lt;p className=&quot;App-intro&quot;&gt;<br>          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br>        &lt;/p&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default App;</pre><h4>Lambda and APIÂ Setup</h4><p>Now weâ€™ve got the basic infrastructure setup, letâ€™s setup Lambda, API Gateway and DynamoDB for our basic CRUD functions. To do this, run the <strong>awsmobile features </strong>command. From here, you can see what features youâ€™re able to activate and what features are available as default. For now we only require <strong>cloud-api </strong>and <strong>database </strong>to be selected and activated.</p><pre><strong>#bash </strong></pre><pre>awsmobile features</pre><pre>? select features:<br> â—¯ user-signin<br> â—¯ user-files<br> â—‰ cloud-api<br>â¯â—‰ database<br> â—‰ analytics<br> â—‰ hosting</pre><pre># hit space to select the features you&#39;d like and enter to confirm</pre><p>Whenever you change something locally, as weâ€™ve just done, weâ€™ll need to push it to AWS so the changes can takeÂ effect.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile push</pre><p>Once everythingâ€™s been initialised and pushed, have a poke around the <strong>backend</strong> directory, within <strong>awsmobilejs.</strong> There should be a <strong>cloud-api </strong>directory that contains your Lambda Project and a bunch of boilerplate code to get you started. By default, Lambda is setup to use AWSâ€™s Serverless Express Framework for Node.js, so if youâ€™re experienced with Node.js and Express, everything should look pretty familiar.</p><p>At this point, I like to do a quick check to make sure the Client and Backend are setup and talking to each other. To do this, I write a get request within the <strong>componentDidMount </strong>function, so as soon as our Component mounts, it fetches data from our backend and logs it to the console. AWS Amplify provides a component, API, to handle all requests to ourÂ backend.</p><pre><strong># App.js</strong></pre><pre>import React, { Component } from &#39;react&#39;;<br>import logo from &#39;./logo.svg&#39;;<br>import &#39;./App.css&#39;;<br><strong>import Amplify, { API } from &#39;aws-amplify&#39;;<br></strong>import aws_exports from &#39;./aws-exports&#39;;</pre><pre>Amplify.configure(aws_exports);</pre><pre><strong>let apiName = &#39;sampleCloudApi&#39;;<br>let path = &#39;/items&#39;;</strong></pre><pre>class App extends Component {</pre><pre><strong>componentDidMount(){<br>    API.get(apiName, path).then(response =&gt; {<br>      console.log(response)<br>    });<br>  }</strong></pre><pre>render() {<br>    return (<br>      &lt;div className=&quot;App&quot;&gt;<br>        &lt;header className=&quot;App-header&quot;&gt;<br>          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;<br>          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;<br>        &lt;/header&gt;<br>        &lt;p className=&quot;App-intro&quot;&gt;<br>          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br>        &lt;/p&gt;<br>      &lt;/div&gt;<br>    );<br>  }<br>}</pre><pre>export default App;</pre><p>If youâ€™ve poked around the Lambda app.js file, youâ€™ll notice we should be expecting a response of <strong>({success: â€˜get call succeed!â€™, url: req.url}).</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*T-GpqFtmKzSIPWZeuqQ0Zw.png"/></figure><p>Ok, you might need to squint, but if you check the console youâ€™ll see our request object <strong>{success: â€œget call succeeded!â€, url: /itemsâ€}. </strong>Great! Everythingâ€™s hooked up and ready toÂ go.</p><p>In the next part weâ€™ll look at setting our Front End Pages up and creating the basic CRUD Functions.</p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><h4><a href="https://medium.com/@jameshamann/serverless-react-web-app-with-aws-amplify-part-two-d740ee8e7456">Serverless React Web App with AWS Amplifyâ€Šâ€”â€ŠPart Two Available Here</a></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><p><strong>This story is published in </strong><a href="http://blog.usejournal.com"><strong>Noteworthy</strong></a><strong>, where thousands come every day to learn about the people &amp; ideas shaping the products weÂ love.</strong></p><p><a href="http://blog.usejournal.com"><strong>Follow our publication</strong></a><strong> to see more product &amp; design stories featured by the </strong><a href="https://usejournal.com/?/utm_source=usejournal.com&amp;utm_medium=blog&amp;utm_campaign=guest_post&amp;utm_content=james_hamann"><strong>Journal</strong></a><strong>Â team.</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=414e9402d92a" width="1" height="1"><hr><p><a href="https://blog.usejournal.com/serverless-react-web-app-with-aws-amplify-part-one-414e9402d92a">Serverless React Web App with AWS Amplify â€” Part One</a> was originally published in <a href="https://blog.usejournal.com">Noteworthy - The Journal Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Accelerating Mobile App Development with AWS Amplify</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*6afwPNkz6LnroeA0lfyC2g.png"/></figure><p>Over the last couple of months AWS have released a new Library, <a href="https://github.com/aws/aws-amplify">AWS Amplify</a>, both for Web Development and React Native Mobile Development. The purpose is to provide <em>a declarative and easy-to-use interface across different categories of cloud operations. </em>If youâ€™re already using AWS Services, it plugs directly in, but it also designed in such a way to plug in with any other backed/cloud service that youÂ use.</p><p>Having used it on a few projects myself, it made key areas of app development a breeze and accelerates the development of an app greatly. Services include Authentication through <a href="https://aws.amazon.com/cognito/">AWS Cognito,</a> No-SQL Databaseâ€™s through <a href="https://aws.amazon.com/dynamodb/">DynamoDB</a> and hosting through <a href="https://aws.amazon.com/s3/">S3</a> and <a href="https://aws.amazon.com/cloudfront/">CloudFont</a>. It connects everything so easily and quickly that it gives you the time to focus on actually developing theÂ app.</p><p>Iâ€™ll briefly walkthrough the process of scaffolding a simple <strong>awsmobile</strong> project, to demonstrate how easy and quick it is to get going. Iâ€™ll assume you have the basics, like <a href="https://nodejs.org/en/">node</a>, <a href="https://facebook.github.io/react-native/docs/getting-started.html">react-native-cli</a> or <a href="https://facebook.github.io/react-native/docs/getting-started.html">create-react-native-cli</a> installed already.</p><p>Obviously, first things first, make sure youâ€™ve got <a href="https://aws.amazon.com/cli/">aws</a> and <a href="https://github.com/aws/awsmobile-cli">awsmobile</a> CLI (npm install awsmobile-cliâ€Šâ€”â€Šglobal) installed and ready to go, youâ€™ll also want to make sure youâ€™ve got your AWS_ACCESS_KEY and AWS_SECRET_KEY toÂ hand.</p><p>Letâ€™s setup our CLI to ensure it can connect toÂ AWS.</p><pre><strong>#bash </strong></pre><pre>$ awsmobile configure<br>$ configure aws<br>? accessKeyId:  [ENTER YOUR ACCESS KEY ID] #hit enter<br>? secretAccessKey: [ENTER YOUR SECRET ACCESS KEY] #hit enter<br>? region:  eu-west-2 #select your region using arrows and hit enter</pre><p>Now youâ€™re all setup and connected to AWS letâ€™s setup yourÂ app.</p><h4>Setup</h4><p>Iâ€™ll leave it up to you to decide whether you choose to use create-react-native-app or react-native-init, both have there advantages and disadvantages that are beyond the spec of this post. Iâ€™ll be using react-native init.</p><pre>#<strong>bash </strong></pre><pre>react-native init awsMobileApp<br>This will walk you through creating a new React Native project in /Users/jameshamann/Documents/Development/awsMobileApp<br>Using yarn v1.3.2<br>Installing react-native...<br>[...]<br>âœ¨  Done in 6.10s.<br>To run your app on iOS:<br>   cd /Users/jameshamann/Documents/Development/awsMobileApp<br>   react-native run-ios<br>   - or -<br>   Open ios/awsMobileApp.xcodeproj in Xcode<br>   Hit the Run button<br>To run your app on Android:<br>   cd /Users/jameshamann/Documents/Development/awsMobileApp<br>   Have an Android emulator running (quickest way to get started), or a device connected<br>   react-native run-android</pre><p>Next youâ€™ll probably want to set up your Github repo and push everything up. Then install both AWS Amplify and AWS Amplify ReactÂ Native.</p><pre>#<strong>bash </strong></pre><pre>$ npm install aws-amplify --save<br>$ npm install aws-amplify-react-native --save</pre><p>Now weâ€™ll initialise a awsmobile project, which will setup a backend for our app and connect it to AWSMobile hub.</p><pre><strong>#bash</strong></pre><pre>awsmobile init</pre><pre>Please tell us about your project:<br>? Where is your project&#39;s source directory:  /<br>? Where is your project&#39;s distribution directory that stores build artifacts:  /<br>? What is your project&#39;s build command:  npm run-script build<br>? What is your project&#39;s start command for local test run:  npm run-script start</pre><pre>? What awsmobile project name would you like to use:  awsMobileAppExample</pre><pre>Successfully created AWS Mobile Hub project: awsMobileAppExample</pre><pre>retrieving the latest backend awsmobile project information<br>awsmobile project&#39;s details logged at: awsmobilejs/#current-backend-info/backend-details.json<br>awsmobile project&#39;s access information logged at: awsmobilejs/#current-backend-info/aws-exports.js<br>awsmobile project&#39;s access information copied to: aws-exports.js<br>awsmobile project&#39;s specifications logged at: awsmobilejs/#current-backend-info/mobile-hub-project.yml<br>contents in #current-backend-info/ is synchronized with the latest in the aws cloud</pre><pre>Executing yarn add aws-amplify ...<br>[...]<br>Success! your project is now initialized with awsmobilejs</pre><pre>awsmobilejs/.awsmobile<br>     is the workspace of awsmobile-cli, please do not modify its contents</pre><pre>awsmobilejs/#current-backend-info<br>     contains information of the backend awsmobile project from the last<br>     synchronization with the cloud</pre><pre>awsmobilejs/backend<br>     is where you develop the codebase of the backend awsmobile project</pre><pre>awsmobile console<br>     opens the web console of the backend awsmobile project</pre><pre>awsmobile run<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and runs the frontend application locally</pre><pre>awsmobile publish<br>     pushes the latest development of the backend awsmobile project to the cloud,<br>     and publishes the frontend application to aws S3 for hosting</pre><pre>Happy coding with awsmobile!</pre><p>That simple command pretty much sets everything up for you within a <strong>awsmobilejs</strong> directory within your app. If you head over to the AWS console, you should see your project, likeÂ this.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*Ae5TkV1NbfbXhKpomKPgSQ.png"/><figcaption>AWS MobileÂ Hub</figcaption></figure><p>AWS Mobile includes the main features youâ€™d need for your mobile app, and thereâ€™s obviously plenty of other AWS Services you can tie into your mobile app. The ones that come bundled in can be found by using the awsmobile command.</p><pre><strong>#bash</strong></pre><pre>$ awsmobile features</pre><pre>? select features:  (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)<br>â¯â—¯ user-signin<br> â—¯ user-files<br> â—¯ cloud-api<br> â—¯ database<br> â—‰ analytics<br> â—‰ hosting</pre><pre>[...]<br>enabled: user-signin<br>backend awsmobile project enabled features:<br>analytics, hosting, user-signin</pre><p>From here you can select whatever feature youâ€™d like to add, for arguments sake letâ€™s add authentication.</p><p>Next, weâ€™ll use AWS Amplifyâ€™s component <strong>withAuthenticator.</strong></p><p>Letâ€™s edit our <strong>App.js </strong>to include the component and then wrap our entire app around it. The main thing weâ€™ll need to edit is changing the class from <strong>export default class App extends Component </strong>to <strong>Class App extends Component </strong>and then export the App at the bottom of the file as an argument in our <strong>withAuthenticator </strong>component. Weâ€™ll also needÂ to</p><pre><strong>#javascript - App.js</strong></pre><pre>[...]</pre><pre>import Amplify from &#39;aws-amplify&#39;;<br>import { withAuthenticator } from &#39;aws-amplify-react-native&#39;;<br>import aws_exports from &#39;./aws-exports&#39;;<br>Amplify.configure(aws_exports);<br>[...]</pre><pre>class App extends Component&lt;Props&gt; { </pre><pre>[...]</pre><pre>}</pre><pre>export default withAuthenticator(App);</pre><p>Now letâ€™s boot our app up in an emulator. It should look similar to the below, with all the basics setup, including routing.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JLYQ4CNKr4DkriQS8WXL1Q.png"/><figcaption>Authentication Front EndÂ Setup</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dvNp1DqBL5xAwAP0ilppyA.png"/></figure><p>When trying to sign up, however, youâ€™ll notice thereâ€™s an error <strong>No userPool.</strong> Thatâ€™s because we havenâ€™t synced our backend with the cloudÂ yet.</p><pre><strong>#bash </strong></pre><pre>$awsmobile push</pre><pre>[...]</pre><p>Once this is complete, reboot your app on the emulator and try signing up. Boom, youâ€™ve got a full authentication system ready to go, built in with SMS confirmations. (please check AWS Billing/Charges to make sure you donâ€™t incur any unwanted charges). Once a user Signs up, theyâ€™ll be visible in your AWS CognitoÂ Pool.</p><p>Itâ€™s super simple to get setup and going with AWS, plus with the addition of AWS Amplify, itâ€™s even easier to connect essential AWS Services to yourÂ app.</p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb2034e60160" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>A brief guide to Semantic Versioning</b></h4> <p style="text-align:justify"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sr-foEv_uj2kJ4Ew6mhDvw.jpeg"/></figure><p>Whenever releasing a product or app, youâ€™ll want to version it. This helps users understand what stage the app is at and also helps when integrating the app into package managers. In Software Development, we version apps by following <strong>Semantic Versioning, </strong>which is a general template that everyone uses and understands.</p><blockquote>Why bother?</blockquote><p>Versioning our apps helps us keep track of whatâ€™s been added/removed at what point. It can get real hectic, real fast, especially in the early stages when youâ€™re releasing new features and fixing bugs. Youâ€™re gonna want to reference things that have been added or things that have beenÂ fixed.</p><blockquote>Where would I keep a track ofÂ this?</blockquote><p>You can <strong>tag </strong>your releases on <strong>Github </strong>using <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging"><strong>git tag.</strong></a><strong> </strong>Essentially, you just tag a version number to a specific commit, like a merge, push it and this appears on the repository under â€œreleasesâ€, with any notes youâ€™d like to add. Itâ€™s best to keep track of all these changes in a <strong>CHANGELOG, </strong>thereâ€™s a nice format to follow outlined <a href="https://keepachangelog.com/en/1.0.0/">here.</a> This way you can keep track of whatâ€™s been fixed and any upcoming features that are being released into the next version. Itâ€™s also important to remember, software is built for people. So people need to actually understand whatâ€™s going on and at what stage your apps currently at, having a well documented<strong> CHANGELOG</strong> helps provide a clear timeline and explanation of yourÂ app.</p><blockquote>Ok, so how do I go about versioning my app/package?</blockquote><h4>0â€Šâ€”â€ŠPre-MVP/Alpha</h4><p>At this stage, youâ€™re developing your app and still building towards an MVP. Thereâ€™s no real point differentating between versions here because itâ€™s not a useable product yet. During this period, the version will remain atÂ <strong>0.</strong></p><h4><strong>Major.Minor.Patchâ€Šâ€”â€ŠAlpha/Beta</strong></h4><p>Once you reach your <strong>MVP, </strong>you might iterate over this and create <strong>Alpha/Beta </strong>releases for users to test and supply feedback on. When creating your first release, youâ€™ll want to start versioning. This helps you keep track of your app and creates a timeline of what features were added when and what bugs have and have not been fixed yet. You might be wondering, what exactly constitutes a major, minor or patchÂ release.</p><p><strong>Major Releaseâ€Šâ€”â€Š</strong>Increment the first digit by 1 if the new features break backwards compatibility/current features</p><p><strong>Minor Releaseâ€Šâ€”â€Š</strong>Increment the middle digit by 1 if the new features donâ€™t break any existing features and are compatible with the app in itâ€™s currentÂ state.</p><p><strong>Patch Releaseâ€Šâ€”â€Š</strong>Increment the last digit by 1 if youâ€™re publishing bug/patch fixes to yourÂ app.</p><p>Before publishing your first, useable version, you might find yourself incrementing the middle and the last digit to keep track of Alpha/Beta releases. Only once youâ€™re ready for a proper, first release, should you start versioning fromÂ 1.0.0.</p><p>I canâ€™t stress enough the benefits of keeping a clean, well documented CHANGELOG. Regardless of whether your project is open source or not, itâ€™s vital to keep track of whatâ€™s been worked on. It helps guide you when deciding what features need work and gives you good insight into your releaseÂ cycle.</p><p>If youâ€™re interested in reading more, you can get the full breakdown of <a href="https://semver.org/">Semantic Versioning on theirÂ site.</a></p><p>As always, thanks for reading, hit ğŸ‘ if you like what you read and be sure to follow to keep up to date with futureÂ posts.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/728/1*UtabZw8_UJYPKlPvfMT0lQ.gif"/></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c6055d87c90e" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Hi Ezequiel FrescÃ³ Werchowsky, thanks for reading and getting in touch!</b></h4> <p style="text-align:justify"><p>Hi <a href="https://medium.com/u/92d053321ec7">Ezequiel FrescÃ³ Werchowsky</a>, thanks for reading and getting in touch! Apologies, it seems like I mightâ€™ve done, thank you for letting me know, Iâ€™ll update the post with theÂ changes.</p><p>Regarding your error, it looks like itâ€™s an issue with AWS and not being able to read your credentials. Have you downloaded the AWS CLI (<a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html">https://docs.aws.amazon.com/cli/latest/userguide/installing.html</a>), if so run the command: aws configure. This will prompt you to enter you AWS_ACCESS_KEY and your AWS_SECRET_ACCESS_KEY, which can be retrieved from the AWS console, under â€œMy Secruity Credentialsâ€, on the top right dropdown by your username.</p><p>Try the above and let me know if you run into any other issues, Iâ€™m happy toÂ help!</p><p>Thanks, James</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3be6aa3813e8" width="1" height="1"></p> </div> </div> <div class="row"> <div class="col s10 offset-s1"> <h4 style="text-align:center"><b>Ryan Pereira Thanks for reading and getting in touch!</b></h4> <p style="text-align:justify"><p><a href="https://medium.com/u/bf1bb52caac4">Ryan Pereira</a> Thanks for reading and getting inÂ touch!</p><p>Here, Iâ€™m explaining that you should setup a brand new jekyll site and add your Gem, that youâ€™ve just built, to the Gemfile and running bundle install. When adding your gem, you need to specify itâ€™s path, like this:<strong> gem â€œYOURTHEMEâ€ =&gt;Â :path =&gt; â€œpath/to/your/gemâ€.</strong></p><p>Looking at the error from your previous comment, I suggest running gem install bundler and gem install jekyll again, looks like maybe an issue with the Ruby Version. In which case it might be best to upgrade to 2.4 +. To upgrade your ruby version, you can install <a href="https://rvm.io/">RVM</a> (ruby version manager).</p><p>This is only applicable if youâ€™re looking to build your own Gem Theme and publish it. If you wish to use an existing theme, you can use the one I created (jekyll-material-theme) and customise it or grab one from <a href="http://jekyllthemes.org/">http://jekyllthemes.org/</a>.</p><p>Hope this helps a little! Let me know if you need anythingÂ else.</p><p>Thanks, James</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3e1c288759dc" width="1" height="1"></p> </div> </div> <p style="text-align: center"><a class="waves-effect waves-light btn green darken-2" target="_blank" href="https://medium.com/@jameshamann/"><i class="material-icons right">library_books</i>Read more at Medium</a></p> </div> <script type="text/javascript" src="/jameshamannassets/js/jquery-3.2.1.min.js"></script> <script type="text/javascript" src="/jameshamannassets/js/materialize.min.js"></script> <script src="/jameshamannassets/js/init.js"></script> </body> <footer class="page-footer"> <div class="footer-copyright" style="padding-left: 30px"> <i class="material-icons" style="padding-right:5px">copyright</i><p>2017 Copyright James Hamann | All rights reserved</p> </div> </footer> </html>